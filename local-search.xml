<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于MotionMatching的交互动动画技术工作总结</title>
    <link href="/2024/07/14/%E5%9F%BA%E4%BA%8EMotionMatching%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8A%A8%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <url>/2024/07/14/%E5%9F%BA%E4%BA%8EMotionMatching%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8A%A8%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>基于MotionMatching的交互动动画技术工作总结</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Motion Matching首先由Büttner和Clavet在2015年提出，该算法基于运动捕捉获得的动作数据库，用程序自动搜索最合适的下一帧，由此生成完整的动画。相比于以往主流采用的状态机动画，具有动画真实度更高、更节约人力和时间成本、能实现更高产能等特点。该算法在2016年在GDC2016由育碧正式提出，同年被应用于开发育碧的多人动作游戏荣耀战魂。之后又被应用于最后生还者，黑神话悟空等众多3A游戏中。在2021年，EA在GDC上分享了将Motion Matching与环境交互结合的技术并展示其在游戏Madden中的表现效果。2024年3月，UE5.4版本正式推出Motion Matching功能并于6月发布示例工程和相关动画数据。可以预见未来Motion Matching会被更加广泛地应用在游戏动作系统的开发中。</p><table><thead><tr><th><img src="/article_img/2024-07-14-17-56-06.png"></th><th><img src="/article_img/2024-07-14-17-57-49.png"></th></tr></thead></table><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一直以来，Motion Matching常被应用于角色Locomotion中，并取得了很好的效果。其实在交互动画领域，Motion Matching也能发挥奇效，EA的多人运动类游戏麦登橄榄球和FIFA中的角色间、角色与场景间的交互动画都有Motion Matching的身影。本课题聚焦的问题就是将Motion Matching应用到交互动动画，探索该技术在角色Locomotion之外的潜力。<br><img src="/article_img/Madden.gif"></p><h1 id="Motion-Matching算法"><a href="#Motion-Matching算法" class="headerlink" title="Motion Matching算法"></a>Motion Matching算法</h1><h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p>Motion Matching的思路可以总结为一句话：<strong>在动画数据库中检索出下一帧应该播放的那个姿势</strong>。</p><p>顺着这个思路要回答两个问题：</p><ol><li>下一帧应该播放哪个姿势（Pose）</li><li>如何从数据库中得到这一帧Pose</li></ol><p>首先，下一帧该播放的pose显然是和当前帧强相关的，不能与当前帧差距过大，因为动画的本质就是pose的连续播放，下一帧的pose如果与当前帧pose差距过大，就会破坏动画的连续性。其次，游戏中的角色动画都是可交互的（指玩家可以控制角色播放什么样的动画），那么下一帧pose也与玩家的输入有关。总结起来就是<strong>当前姿势</strong>和<strong>玩家输入</strong>。</p><p>接下来回答第二个问题，如何得到这个pose；我们需要在数据库中根据判断下一帧姿势的两个条件评估每个姿势是否是我们理想的姿势，当前姿势很好得到，从数据库中获得与当前姿势相似的姿势也很容易。因此重点在于如何使用玩家输入进行检索，容易想到根据玩家输入可以得到未来的运动趋势，如玩家当前时刻向左推摇杆那么之后一段时间角色就应该向左运动，那么就需要动画数据库中有特征用来表示每一个pose的运动趋势。MM算法就是这种思路，使用轨迹（Trajectory）来匹配玩家输入，这里的轨迹指的是一段连续姿势的特征，如未来几帧姿势的位置、方向等信息。在Offline阶段得到每个pose的一段时间内的轨迹，在Runtime时根据玩家的输入预测出相同时间段内的轨迹，在数据库中匹配哪个姿势的轨迹与当前预测出的轨迹最相似。将当前姿势和玩家输入两部分影响因素综合考虑，就可以得到最适合在下一帧播放的pose；</p><p>上面我们重点分析了两个因素：当前姿势和运动轨迹，其实在实际使用时还有很多因素会产生影响，对于角色Locomotion常见的因素还有角色当前运动速度和朝向。抽象出数学公式如下，为数据库中的每一个姿势计算Cost（这里的cost理解为与理想姿势间的差距），Cost最低的就是match到的下一帧播放的姿势。<br><img src="https://kenny-hoho.github.io/article_img/2024-01-24-20-32-52.png"></p><p>由上的算法思路分析可知，MM的关键点是要确定下一帧要播放哪个姿势再去想办法在数据库中得到这个姿势，<strong>抽象来说就是一个特征匹配的过程</strong>。具体到实现上，就需要提供方法分别在数据库中和runtime时提取姿势的特征。因此MM的流程如下：</p><ol><li><strong>确定特征</strong>：判断哪些因素会决定下一帧姿势</li><li><strong>提取特征</strong>：在Offline阶段为数据库中的每个姿势提取这些特征</li><li><strong>计算特征</strong>：在Runtime阶段计算下一帧期望播放的姿势的特征</li><li><strong>特征匹配</strong>：搜索数据库，进行特征匹配得到姿势</li><li><strong>姿势过渡</strong>：从当前姿势过渡到匹配结果</li></ol><h2 id="交互算法"><a href="#交互算法" class="headerlink" title="交互算法"></a>交互算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从MM的本质出发交互动MM的实现思路也很简单，可以从上面的两个问题开始思考，下一帧应该播放哪个姿势以及如何得到这个姿势。交互动动画中，决定下一帧播放哪个动画的因素显然除了角色Locomotion中用到的特征，还应该有交互特征，也就是描述环境信息的特征，比如希望让角色扶墙行走，就需要墙的特征。因此交互动MM的算法流程与基础的MM完全相同，只是需要对交互特征进行特殊处理。</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>交互动MM的思路很简单，只是在原有框架下加入新的特征即可，但是实现难点主要在于<strong>交互特征难以提取</strong>，也就是难以将动画数据中的交互特征提取出来并Bake到特征数据库。大部分的骨骼动画数据，都是以单个角色的骨架为单位存储动画数据的，对于交互式动画例如开门，受击等，也都只存储了角色骨骼的信息，对于门或者攻击来源的信息是完全没有的；因此如何从动画数据中得到这些交互物的信息是实现交互动MM的关键。<br>当然如果在动捕的时候捕捉了这些交互物</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>明确了需要交互特征和实现难点，我们可以先参考一下目前的一些工作是如何处理将MM与交互动动画相结合的。EA在GDC2021分享的工作Environmental and Motion Matched Interactions，是在EA2017年提出的N-teract技术的基础上用MM取代状态机实现的，N-teract是一种用于实现多人交互动画效果的技术，被应用在多人体育运动类游戏中，这类游戏往往有大量多人间的接触和交互，如篮球和橄榄球游戏。N-teract本质是匹配开始播放多人动画的入口，然后开始播放对应的多人动画，具体原理可以参考之前专门总结的文章。整个过程如下：</p><table><thead><tr><th><img src="/article_img/2023-12-14-11-35-41.png"></th><th><img src="/article_img/2023-12-14-11-35-58.png"></th></tr></thead></table><p>左图检测到了1号和3号，但是数据库中没有1号和3号同时存在的多人动画，故没有播放tackle动画，继续移动到了右图所示，检测到了1号和2号，数据库中有1号和2号同时存在的动画就播放。</p><p>而GDC2021上提出的EMMI是在N-teract过程结束后用MM代替直接播放对应动画：<br><img src="/article_img/2023-12-15-14-55-32.png"></p><p>由上图我们也可以看出，交互动MotionMatching最适用的场景是：<strong>“入口”相同但是期望播放的动画不同</strong>，否则完全可以根据“入口”的不同直接播放对应动画即可。因此在挑选测试场景时最好选择这种场景，我们最终选取了开门场景作为交互动MM的测试场景，开门时一般都需要走到门前，即交互“入口”相同，但是不同的门（如双开门，内开门，外开门）期望播放的动画不同，很适合使用交互动MM。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>本课题在Motion Sympathy插件的基础上进行开发，具体分析了<strong>交互物与角色有接触</strong>（如开门，受击等）的这一类交互动动画的特征提取方式。对于这类交互动动画，由于交互物与角色有接触，将角色与交互物接触过程中的接触点的骨骼当作交互物，那么就可以通过接触的骨骼间接得到接触过程中交互物的特征信息。除此之外，对于交互动MM需要调整轨迹预测算法，使得预测轨迹可以准确得停在对对应的交互点。</p><p>对于交互动动画的触发应该<strong>由被交互物决定</strong>，例如对于开门demo，可以准备不同种类的门（双开门，单开门，内&#x2F;外开门），在交互过程中通过不同的门的动画来决定当前角色应该播放哪个动画。<br>具体gameplay应为，玩家按下交互按键检测周围是否有门，如果有，门actor将此时的角色由locomotion状态切换为交互状态，并告知角色交互入口（即角色应该走到哪里停下开始开门）的位置和交互点相对角色根的相对位置（门把手）位置，角色开始向交互入口移动，由交互组件判断是否到达，如果到达就通知被交互物：门，开始播放打开动画。当门的开打动画播放完毕后，门actor将角色由交互状态切换为locomotion状态，整个交互过程结束。</p><p>可以看出，整个交互流程是由被交互物驱动的，这符合MotionMatching的算法思想：自动寻找合适的动画帧，而不是像动画状态机一样完全由角色决定当前应该播放的动画。</p><p>下面详细介绍为开门交互动MotionMatching测试demo开发的功能：</p><h2 id="功能1：开门框架"><a href="#功能1：开门框架" class="headerlink" title="功能1：开门框架"></a>功能1：开门框架</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>实现用MotionMatching驱动的开门效果，即角色走到门前播放开门动画，门被打开；</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现依靠<strong>CBP_InteractComponent</strong>蓝图类和<strong>BP_Door</strong>蓝图类，这两个类都继承接口 <strong>BPI_Interact</strong> 并实现该接口中定义的三个函数：<br><img src="/article_img/2024-05-21-14-32-04.png"></p><h4 id="交互接口：BPI-Interact"><a href="#交互接口：BPI-Interact" class="headerlink" title="交互接口：BPI_Interact"></a>交互接口：BPI_Interact</h4><ol><li><strong>InteractPrepare</strong>：被交互物（BP_Door）实现，实现交互前的准备工作，缓存发起交互的角色Investigator，并调用Investigator（能发起交互说明有交互组件且继承了<strong>BPI_Interact</strong>）实现的接口函数 <strong>MoveTo</strong>；<br><img src="/article_img/2024-05-21-14-33-16.png"></li><li><strong>MoveTo</strong>：交互组件实现，实现驱动带有交互组件的角色移动到对应的交互点；Location表示交互点位置，ActprTarget表示被交互物，LinkedActor可以是另一个对此交互做出反应的Actor，UseAnimation表示被交互物播放的动画（但是这里使用Timeline实现开门效果）<br><img src="/article_img/2024-05-21-14-37-04.png"></li><li><strong>Interact</strong>：被交互物（BP_Door）实现，实现由Timeline驱动的开关门效果；<br><img src="/article_img/2024-05-21-14-40-26.png"></li></ol><h4 id="交互组件：CBP-InteractComponent"><a href="#交互组件：CBP-InteractComponent" class="headerlink" title="交互组件：CBP_InteractComponent"></a>交互组件：CBP_InteractComponent</h4><ol><li>按下交互键进行<strong>SphereTraceForObjects</strong>，检测视角方向一定距离内有无可交互物（由是否是自定义的碰撞对象决定）<br><img src="/article_img/2024-05-21-14-45-34.png"><br>如果有可交互物，调用其实现的<strong>InteractPrepare</strong>接口函数进行交互前的准备；</li><li>实现<strong>MoveTo</strong>接口函数，使用bool变量 <strong>ShouldMove</strong> 判断是否已经走到交互点，如果还没走到交互点，在Tick中计算走到交互点的需要的方向（该方向为TrajectoryGenerator的输入）</li></ol><h4 id="角色蓝图：BP-MotionMatchingCharacter"><a href="#角色蓝图：BP-MotionMatchingCharacter" class="headerlink" title="角色蓝图：BP_MotionMatchingCharacter"></a>角色蓝图：BP_MotionMatchingCharacter</h4><p>如果是传统方法实现开门，不需要角色蓝图有任何多余的修改，只需要添加交互组件即可；<br>如果使用MotionMatching，需要根据交互组件中的bool变量ShouldMove判断<strong>是否应该向交互点移动</strong>，此时<strong>不使用用户输入</strong>生成轨迹，而<strong>使用交互组件中生成的移动方向</strong>生成轨迹：<br><img src="/article_img/2024-05-21-14-56-26.png"><br>同时，还需要根据交互组件中的bool变量Interacting判断是否开始了交互，需要切换MotionMatching输入特征构建时的MotionConfig：<br><img src="/article_img/2024-05-21-14-56-40.png"></p><h4 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h4><p>动画蓝图中需要根据是否处于Interact状态切换到交互状态机，交互状态机中有一个状态，其中为一个使用交互动画数据集的MotionMatching节点：<br><img src="/article_img/2024-05-21-14-59-15.png"></p><h2 id="功能2：交互特征（MatchFeature-Interaction）"><a href="#功能2：交互特征（MatchFeature-Interaction）" class="headerlink" title="功能2：交互特征（MatchFeature_Interaction）"></a>功能2：交互特征（MatchFeature_Interaction）</h2><p>要使用MotionMatching驱动交互动画，目前的思路是添加一个<strong>交互点位置特征</strong>，在Bake阶段得到交互点相对于角色根骨骼的相对位置，在Runtime阶段检测交互点的实时相对角色根骨骼的位置，进行Cost计算；</p><h3 id="Runtime阶段"><a href="#Runtime阶段" class="headerlink" title="Runtime阶段"></a>Runtime阶段</h3><p>在被交互物的Tick中判断是否开始了交互，即调用接口函数<strong>InteractPrepare</strong>直到接口函数<strong>Interact</strong>执行完成，在此期间每帧计算交互点相对于角色根骨骼的相对位置，并将该位置通过<strong>交互组件</strong>的函数 <strong>SetCurrentInteractPointLocation</strong> 保存起来，同时在构建输入特征函数中由函数 <strong>GetCurrentInteractPointLocation</strong> 提取；</p><h3 id="Bake阶段"><a href="#Bake阶段" class="headerlink" title="Bake阶段"></a>Bake阶段</h3><p>骨骼动画数据一般都只有当前角色的骨骼信息，<strong>没有被交互对象的任何信息</strong>，如开门动画，在动画数据中没有门的任何信息；我们要实现MM中的交互点位置特征匹配，就必须动画数据库存在该信息。<br>对于大部分交互动画，在交互过程中交互点的位置往往和角色的某一块骨骼的位置重合，因此使用这个骨骼位置代替交互点位置（如开门过程中，手部会一直握住门把手，就可以用手部骨骼位置代表交互点门把手的位置）；因此交互特征<strong>MatchFeature_Interaction</strong>得到关注的骨骼的位置；<br>但是这样存在问题，就是只能表示手接触门把手之后的交互点的位置，我们的动画数据是从不同角度走向门并开门的动画，在走向门的过程中不能表示门把手的位置；因此使用<strong>Tag_Interaction</strong>来解决这个问题：在一段动画中，使用<strong>Tag_Interaction</strong>标记角色手部接触门把手直到松开的过程，使用Tag标记的第一帧的手部位置的世界坐标表示门把手（交互点）的世界坐标，再从动画序列的开头计算出该世界坐标每帧相对于角色根骨骼的位置，这样就把交互点的位置Bake到了数据库中，效果如下：</p><figure><img src="/article_img/2024-05-21-15-24-05.png" width=300/><img src="/article_img/2024-05-21-15-24-14.png" width=300/><img src="/article_img/2024-05-21-15-23-46.png" width=300/><img src="/article_img/2024-05-21-15-24-32.png" width=300/></figure><p><strong>交互特征的权重不宜过大</strong></p><h2 id="功能3：Bake界面显示信息"><a href="#功能3：Bake界面显示信息" class="headerlink" title="功能3：Bake界面显示信息"></a>功能3：Bake界面显示信息</h2><h3 id="显示根速度"><a href="#显示根速度" class="headerlink" title="显示根速度"></a>显示根速度</h3><p>在<strong>MotionSymphonyEditor\Private\Toolkits\MotionPreProcessToolkitViewportClient.cpp</strong> 中的 <strong>DrawCanvas</strong> 函数中添加要关注的信息即可，根速度使用函数 <strong>FMMPreProcessUtils::ExtractRootVelocity</strong> 得到；</p><h3 id="显示角度点位置"><a href="#显示角度点位置" class="headerlink" title="显示角度点位置"></a>显示角度点位置</h3><p>添加信息和上面显示根速度的位置一样，关键在于如何得到交互点的位置信息，这里借助姿势特征数组（PoseArray），先遍历一遍MotionConfig中的特征数组（Feature）得到 <strong>Interaction特征</strong> 的FeatureOffset，之后凭借该偏移从PoseArray中得到交互点相对位置；</p><p><img src="/article_img/2024-05-26-15-49-52.png"></p><h2 id="功能4：统计单个特征的Cost值"><a href="#功能4：统计单个特征的Cost值" class="headerlink" title="功能4：统计单个特征的Cost值"></a>功能4：统计单个特征的Cost值</h2><p>借助每个特征的<strong>Size</strong>函数得到该特征的大小，在特征数组中计算；计算过程在 <strong>GetLowestCostPoseId_Standard()</strong> 函数中，计算完成之后，定义一个TMap，Key为每个特征的名称（在每个特征类中添加函数GetFeatureName得到），Value为该特征的Cost；</p><h2 id="功能5：走到目标点的轨迹生成"><a href="#功能5：走到目标点的轨迹生成" class="headerlink" title="功能5：走到目标点的轨迹生成"></a>功能5：走到目标点的轨迹生成</h2><p>原本的Trajectory Generator生成轨迹的思路是，输入的向量代表希望移动的方向，乘上移动速度得到当前期望的速度向量 <strong>DesiredLinearVelocity</strong>（有方向有大小），之后根据Trajectory Generator的Sample Rate计算出期望的移动位移 <strong>DesiredLinearDisplacement</strong>，这个位移就表示了轨迹预测最后一帧的位移，再选择不同的插值方式插值出中间的轨迹点；</p><p>走到目标点的轨迹生成要求在到达目标点时速度为零，也就是在接近目标点时要减速，那么就很简单了，只需要<strong>根据当前位置到目标点的距离设置移动速度</strong>即可；这一步在原本框架中即使计算 <strong>DesiredLinearVelocity</strong> 的函数，那么只需要自定义新的函数，设定一定的减速距离（表示距离目标点多远开始减速），进入这个减速距离之后，速度为原速度乘上  <strong>距目标点距离&#x2F;减速距离</strong>，实现减速：<br><img src="/article_img/2024-05-27-14-14-04.png"></p><h1 id="交互动MotionMaatching工作流"><a href="#交互动MotionMaatching工作流" class="headerlink" title="交互动MotionMaatching工作流"></a>交互动MotionMaatching工作流</h1><p>整体工作流与Motion Symphony相同，只需要额外处理交互特征：</p><ol><li><strong>动画数据获取</strong>：准备交互动动画数据，保证有正确的根运动</li><li><strong>动画数据库构建</strong>：对动画数据进行预处理，在Bake阶段使用<strong>Tag_Interaction</strong>来解决这个问题：在一段动画中，使用<strong>Tag_Interaction</strong>标记角色手部接触门把手直到松开的过程；</li><li><strong>设置轨迹生成算法</strong>：将轨迹生成算法设置为<strong>Interaction</strong></li><li><strong>添加交互组件</strong>：为角色添加交互组件</li><li><strong>自定义被交互物行为</strong>：设置被交互物动画</li></ol><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><h2 id="特征提取效果"><a href="#特征提取效果" class="headerlink" title="特征提取效果"></a>特征提取效果</h2><p>其中红色小球代表该开门动画中的交互点（门把手）的位置信息，图中其会左右抖动为显示问题，不影响交互特征信息提取的准确性。<br><img src="/article_img/%E4%BA%A4%E4%BA%92MM%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96Bake%E7%95%8C%E9%9D%A2.gif"></p><h2 id="交互动MM效果"><a href="#交互动MM效果" class="headerlink" title="交互动MM效果"></a>交互动MM效果</h2><p><img src="/article_img/%E4%BA%A4%E4%BA%92MM%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.gif"><br>虽然还有抖动，不够准确等问题，但是在没有刻意优化特征参数的情况下可以达到基本的开门效果，可以证明当前方案具备可行性。</p><h1 id="未来工作"><a href="#未来工作" class="headerlink" title="未来工作"></a>未来工作</h1><ol><li><strong>交互特征提取</strong>： 当前只解决了接触式交互动画中的特征提取问题，对于非接触式还没有特别好的思路；同时当前只提取交互点位置特征还不够导致效果不稳定，还可以添加速度，加速度等特征，对于开门动画可以考虑添加角色与门的角度特征；</li><li><strong>权重参数优化</strong>：目前角色向被交互物移动的过程也考虑了交互点的信息，但是向交互点移动的过程中需要考虑双脚骨骼，如果交互点特征权重过大可能导致双脚骨骼的信息被稀释，导致行走动画不流畅；如果交互点特征权重过小可能导致交互点信息被稀释，导致不能正确开门，或者无法匹配正确角度的开门；</li><li><strong>组件化</strong>：目前的功能耦合度较高，尤其是被交互物，后期可以将被交互物功能组件化，实现对任意物体添加被交互组件即可驱动交互动MM；</li></ol>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unreal-回放系统浅析</title>
    <link href="/2024/03/11/UE%E5%9B%9E%E6%94%BE%E7%B3%BB%E7%BB%9F%E6%B5%85%E6%9E%90/"/>
    <url>/2024/03/11/UE%E5%9B%9E%E6%94%BE%E7%B3%BB%E7%BB%9F%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/564017214">《Exploring in UE4》Unreal回放系统剖析</a><br><a href="https://unrealcommunity.wiki/replay-system-tutorial-41kq5b58">Replay System Tutorial</a><br><a href="https://docs.unrealengine.com/5.3/zh-CN/using-the-replay-system-in-unreal-engine/">UE文档-重播系统</a><br><a href="https://forums.unrealengine.com/t/experimental-sample-code-for-implementing-instant-replays/264946">Experimental:Sample code for Implementing Instant Replays</a><br><a href="https://vorixo.github.io/devtricks/killcam/">Implementing Instant Replays (Killcam)</a></p><h1 id="UE回放系统"><a href="#UE回放系统" class="headerlink" title="UE回放系统"></a>UE回放系统</h1>]]></content>
    
    
    <categories>
      
      <category>-[客户端]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习-游戏相关</title>
    <link href="/2024/03/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/03/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><h2 id="点到直线-射线-线段"><a href="#点到直线-射线-线段" class="headerlink" title="点到直线&#x2F;射线&#x2F;线段"></a>点到直线&#x2F;射线&#x2F;线段</h2><h2 id="两个矩形相交（GJK）"><a href="#两个矩形相交（GJK）" class="headerlink" title="两个矩形相交（GJK）"></a>两个矩形相交（GJK）</h2><h2 id="子弹碰撞"><a href="#子弹碰撞" class="headerlink" title="子弹碰撞"></a>子弹碰撞</h2><p><a href="https://zhuanlan.zhihu.com/p/396719279">现代游戏物理引擎入门(三)——碰撞检测(上)</a></p><h1 id="寻路算法"><a href="#寻路算法" class="headerlink" title="寻路算法"></a>寻路算法</h1><h2 id="A-及其优化"><a href="#A-及其优化" class="headerlink" title="A*及其优化"></a>A*及其优化</h2><h2 id="NevMesh和Grid"><a href="#NevMesh和Grid" class="headerlink" title="NevMesh和Grid"></a>NevMesh和Grid</h2><h1 id="避障算法"><a href="#避障算法" class="headerlink" title="避障算法"></a>避障算法</h1><h2 id="VO、RVO和ORCA"><a href="#VO、RVO和ORCA" class="headerlink" title="VO、RVO和ORCA"></a>VO、RVO和ORCA</h2><p><a href="https://indienova.com/indie-game-development/vo-rvo-orca/">避障算法 - VO、RVO 以及 ORCA (RVO2)</a></p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><h2 id="帧同步和状态同步"><a href="#帧同步和状态同步" class="headerlink" title="帧同步和状态同步"></a>帧同步和状态同步</h2><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><h1 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h1><h1 id="ECS架构"><a href="#ECS架构" class="headerlink" title="ECS架构"></a>ECS架构</h1><h1 id="背包界面"><a href="#背包界面" class="headerlink" title="背包界面"></a>背包界面</h1><h1 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h1><h2 id="骨骼动画烘焙"><a href="#骨骼动画烘焙" class="headerlink" title="骨骼动画烘焙"></a>骨骼动画烘焙</h2><p><a href="https://zhuanlan.zhihu.com/p/108725072">Unity大规模角色的GPU蒙皮动画表达方式</a></p><p>大致思路：将骨骼动画数据烘焙到贴图上（将蒙皮顶点的变换矩阵提前计算好，只需要在顶点着色器读出这个矩阵mul即可），在Mesh上记录每个点的对应骨骼和权重信息，在顶点着色器计算；</p>]]></content>
    
    
    <categories>
      
      <category>-[面试]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习-UE</title>
    <link href="/2024/03/05/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-UE%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/03/05/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-UE%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Gameplay架构"><a href="#Gameplay架构" class="headerlink" title="Gameplay架构"></a>Gameplay架构</h1><h2 id="APawn"><a href="#APawn" class="headerlink" title="APawn"></a>APawn</h2><h2 id="ACharacter"><a href="#ACharacter" class="headerlink" title="ACharacter"></a>ACharacter</h2><h1 id="UE数据结构"><a href="#UE数据结构" class="headerlink" title="UE数据结构"></a>UE数据结构</h1><h2 id="FName，FText和FString"><a href="#FName，FText和FString" class="headerlink" title="FName，FText和FString"></a>FName，FText和FString</h2><h1 id="UE反射"><a href="#UE反射" class="headerlink" title="UE反射"></a>UE反射</h1><h2 id="UFunction"><a href="#UFunction" class="headerlink" title="UFunction"></a>UFunction</h2><p>const函数在蓝图里怎样显示</p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="USkeletalMesh、USkeletalMeshComponent和ASkeletalMeshActor"><a href="#USkeletalMesh、USkeletalMeshComponent和ASkeletalMeshActor" class="headerlink" title="USkeletalMesh、USkeletalMeshComponent和ASkeletalMeshActor"></a>USkeletalMesh、USkeletalMeshComponent和ASkeletalMeshActor</h2><p><img src="/article_img/2024-03-07-17-23-16.png"></p>]]></content>
    
    
    <categories>
      
      <category>-[面试]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习-计算机基础</title>
    <link href="/2024/03/02/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/02/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="C-和STL"><a href="#C-和STL" class="headerlink" title="C++和STL"></a>C++和STL</h1><p>C++和STL按照 <a href="https://zhuanlan.zhihu.com/p/417640759">【游戏开发面经汇总】- 计算机基础篇</a> 中总结的顺序复习，参考之前的笔记。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><a href="https://blog.csdn.net/weixin_43736974/article/details/84543970">C++ 算法篇 位运算</a></p><ul><li><strong>按位与&amp;<strong>：可以理解为</strong>串联</strong>，都为1才得1：1&amp;1&#x3D;1，1&amp;0&#x3D;0，0&amp;1&#x3D;0，0&amp;0&#x3D;0；</li><li><strong>按位或|<strong>：可以理解为</strong>并联</strong>，有一个1就得1：1&amp;1&#x3D;1，1&amp;0&#x3D;1，0&amp;1&#x3D;1，0&amp;0&#x3D;0；</li><li><strong>按位异或^</strong>：<strong>不相同得1，相同得0</strong>：1&amp;1&#x3D;0，1&amp;0&#x3D;1，0&amp;1&#x3D;1，0&amp;0&#x3D;0；</li><li>**按位取反~**：顾名思义，1得0，0得1；</li><li>**按位左移&lt;&lt;**：二进制数左移n位，高位溢出则舍弃，低位补0；</li><li><strong>按位右移&gt;&gt;<strong>：二进制数右移n位，低位舍弃，对于无符号数高位补零，对于有符号数，原来符号位为0（正数）则也移入0，原来符号位为1（负数）移入0或1要看计算机系统，移入1的称为</strong>算数移位</strong>，移入0的称为<strong>逻辑移位</strong>。</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>懒汉式：只在第一次调用getInstance时才创建单例对象；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">static</span> MyClass&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">// 静态函数可以在在类外得到单例对象 MyClass::getInstance();</span><br>      <span class="hljs-type">static</span> MyClass instance;  <span class="hljs-comment">// 静态局部变量，存储在静态存储区，其他函数不能访问，生命周期只到程序结束</span><br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// 防止类外构造</span><br>   ~<span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// 防止类外析构</span><br>   <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; myclass)(); <span class="hljs-comment">// 防止类外拷贝构造</span><br>   <span class="hljs-type">const</span> MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; myclass); <span class="hljs-comment">// 防止类外赋值构造</span><br>&#125;<br></code></pre></td></tr></table></figure><p>懒汉式：程序一开始就创建单例对象，需要的时候用getInstance取得</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">static</span> MyClass&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> singleInstance;<br>   &#125;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">static</span> MyClass singleInstance;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// 防止类外构造</span><br>   ~<span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// 防止类外析构</span><br>   <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; myclass); <span class="hljs-comment">// 防止类外拷贝构造</span><br>   <span class="hljs-type">const</span> MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; myclass); <span class="hljs-comment">// 防止类外赋值构造</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>   MyClass::<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">func1</span>(); <span class="hljs-comment">// 通过唯一的单例对象调用其成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><a href="https://zhuanlan.zhihu.com/p/83535678">C++深入浅出工厂模式（初识篇）</a></p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p><img src="/article_img/2024-03-02-16-46-18.png"></p><p><strong>优点：</strong> 封装了创建具体产品对象的函数<br><strong>缺陷：</strong> 扩展性差，每次添加新的产品要修改工厂类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*-----------------产品------------------*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shoes</span>&#123; <span class="hljs-comment">// 抽象产品类</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shoes</span>();<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NikeShoes</span>&#123;  <span class="hljs-comment">// 具体产品类</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;NikeShoes&quot;</span>&lt;&lt;endl;<br>   &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdidasShoes</span>&#123;  <span class="hljs-comment">// 具体产品类</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;AdidasShoes&quot;</span>&lt;&lt;endl;<br>   &#125;<br>&#125;;<br><span class="hljs-comment">/*-----------------工厂------------------*/</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SHOES_TYPE</span>&#123;<br>   NIKE,<br>   ADIDAS<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoesFactory</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function">Shoes* <span class="hljs-title">createShoes</span><span class="hljs-params">(SHOES_TYPE type)</span></span>&#123;<br>      <span class="hljs-keyword">switch</span> (type)&#123;<br>         <span class="hljs-keyword">case</span> NIKE:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">NikeShoes</span>();<br>         <span class="hljs-keyword">case</span> ADIDAS:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">AdidasShoes</span>();<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>将产品生产分配给多个工厂（生产线），但是每个工厂只生产一种产品；</p><p><img src="/article_img/2024-03-02-16-57-52.png"></p><p><strong>优点：</strong> 添加新产品时添加对应的具体工厂即可<br><strong>缺陷：</strong> 需要定义很多类，一个具体工厂只能生产一种产品</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*-----------------产品------------------*/</span><br><span class="hljs-comment">// ... </span><br><span class="hljs-comment">/*-----------------工厂------------------*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoesFactory</span>&#123; <br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> Shoes* <span class="hljs-title">createShoes</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NikeProducer</span> : <span class="hljs-keyword">public</span> ShoesFactory&#123; <span class="hljs-comment">// 生产具体产品的生产线</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> Shoes* <span class="hljs-title">createShoes</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">NikeShoes</span>();<br>   &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdidasProducer</span> : <span class="hljs-keyword">public</span> ShoesFactory&#123; <span class="hljs-comment">// 生产具体产品的生产线</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> Shoes* <span class="hljs-title">createShoes</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">AdidasShoes</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>将产品生产分配给多个工厂，每个工厂可以生产多种产品；</p><p><img src="/article_img/2024-03-02-17-03-49.png"></p><h3 id="模板工厂模式"><a href="#模板工厂模式" class="headerlink" title="模板工厂模式"></a>模板工厂模式</h3><p>针对工厂方法模式封装成模板工厂类，那么这样在新增产品时，是不需要新增具体的工厂类，减少了代码的编写量。</p><p><img src="/article_img/2024-03-02-17-05-32.png"></p><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>思想与 <strong>内存池</strong> 一样，提前分配一些对象等待使用；<br>对于那些需要频繁创建和销毁的对象，对象池的思想是，首先从对象池中寻找有没有可用的对象，如果没有，就创建对象来使用，然后当一个对象不使用的时候，不是把它删除，而是将它设置为不激活的状态并放入对象池中，等待需要使用的时候再去对象池中寻找，并把它激活。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ObjectPool</span>(<span class="hljs-type">int</span> n) &#123;  <span class="hljs-comment">// 构造函数时生成一些对象放入对象池</span><br>        m_objNum = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            m_objPool.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(i));<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">ObjectPool</span>() &#123;  <span class="hljs-comment">// 析构函数要负责删除对象池中的对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_objNum; i++) &#123;<br>            <span class="hljs-built_in">delete</span>(m_objPool.<span class="hljs-built_in">front</span>());<br>            m_objPool.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        m_objNum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function">T* <span class="hljs-title">getObj</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 允许外界从对象池中获得对象</span><br>        T* obj = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (m_objNum &gt; <span class="hljs-number">0</span>) &#123;<br>            m_objNum--;<br>            obj = m_objPool.<span class="hljs-built_in">front</span>();<br>            m_objPool.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">returnObj</span><span class="hljs-params">(T* obj)</span> </span>&#123;  <span class="hljs-comment">// 允许外界归还对象到对象池</span><br>        m_objNum++;<br>        m_objPool.<span class="hljs-built_in">push</span>(obj);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_objNum;<br>    queue&lt;T*&gt; m_objPool;<br>&#125;;<br></code></pre></td></tr></table></figure><p>实现对象池时，要注意<strong>析构函数</strong>;</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>参考<a href="https://www.xiaolincoding.com/os/">小林coding-图解系统</a></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么<strong>这个运行中的程序，就被称为「进程」（Process）</strong>。</p><p><img src="/article_img/2024-03-03-13-14-57.png"></p><p>上图表现得就是<strong>并发</strong>，下图展示出<strong>并发</strong>与<strong>并行</strong>的区别：<br><img src="/article_img/2024-03-03-13-18-18.png"></p><p>进程状态分为：<strong>运行态，阻塞态，就绪态，挂起态</strong>等状态，完整的状态间切换过程如图：<br><img src="/article_img/2024-03-03-13-22-34.png"><br>运行态，阻塞态，就绪态的概念很好理解，这里介绍一下挂起状态，如果有很多进程处于阻塞状态，那么他们还是会在内存中，而没有被执行会<strong>占用大量的内存空间</strong>，所以我们希望当阻塞发生时，把阻塞状态的进程<strong>换出到外存（硬盘）中</strong>，等需要再次运行时再<strong>换入到物理内存</strong>；<br>那么，就需要一个新的状态，来描述<strong>进程没有占用实际的物理内存空间</strong>的情况，这个状态就是挂起状态。</p><ol><li>阻塞挂起状态：发生了阻塞换出到外存，等待事件完成</li><li>就绪挂起状态：进程在外存中，只要进入内存就能立刻运行</li></ol><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是比进程更小的能<strong>独立运行</strong>的基本单位。线程之间可以并发运行且共享相同的地址空间。同一个进程内多个线程之间可以<strong>共享代码段、数据段、打开的文件等资源</strong>，但每个线程各自都有一套<strong>独立的寄存器和栈</strong>，这样可以确保线程的控制流是相对独立的。<br><img src="/article_img/2024-03-03-13-35-15.png"></p><p>线程的实现分为几种不同的方法，这里介绍两种：<strong>用户线程</strong>和<strong>内核线程</strong>，实现原理如下：</p><table><thead><tr><th><img src="/article_img/2024-03-03-13-39-45.png"></th><th><img src="/article_img/2024-03-03-13-39-50.png"></th></tr></thead></table><h3 id="进程与线程的区别（⭐）"><a href="#进程与线程的区别（⭐）" class="headerlink" title="进程与线程的区别（⭐）"></a>进程与线程的区别（⭐）</h3><ol><li><strong>进程</strong>是运行时的程序，是系统进行<strong>资源分配</strong>的基本单位，实现了系统的并发；<strong>线程</strong>是进程的子单位，是CPU<strong>调度</strong>的基本单位，也是最小的独立运行的基本单位，实现了进程内的并发；</li><li>进程拥有独立的内存空间，同一个进程内的线程共享资源，只拥有独立的寄存器和栈；</li><li>线程的切换开销比进程小很多，因为不需要切换共享的资源，只需要切换现成的私有数据，寄存器等不共享数据；</li></ol><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ol><li>先来先服务：非抢占式；</li><li>最短作业优先：非抢占式，会导致长作业饥饿；</li><li>高响应比优先：非抢占式，等得越久越容易被执行；<br><img src="/article_img/2024-03-03-13-51-06.png"></li><li>最高优先级：先执行优先级高的作业，会导致低优先级作业饥饿；</li><li>时间片轮转：抢占式，时间片用完切换下一个进程<br><img src="/article_img/2024-03-03-13-52-28.png"></li><li>多级反馈队列：是「时间片轮转算法」和「最高优先级算法」的综合和发展；<br><img src="/article_img/2024-03-03-13-58-54.png"></li></ol><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。<br><img src="/article_img/2024-03-20-10-41-41.png"></p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p><img src="/article_img/2024-03-20-10-42-42.png"><br><strong>所谓管道就是内核中的一串缓存</strong>，写入到管道就是缓存到内核中，管道传输的数据是无格式的流且大小受限，且是<strong>先进先出</strong>的；<br><img src="/article_img/2024-03-20-10-44-03.png"></p><p>匿名管道只能实现存在父子关系的进程，命名管道可以在不相关的进程间通信；</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块；</p><p>可以理解为发邮件，同时也就像发邮件一样<strong>通信不及时</strong>，<strong>大小也有限制</strong>；</p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p><img src="/article_img/2024-03-20-10-48-16.png"></p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong></p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>由于共享同一片物理内存，那么就要处理多进程冲突和同步问题，这里就引入了信号量，<strong>信号量就是一个整型计数器</strong>：</p><ol><li><strong>P操作</strong>：信号量减1，如果信号量&lt;0表示资源被占用</li><li><strong>V操作</strong>：信号量加1，相加后如果信号量&lt;&#x3D;0，则表明当前有阻塞中的进程，将该进程唤醒运行，如果相加后信号量&gt;0，则表明没有阻塞中的进程。</li></ol><p><strong>P、V操作必须成对出现！</strong></p><p>信号量又分为两种：</p><ol><li>互斥信号量，信号量初始化为1：<br><img src="/article_img/2024-03-20-10-54-00.png"></li><li>同步信号量，信号量初始化为0，可以保证进程间执行的顺序：<br><img src="/article_img/2024-03-20-10-53-53.png"></li></ol><h3 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h3><p>由于线程共享资源，如果多个线程同时对某个资源进行修改，就会出错，因此需要保证同一时间只有一个线程可以操作共享资源；这就是线程的互斥；<br><img src="/article_img/2024-03-03-14-07-40.png"></p><p><strong>乐观锁和悲观锁</strong>：<br>悲观锁认为多个线程同时访问一个资源的概率较高，因此在修改之前先加锁，防止别的线程修改，如互斥锁，读写锁；<br>乐观锁认为冲突的概率并不高，就直接修改，修改之后再对比修改过程中是否其他线程也修改了该资源；如git；</p><h3 id="死锁（⭐）"><a href="#死锁（⭐）" class="headerlink" title="死锁（⭐）"></a>死锁（⭐）</h3><p>死锁就是多个进程并发执行，在各自占有一定资源的情况下，希望获得其他进程占有的资源以推进执行，但是其他资源同样也期待获得另外进程的资源，大家都不愿意释放自己的资源，从而导致了相互阻塞、循环等待，进程无法推进的情况。</p><p><strong>死锁条件</strong>：</p><ol><li>互斥：一个资源只能被一个进程使用</li><li>请求并保持：请求其他资源但是不释放已有资源</li><li>不可剥夺</li><li>循环等待</li></ol><p><strong>死锁防止</strong>：</p><ol><li>死锁预防：打破以上四个死锁条件</li><li>死锁避免：银行家算法</li><li>死锁检测：检测到了死锁直接抢占资源或终止进程</li></ol><p><strong>银行家算法</strong>（⭐）：<br>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。安全的状态指的是一个进程序列{P1,P2,…Pn}，对于每一个进程Pi，它以后尚需要的资源不大于当前资源剩余量和其余进程所占有的资源量之和。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><img src="/article_img/2024-03-03-14-34-47.png"></p><p>如果没有虚拟内存，两个程序要同时运行在内存中就必须保证不使用同一个位置的物理内存；这样编程会很麻烦，因为要时刻注意两端程序是否引用了相同的物理内存地址；于是，操作系统提供了虚拟内存，如上图所示，<strong>每个进程都有一套“虚拟地址”</strong>，互不干扰，操作系统负责把<strong>虚拟地址映射到物理地址</strong>，这样程序员就完全不用关心物理内存。<br><img src="/article_img/2024-03-03-14-39-47.png"></p><p>总结虚拟内存的优势：</p><ol><li>虚拟内存可以使进程的运行内存超过物理内存的大小，因为程序运行符合局部性原理，那些没有被经常使用到的内存就可以把它换出到外存；</li><li>每个进程都有自己的页表，也就是说每个进程的虚拟内存空间就是相互独立的，解决了多进程之间地址冲突的问题；</li></ol><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>我们知道程序的存储本身就是分区的，如堆区，栈区，代码区等等，因此直接的想法就是按照这些分区进行分段映射：</p><p><img src="/article_img/2024-03-03-14-40-25.png"></p><p>这样就解决了程序本身不需要关心物理内存地址的问题，但是有一些问题：</p><ol><li>内存碎片</li><li>内存交换效率很低</li></ol><p>内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大的段，所以<strong>不会出现内部内存碎片</strong>。但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以会出现<strong>外部内存碎片</strong>的问题。要解决内存碎片需要 <strong>内存交换</strong>，先把程序写到外存，再写回来并且紧跟上一段内存，就没有内存碎片了，但是内存交换效率很低；</p><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>为了解决内存碎片的问题，可以使用内存分页式存储，把物理地址划分为相同的页，每次都是以页为单位进行内存分配，这样就不会有很小的内存碎片出现了。<br><img src="/article_img/2024-03-03-15-00-08.png"></p><p>内存分页保证物理内存没有内存碎片，但是如果一个程序不足一页大小也会分配一个页，会出现页内内存浪费，会有<strong>内部内存碎片</strong>；<br><img src="/article_img/2024-03-03-15-04-06.png"></p><p>简单的内存分页也有问题，那就是页表太大，虚拟内存本就很大，分成很多个页都需要存储页表项；而且每个进程都有自己的页表，加起来分配给页表的内存就很大了；</p><p><strong>多级页表</strong>：<br><img src="/article_img/2024-03-03-15-08-30.png"><br>多级页表的思想就是既然页表太大了，那就对页表再分页，一级页表中存储1024个页表项（二级页表），每个二级页表中存储1024个页表项对应物理页号；<br>并且，根据程序的局部性原理，如果一级页表中没有用到某一个页表项，那就不需要创建这个页表项对应的二级页表了，需要时再创建；</p><p><strong>TLB(Translation Lookaside Buffer)，页表缓存，快表</strong><br><img src="/article_img/2024-03-03-15-12-41.png"><br>多级页表解决了存储问题，但是多了几次地址转换，降低了转换速度，因此同样根据局部性原理，程序经常访问的内存比较固定，那就把这些经常访问的内存页存到快表中，先在快表中找，没有再去多级页表中找；</p><h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p><img src="/article_img/2024-03-03-15-15-34.png"><br>段页式就是将段式和分页式结合起来，先分段，再对每个段分页；</p><h2 id="浮点数和负数"><a href="#浮点数和负数" class="headerlink" title="浮点数和负数"></a>浮点数和负数</h2><h3 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h3><p><strong>负数使用补码表示</strong>，即正数按位取反再加1；<br><img src="/article_img/2024-03-20-11-07-59.png"></p><p>这样表示是为了统一加法操作；</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>小数的表示是整数部分使用<strong>除二取余</strong>，小数部分使用 <strong>乘二取整</strong>：<br><img src="/article_img/2024-03-20-11-08-52.png"><br>因此可以发现，对于一些小数我们无法得到准确的二进制数，比如0.1的二进制数就是无限循环的，这样就会造成浮点数精度误差的问题；</p><p>浮点数之所以叫浮点数，是因为其小数点是可以移动的；比如 1000.101 这个二进制数，可以表示成 1.000101 x 2^3，类似于数学上的<strong>科学记数法</strong>。因此就可以使用下图的形式存储浮点数，指数为就是3，尾数就是000101；<br><img src="/article_img/2024-03-20-11-11-54.png"><br>但是这里的指数位不是简单的存浮点的移动位数，而是存 <strong>移动位数+127</strong>，这是因为指数有正有负，如1010.101应该右移3位，此时指数就是+3，如果对于0.000101应该左移4位，此时指数就是-4；我们不想对指数区分正数负数，因此就加上偏移量，保证都是正数；<br><img src="/article_img/2024-03-20-11-12-38.png"><br><img src="/article_img/2024-03-20-11-18-10.png"></p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是<strong>面向连接的</strong>，<strong>可靠的</strong>，<strong>基于字节流</strong>的传输层通信协议；</p><ul><li>面向连接的：一定是 <strong>一对一</strong> 才能连接，不能像UDP协议可以一个主机同时向多个主机发送消息；</li><li>可靠的：无论网络链路中出现了怎样的链路变化，TCP都可以保证一个报文一定能到达接收端；</li><li>字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃</li></ul><h2 id="TCP和UDP的区别（⭐）"><a href="#TCP和UDP的区别（⭐）" class="headerlink" title="TCP和UDP的区别（⭐）"></a>TCP和UDP的区别（⭐）</h2><ol><li>TCP是面向连接的传输层协议，传递数据前需要先建立连接；UDP是不需要连接的，即刻传输数据。</li><li>TCP是一对一的，UDP支持一对多，一对一，多对多</li><li>TCP是可靠的；UDP是尽最大努力交付</li><li>TCP有拥塞控制和流量控制，保证数据传输的安全性；UDP没有，即使网络非常拥堵了，也不会影响UDP的发送速率</li><li>TCP是流式传输，没有边界，但保证顺序和可靠；UDP是一个包一个包发送，有边界，但是可能会丢包和乱序</li></ol><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><img src="/article_img/2024-03-03-16-10-23.png"></p><h2 id="TCP的三次挥手"><a href="#TCP的三次挥手" class="headerlink" title="TCP的三次挥手"></a>TCP的三次挥手</h2><p><img src="/article_img/2024-03-03-16-13-23.png"></p>]]></content>
    
    
    <categories>
      
      <category>-[面试]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>侯捷C++-C++11新特性</title>
    <link href="/2024/03/01/%E4%BE%AF%E6%8D%B7C++-C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2024/03/01/%E4%BE%AF%E6%8D%B7C++-C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p><strong>左值</strong>：具有可寻址的存储单元，并且能由用户改变其值的量<br><strong>右值</strong>：即将被销毁的临时变量，如字面值常量“hello”（将亡值），返回非引用类型的表达式int func()（纯右值）等；</p><h2 id="为什么要有右值引用？"><a href="#为什么要有右值引用？" class="headerlink" title="为什么要有右值引用？"></a>为什么要有右值引用？</h2><p>避免不必要的拷贝，如果没有右值引用，每一次的拷贝都需要开辟一片新的空间存储被拷贝的值，这样就使拷贝不会影响原来的值，这样当然没有错，但是有些情况下被拷贝的值再完成拷贝之后就被销毁了（如各种临时变量），那么也就没有必要再考虑会不会影响原来的值了，可以直接把原来的值 <strong>偷</strong> 过来，也就是直接将原来的存储空间拿给拷贝后的变量，不需要开辟新空间；</p><p>因此，右值引用就被提出了，对于右值引用，我们可以使用 <strong>移动构造函数</strong> 而不是 <strong>拷贝构造函数</strong> 从而避免开辟新空间，大大提高效率；</p><h2 id="右值引用的用法"><a href="#右值引用的用法" class="headerlink" title="右值引用的用法"></a>右值引用的用法</h2><ol><li>对于临时变量，编译器会自动将其看做一个右值引用；</li><li>对于左值，可以使用 <strong>std::move(lvalue)</strong> 移动语义将其变为一个右值引用；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span>;<br><span class="hljs-function">M <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>; <span class="hljs-comment">// 会调用拷贝构造函数</span><br><span class="hljs-function">M <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c1))</span></span>; <span class="hljs-comment">// 会调用移动构造函数</span><br></code></pre></td></tr></table></figure><p><img src="/article_img/2024-03-01-16-16-55.png"></p><p>因此，对于自定义的<strong>带有指针的类，需要定义移动构造函数</strong>；在标准库中，大多数函数也都有针对右值引用的版本；</p><p>拷贝构造和移动构造的区别：</p><table><thead><tr><th><img src="/article_img/2024-03-01-16-19-45.png"></th><th><img src="/article_img/2024-03-01-16-19-54.png"></th></tr></thead></table><p>在写移动构造或者移动赋值时要注意，只要让原来的指针<strong>断开</strong>（指向NULL）即可，<strong>不要销毁</strong>，销毁是析构函数要做的事；</p><h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p>C++11还实现了 <strong>完美转发</strong>，完美转发的含义是在参数传递的过程中保持其左值或右值的特性；<br>没有完美转发的案例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; t)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;左值&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; t)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;右值&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testForward</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; t)</span></span>&#123;<br>    <span class="hljs-built_in">print</span>(t);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">testForward</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 输出：左值，因为在testForward中，对于print来说，t是一个有名字的，可以改变的值，是一个左值；</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <strong>std::forward</strong> 可以实现完美转发：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; t)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;左值&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; t)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;右值&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testForward</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; t)</span></span>&#123;<br>    <span class="hljs-built_in">print</span>(t);<br>    <span class="hljs-built_in">print</span>(std::forward&lt;<span class="hljs-type">int</span>&gt;(t));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">testForward</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 输出：右值，std::forward 保留了参数的左右值信息</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h1><p>lambda表达式可以理解为一个匿名的内联函数；可以被当作一个参数或者局部对象；<strong>常用于标准库函数中的函数对象参数，如定义比较大小的函数对象参数</strong>。<br><img src="/article_img/2024-03-01-15-06-03.png"><br>lambda表达式的完全形式如上，**[]中表示传入的外界变量<strong>，</strong>()中表示函数参数**，后三个分别表示 **mutable(可改变传入值)，throwSpec(允许报错)，retType(返回类型)**；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">[]&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;Hello Lambda&quot;</span>&lt;&lt;std::endl;<br>&#125;<br><span class="hljs-comment">// 直接使用</span><br>[]&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;Hello Lambda&quot;</span>&lt;&lt;std::endl;<br>&#125;()<br><span class="hljs-comment">// 常用方法</span><br><span class="hljs-keyword">auto</span> L=[]&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;Hello Lambda&quot;</span>&lt;&lt;std::endl;<br>&#125;;<br><br><span class="hljs-built_in">L</span>(); <span class="hljs-comment">// prints&quot;Hello Lambda&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/article_img/2024-03-01-15-04-47.png"><br>可以看出，编译器会把Lambda表达式看成一个**Functor(仿函数&#x2F;函数对象)**；</p><p><img src="/article_img/2024-03-01-15-09-16.png"><br>lambda表达式是一个匿名的内联函数，在编译阶段就会被展开填补在调用处，因此如果是 <strong>传值</strong> 如左上图中案例；如果<strong>传引用</strong>则不会有这种问题，如中上图案例；如果没写<strong>mutable</strong>却要更改传入值，则会编译报错；</p><p>如下图所示，是lambda表达式的一种常见用法，先定义出lambda表达式，再用 <strong>decltype</strong> 得到其类型作为模板参数：<br><img src="/article_img/2024-03-01-15-13-48.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 定义比较大小的lambda表达式</span><br><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)&#123;<br>    <span class="hljs-keyword">return</span> lhs.second&gt;rhs.second;<br>&#125;;<br><span class="hljs-comment">// 使用decltype得到cmp的类型作为模板参数定义优先级队列</span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, deeltype(cmp)&gt; pri_que;<br></code></pre></td></tr></table></figure><p>还有一种用法是直接在参数处定义一个lambda表达式作为局部函数对象，不需要定义一个完整的仿函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; vi&#123;<span class="hljs-number">5</span>,<span class="hljs-number">28</span>,<span class="hljs-number">50</span>,<span class="hljs-number">83</span>,<span class="hljs-number">70</span>,<span class="hljs-number">590</span>,<span class="hljs-number">245</span>&#125;;<br><span class="hljs-type">int</span> x=<span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> y=<span class="hljs-number">100</span>;<br>vi.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove_if</span>(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), [x,y](<span class="hljs-type">int</span> n)&#123;<span class="hljs-keyword">return</span> x&lt;n&amp;&amp;n&lt;y&#125;))<br></code></pre></td></tr></table></figure><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p><a href="https://zhuanlan.zhihu.com/p/436290273">C++ 智能指针最佳实践&amp;源码分析</a></p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr的核心特点就如它的名字一样，它拥有对持有对象的唯一所有权。即两个unique_ptr不能同时指向同一个对象。</p><ol><li>unique_ptr 不能被复制到另一个unique_ptr</li><li>unique_ptr 只能通过转移语义将所有权转移到另一个unique_ptr</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;A&gt; <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function">std::unique_ptr&lt;A&gt; <span class="hljs-title">a2</span><span class="hljs-params">(a1)</span></span>; <span class="hljs-comment">// 编译报错，已删除拷贝构造函数</span><br>std::unique_ptr&lt;A&gt; a2 = a1; <span class="hljs-comment">// 编译报错，已删除赋值构造函数</span><br>std::unique_ptr&lt;A&gt; a3 = std::<span class="hljs-built_in">move</span>(a1);<br></code></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>删除拷贝构造函数和赋值构造函数，在析构函数中delete raw_ptr</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>与unique_ptr的唯一所有权所不同的是，shared_ptr强调的是共享所有权。也就是说多个shared_ptr可以拥有同一个原生指针的所有权。</p><p>shared_ptr 是通过引用计数的方式管理指针，当引用计数为 0 时会销毁拥有的原生对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">a2</span><span class="hljs-params">(a1)</span></span>;<br>std::shared_ptr&lt;A&gt; a2 = a1;<br>std::shared_ptr&lt;A&gt; a3 = std::<span class="hljs-built_in">move</span>(a1);<br></code></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ol><li>构造函数：指针指向该对象，引用计数置为一</li><li>拷贝构造函数：指针指向该对象，引用计数加一</li><li>赋值构造函数：&#x3D;左边引用计数减一，右边引用计数加一，如果左边引用计数降为0，要销毁指针指向的对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sharedPtr</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T* _ptr;<br>    <span class="hljs-type">int</span>* _count;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">sharedPtr</span>(T* p):_ptr(p) &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>            _count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            _count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">sharedPtr</span>(<span class="hljs-type">const</span> sharedPtr&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (&amp;other != <span class="hljs-keyword">this</span>) &#123;<br>            _ptr = other._ptr;<br>            _count = other._count;<br>            (*_count)++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            _ptr = <span class="hljs-literal">nullptr</span>;<br>            _count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 赋值构造函数</span><br>    sharedPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> sharedPtr&amp; rhs) &#123;<br>        <span class="hljs-keyword">if</span> (rhs == <span class="hljs-keyword">this</span>) &#123;  <span class="hljs-comment">// 判断自我赋值</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (_ptr) &#123;  <span class="hljs-comment">// 等号左边计数减一并判断是否销毁</span><br>            (*_count)--;<br>            <span class="hljs-keyword">if</span> ((*_count) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">delete</span> _ptr;<br>                <span class="hljs-keyword">delete</span> _count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 等号右边计数加一，赋值</span><br>        (* rhs._count)++;<br>        _ptr = rhs._ptr;<br>        _count = rhs._count;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 返回raw_ptr</span><br>    T* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        <span class="hljs-keyword">if</span> (_ptr) &#123;<br>            <span class="hljs-keyword">return</span> _ptr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回对象引用</span><br>    T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        <span class="hljs-keyword">if</span> (_ptr) &#123;<br>            <span class="hljs-keyword">return</span> *_ptr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">sharedPtr</span>() &#123;<br>        (* _count)--;<br>        <span class="hljs-keyword">if</span> ((*_count) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">delete</span> _ptr;<br>            <span class="hljs-keyword">delete</span> _count;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getRefCount</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Reference Count:&quot;</span> &lt;&lt; (*_count) &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>shared_ptr指向的对象不是线程安全的；</strong></p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr 比较特殊，它主要是为了配合shared_ptr而存在的。就像它的名字一样，它本身是一个弱指针，因为它<strong>本身是不能直接调用原生指针的方法</strong>的。如果想要使用原生指针的方法，需要将其先转换为一个shared_ptr。那weak_ptr存在的意义到底是什么呢？</p><p>解决shared_ptr的循环引用问题，<strong>weak_ptr不增加引用计数</strong>；</p><p><img src="/article_img/2024-03-04-13-03-54.png"></p><p>如图，栈上创建的共享指针person指向一个新建的Person对象，引用计数为1，car指向一个新建的Car对象，引用计数为1；<br>之后让person的成员变量m_car指向car表示这个人的汽车，car对象引用计数为2，让car的成员变量m_person指向person表示这辆车的主人，person对象引用计数为2。<br>此时如果程序结束，栈上的person被销毁，堆中的person对象引用计数减1，变为1，栈上的car被销毁，推中的car对象引用计数减1，变为1；都没有变成0，都不会被销毁，造成<strong>内存泄漏</strong>。</p><p><img src="/article_img/2024-03-04-13-12-18.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>std::weak_ptr&lt;A&gt; weak_a1 = a1; <span class="hljs-comment">// 不增加引用计数</span><br><span class="hljs-keyword">if</span>(weak_a1.<span class="hljs-built_in">expired</span>())<br>&#123;<br>    <span class="hljs-comment">//如果为true，weak_a1对应的原生指针已经被释放了</span><br>&#125;<br><br><span class="hljs-type">long</span> a1_use_count = weak_a1.<span class="hljs-built_in">use_count</span>();<span class="hljs-comment">//引用计数数量</span><br><br><span class="hljs-keyword">if</span>(std::shared_ptr&lt;A&gt; shared_a = weak_a1.<span class="hljs-built_in">lock</span>())<br>&#123;<br>    <span class="hljs-comment">//此时可以通过shared_a进行原生指针的方法调用</span><br>&#125;<br><br>weak_a1.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">//将weak_a1置空</span><br></code></pre></td></tr></table></figure><p>另外，一切<strong>应该不具有对象所有权</strong>，又想安全访问对象的情况。</p><p>如：一个公司类可以拥有员工，那么这些员工就使用std::shared_ptr维护。另外有时候我们希望员工也能找到他的公司，所以也是用std::shared_ptr维护，这个时候问题就出来了。但是实际情况是，员工并不拥有公司，所以应该用std::weak_ptr来维护对公司的指针。 </p>]]></content>
    
    
    <categories>
      
      <category>-[C++]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MotionSymphony插件详解</title>
    <link href="/2024/01/23/MotionSymphony%E6%8F%92%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/01/23/MotionSymphony%E6%8F%92%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>MotionSymphony插件报告</p><span id="more"></span><h1 id="Motion-Symphony资产和数据结构"><a href="#Motion-Symphony资产和数据结构" class="headerlink" title="Motion Symphony资产和数据结构"></a>Motion Symphony资产和数据结构</h1><h2 id="资产"><a href="#资产" class="headerlink" title="资产"></a>资产</h2><p>Motion Symphony是一个实现Motion Matching的虚幻引擎动画工具集，Motion Matching是一个基于数据的动画驱动方案，Motion Symphony中提供了一套完整的工具和工作流用于构建MM需要的动画数据集，在Motion Symphony中这个数据集叫做 <strong>Motion Data</strong>；如下图，可见要构建Motion Data还需要几个其他的Motion Symphony提供的资产；<br><img src="/article_img/2024-01-23-16-26-34.png"></p><p>Motion Matching的原理是根据当前姿势和未来轨迹在动画数据库中寻找下一帧要播放的姿势，针对姿势匹配一般选取几个骨骼代表一个姿势，对于轨迹一般分别采样几个过去和未来的点；在Motion Symphony中这些信息被定义在资产 <strong>Motion Matching Config</strong> 中：<br><img src="/article_img/2024-01-23-16-34-54.png"></p><p>MM中的寻找，就是一个计算Cost的过程，计算最能匹配当前帧姿势和未来轨迹的动画帧作为下一个要播放的动画帧，计算Cost时需要对不同的特征设置不同的权重（表示我们更关注哪些特征），这些权重信息被定义在资产 <strong>Motion Calibration</strong> 中：<br><img src="/article_img/2024-01-23-16-34-41.png"></p><p>这三个资产是Motion Symphony中最重要的三个自定义资产，源码中的位置在<strong>CustomAessets</strong>目录下：<br><img src="/article_img/2024-01-23-16-39-57.png"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Motion Symphony定义了许多数据结构来方便之后的动画节点计算：<br><img src="/article_img/2024-01-23-16-48-25.png"><br>其中最重要的是 <strong>AnimChannelState</strong>，这个数据结构中存储了：动画id，动画权重，动画类型（序列，混合空间等）等信息，<strong>用来方便操作（不需要每次都用AnimId去找动画长度，是否循环等等）</strong>，AnimNode_MotionMatching中维护了一个 <strong>BlendChannels</strong> 数组，经过MM后选择了一个要播放的动画帧，就会将选择的动画帧构造成一个 <strong>AnimChannelState</strong> 并加入 <strong>BlendChannels</strong> 数组：<br><img src="/article_img/2024-01-23-16-58-58.png"><br>之后在 <strong>FAnimNode_MotionMatching::Evaluate_AnyThread(FPoseContext&amp; Output)</strong> 函数中通过BlendChannels数组选择播放的动画帧：<br><img src="/article_img/2024-01-23-17-03-19.png"></p><h1 id="数据库构建（PreProcess）"><a href="#数据库构建（PreProcess）" class="headerlink" title="数据库构建（PreProcess）"></a>数据库构建（PreProcess）</h1><p><img src="/article_img/2024-02-21-17-06-19.png"></p><p>自定义资产Motion Data就是动画数据库，Motion Symphony的思路是把不同类型的动画单独做成一个Motion Data（比如跑步动画构成一个Motion Data，走路动画构成另一个Motion Data），再用状态机实现各个状态间的过渡，这种方式可以显著提高MM的效率和准确度，因为要搜索的数据库变小了。</p><h2 id="PreProcess框架"><a href="#PreProcess框架" class="headerlink" title="PreProcess框架"></a>PreProcess框架</h2><p>如上图，配置好一个Motion Data的源动画和Calibration和Config后，要点击<strong>PreProcess</strong>，进行预处理，<strong>把动画数据库处理成特征数据库</strong>，减少存储大小；Motion Data中最重要的变量是<strong>Poses</strong>，其中并不存储整个Pose而是存储Pose的特征，PoseId，AnimType，NextPoseId等等信息；<br><img src="/article_img/2024-02-21-17-21-04.png"></p><p>这一步操作由 <strong>void UMotionDataAsset::PreProcess()</strong> 函数完成（只展示核心代码）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMotionDataAsset::PreProcess</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MotionMatchConfig-&gt;<span class="hljs-built_in">Initialize</span>();<br><br><span class="hljs-comment">//Setup mirroring data</span><br><span class="hljs-built_in">ClearPoses</span>();<br><br><span class="hljs-comment">//依次处理选择的Animation Sequences</span><br><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; SourceMotionAnims.<span class="hljs-built_in">Num</span>(); ++i)<br>&#123;<br><span class="hljs-comment">// 先处理一遍未镜像的</span><br><span class="hljs-built_in">PreProcessAnim</span>(i, <span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">if</span> (MirroringProfile != <span class="hljs-literal">nullptr</span> &amp;&amp; SourceMotionAnims[i].bEnableMirroring)<br>&#123;   <span class="hljs-comment">// 如果镜像再处理一遍镜像的</span><br><span class="hljs-built_in">PreProcessAnim</span>(i, <span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Blend Spaces预处理，和上面一样只是调用的预处理函数针对Blend Space</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Composites预处理，同理</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-comment">// 生成NextPoseId和LastPoseId，需要对循环动画进行一些处理</span><br><span class="hljs-built_in">GeneratePoseSequencing</span>();<br><br><span class="hljs-comment">//Standard deviations</span><br><span class="hljs-comment">//First Find a list of traits </span><br>TArray&lt;FMotionTraitField&gt; UsedMotionTraits;<br><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; Poses.<span class="hljs-built_in">Num</span>(); ++i)<br>&#123;<br>UsedMotionTraits.<span class="hljs-built_in">AddUnique</span>(Poses[i].Traits);<br>&#125;<br><br>FeatureStandardDeviations.<span class="hljs-built_in">Empty</span>(UsedMotionTraits.<span class="hljs-built_in">Num</span>());<br><span class="hljs-comment">// 根据不同的Traits选择不同的权重信息，但是一般也不用Traits进行分类</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> FMotionTraitField&amp; MotionTrait : UsedMotionTraits)<br>&#123;<br>FCalibrationData&amp; NewCalibrationData = FeatureStandardDeviations.<span class="hljs-built_in">Add</span>(MotionTrait, <span class="hljs-built_in">FCalibrationData</span>(<span class="hljs-keyword">this</span>));<br>NewCalibrationData.<span class="hljs-built_in">GenerateStandardDeviationWeights</span>(<span class="hljs-keyword">this</span>, MotionTrait);<br>&#125;<br>PreprocessCalibration-&gt;<span class="hljs-built_in">Initialize</span>();<br><br><span class="hljs-comment">// 设置优化模块，在搜索时会根据优化模块减少搜索总数</span><br><span class="hljs-keyword">if</span>(bOptimize &amp;&amp; OptimisationModule)<br>&#123;<br>OptimisationModule-&gt;<span class="hljs-built_in">BuildOptimisationStructures</span>(<span class="hljs-keyword">this</span>);<br>bIsOptimised = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>bIsOptimised = <span class="hljs-literal">false</span>;<br>&#125;<br>bIsProcessed = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面源码概况下来就是先根据不同的源动画类型分别生成<strong>特征（MotionPoseData构成的Poses数组）</strong>，再构建起这些特征的<strong>顺序关系</strong>，最后<strong>设置优化模块</strong>，这里调用的构建优化结构的函数作用是做检查，检查优化模块是否有效；</p><p>可以看出进行PreProcess的核心函数是 **void UMotionDataAsset::PreProcessAnim(const int32 SourceAnimIndex, const bool bMirror)**，下面看看这个函数的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMotionDataAsset::PreProcessAnim</span><span class="hljs-params">(<span class="hljs-type">const</span> int32 SourceAnimIndex, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> bMirror <span class="hljs-comment">/*= false*/</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 得到MotionAnim，该变量继承自 FMotionAnimAsset，其中包含了动画序列本身以及一些其他的属性如是否循环等，这些属性可以在MotionData资产编辑器中设置；</span><br>FMotionAnimSequence&amp; MotionAnim = SourceMotionAnims[SourceAnimIndex];<br>UAnimSequence* Sequence = MotionAnim.Sequence;<br><br>MotionAnim.AnimId = SourceAnimIndex;<br><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> AnimLength = Sequence-&gt;<span class="hljs-built_in">GetPlayLength</span>();<br><span class="hljs-type">float</span> CurrentTime = <span class="hljs-number">0.0f</span>;<br><span class="hljs-comment">// TimeHorizon用来判断某一个动画帧能否使用，其值为轨迹预测中的最大值</span><br><span class="hljs-type">float</span> TimeHorizon = MotionMatchConfig-&gt;TrajectoryTimes.<span class="hljs-built_in">Last</span>();<br><br>FMotionTraitField AnimTraitHandle = UMMBlueprintFunctionLibrary::<span class="hljs-built_in">CreateMotionTraitFieldFromArray</span>(MotionAnim.TraitNames);<br><br><span class="hljs-comment">// PoseInterval太小没必要且影响性能</span><br><span class="hljs-keyword">if</span>(PoseInterval &lt; <span class="hljs-number">0.01f</span>)<br>PoseInterval = <span class="hljs-number">0.05f</span>;<br><br>int32 StartPoseId = Poses.<span class="hljs-built_in">Num</span>();<br>int32 EndPoseId = StartPoseId;<br><span class="hljs-comment">// 进入循环，CurrentTime每循环加PoseInterval</span><br><span class="hljs-keyword">while</span> (CurrentTime &lt;= AnimLength)<br>&#123;<br><span class="hljs-comment">// 当前帧的PoseId为Poses的个数，可以看出PoseId在每个Motion Data中都是从0开始的（因为Motion Data就是一个数据库，PoseId在同一个数据库中不同即可）</span><br>int32 PoseId = Poses.<span class="hljs-built_in">Num</span>();<br>EndPoseId = PoseId;<br><span class="hljs-comment">// 如果CurrentTime位于动画序列的开头或者结尾的TimeHorizon区域中，意味着其不能支持完整的轨迹预测，就标记为不可使用</span><br><span class="hljs-type">bool</span> bDoNotUse = ((CurrentTime &lt; TimeHorizon) &amp;&amp; (MotionAnim.PastTrajectory == ETrajectoryPreProcessMethod::IgnoreEdges))<br>|| ((CurrentTime &gt; AnimLength - TimeHorizon) &amp;&amp; (MotionAnim.FutureTrajectory == ETrajectoryPreProcessMethod::IgnoreEdges))<br>? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 如果是循环则没有上面的顾虑，永远可以支持完整的轨迹预测</span><br><span class="hljs-keyword">if</span>(MotionAnim.bLoop)<br>&#123;<br>bDoNotUse = <span class="hljs-literal">false</span>;<br>&#125;<br><br>FVector RootVelocity;<br><span class="hljs-type">float</span> RootRotVelocity;<br><span class="hljs-comment">// 提取根速度</span><br>FMMPreProcessUtils::<span class="hljs-built_in">ExtractRootVelocity</span>(RootVelocity, RootRotVelocity, Sequence, CurrentTime, PoseInterval);<br><br><span class="hljs-keyword">if</span> (bMirror)<br>&#123;<br>RootVelocity.X *= <span class="hljs-number">-1.0f</span>;<br>RootRotVelocity *= <span class="hljs-number">-1.0f</span>;<br>&#125;<br><br><span class="hljs-type">float</span> PoseCostMultiplier = MotionAnim.CostMultiplier;<br><br><span class="hljs-comment">// 根据以上计算构建一个PoseMotionData，也就是Poses中的元素，之后要加入到Poses数组中；</span><br>FPoseMotionData NewPoseData = <span class="hljs-built_in">FPoseMotionData</span>(PoseId, EMotionAnimAssetType::Sequence, <br>SourceAnimIndex, CurrentTime, PoseCostMultiplier, bDoNotUse, bMirror, <br>RootRotVelocity, RootVelocity, AnimTraitHandle);<br><br><span class="hljs-comment">//Process trajectory for pose  计算轨迹</span><br><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; MotionMatchConfig-&gt;TrajectoryTimes.<span class="hljs-built_in">Num</span>(); ++i)<br>&#123;<br>FTrajectoryPoint Point;<br><br><span class="hljs-keyword">if</span> (MotionAnim.bLoop)<br>&#123;<br>FMMPreProcessUtils::<span class="hljs-built_in">ExtractLoopingTrajectoryPoint</span>(Point, Sequence, CurrentTime, MotionMatchConfig-&gt;TrajectoryTimes[i]);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-type">float</span> PointTime = MotionMatchConfig-&gt;TrajectoryTimes[i];<br><br><span class="hljs-keyword">if</span> (PointTime &lt; <span class="hljs-number">0.0f</span>)<br>&#123;<br><span class="hljs-comment">//past Point</span><br>FMMPreProcessUtils::<span class="hljs-built_in">ExtractPastTrajectoryPoint</span>(Point, Sequence, CurrentTime, PointTime,<br>MotionAnim.PastTrajectory, MotionAnim.PrecedingMotion);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>FMMPreProcessUtils::<span class="hljs-built_in">ExtractFutureTrajectoryPoint</span>(Point, Sequence, CurrentTime, PointTime,<br>MotionAnim.FutureTrajectory, MotionAnim.FollowingMotion);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (MotionAnim.bFlattenTrajectory)<br>&#123;<br>Point.Position.Z = <span class="hljs-number">0.0f</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (bMirror)<br>&#123;<br>Point.Position.X *= <span class="hljs-number">-1.0f</span>;<br>Point.RotationZ *= <span class="hljs-number">-1.0f</span>;<br>&#125;<br><br><span class="hljs-comment">// 将计算出的轨迹点添加到轨迹中</span><br>NewPoseData.Trajectory.<span class="hljs-built_in">Add</span>(Point);<br>&#125;<br><br><span class="hljs-type">const</span> FReferenceSkeleton&amp; RefSkeleton = Sequence-&gt;<span class="hljs-built_in">GetSkeleton</span>()-&gt;<span class="hljs-built_in">GetReferenceSkeleton</span>();<br><br><span class="hljs-comment">//Process joints for pose 提取姿势信息</span><br><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; MotionMatchConfig-&gt;PoseBones.<span class="hljs-built_in">Num</span>(); ++i)<br>&#123;<br>FJointData JointData;<br><br><span class="hljs-keyword">if</span> (bMirror)<br>&#123;<br>FName BoneName = MotionMatchConfig-&gt;PoseBones[i].BoneName;<br>FName MirrorBoneName = MirroringProfile-&gt;<span class="hljs-built_in">FindBoneMirror</span>(BoneName);<br><br><span class="hljs-type">const</span> int32 MirrorBoneIndex = RefSkeleton.<span class="hljs-built_in">FindBoneIndex</span>(MirrorBoneName);<br><br>FMMPreProcessUtils::<span class="hljs-built_in">ExtractJointData</span>(JointData, Sequence, MirrorBoneIndex, CurrentTime, PoseInterval);<br><br>JointData.Position.X *= <span class="hljs-number">-1.0f</span>;<br>JointData.Velocity.X *= <span class="hljs-number">-1.0f</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>FMMPreProcessUtils::<span class="hljs-built_in">ExtractJointData</span>(JointData, Sequence, MotionMatchConfig-&gt;PoseBones[i], CurrentTime, PoseInterval);<br>&#125;<br><br><span class="hljs-comment">// 加入到NewPoseData中</span><br>NewPoseData.JointData.<span class="hljs-built_in">Add</span>(JointData);<br>&#125;<br><br><span class="hljs-comment">// 添加到Poses数组中，也就是完成了数据库中的一个动画帧的预处理</span><br>Poses.<span class="hljs-built_in">Add</span>(NewPoseData);<br>CurrentTime += PoseInterval;<br>&#125;<br><br><span class="hljs-comment">//PreProcess Tags 处理Tag</span><br><span class="hljs-keyword">for</span> (FAnimNotifyEvent&amp; NotifyEvent : MotionAnim.Tags)<br>&#123;<br>UTagSection* TagSection = <span class="hljs-built_in">Cast</span>&lt;UTagSection&gt;(NotifyEvent.NotifyStateClass);<br><span class="hljs-keyword">if</span> (TagSection)<br>&#123;<br><span class="hljs-type">float</span> TagStartTime = NotifyEvent.<span class="hljs-built_in">GetTriggerTime</span>();<br><br><span class="hljs-comment">//Pre-process the tag itself</span><br>TagSection-&gt;<span class="hljs-built_in">PreProcessTag</span>(MotionAnim, <span class="hljs-keyword">this</span>, TagStartTime, TagStartTime + NotifyEvent.Duration);<br><br><span class="hljs-comment">//Find the range of poses affected by this tag</span><br>int32 TagStartPoseId = StartPoseId + FMath::<span class="hljs-built_in">RoundHalfToEven</span>(NotifyEvent.<span class="hljs-built_in">GetTriggerTime</span>() / PoseInterval);<br>int32 TagEndPoseId = StartPoseId + FMath::<span class="hljs-built_in">RoundHalfToEven</span>((NotifyEvent.<span class="hljs-built_in">GetTriggerTime</span>() + NotifyEvent.Duration) / PoseInterval);<br><br>TagStartPoseId = FMath::<span class="hljs-built_in">Clamp</span>(TagStartPoseId, <span class="hljs-number">0</span>, Poses.<span class="hljs-built_in">Num</span>());<br>TagEndPoseId = FMath::<span class="hljs-built_in">Clamp</span>(TagEndPoseId, <span class="hljs-number">0</span>, Poses.<span class="hljs-built_in">Num</span>());<br><br>TagStartTime = NotifyEvent.<span class="hljs-built_in">GetTriggerTime</span>();<br><span class="hljs-type">float</span> TagEndTime = TagStartTime + NotifyEvent.<span class="hljs-built_in">GetDuration</span>();<br><br><span class="hljs-comment">//Apply the tags pre-processing to all poses in this range 这里的PreProcessPose又不同的Tag子类实现，如DoNotUse的Tag就是标记这些Pose为DoNotUse</span><br><span class="hljs-keyword">for</span> (int32 PoseIndex = TagStartPoseId; PoseIndex &lt; TagEndPoseId; ++PoseIndex)<br>&#123;<br>TagSection-&gt;<span class="hljs-built_in">PreProcessPose</span>(Poses[PoseIndex], MotionAnim, <span class="hljs-keyword">this</span>, TagStartTime, TagEndTime);<br>&#125;<br><br><span class="hljs-keyword">continue</span>; <span class="hljs-comment">//Don&#x27;t check for a tag point if we already know its a tag section</span><br>&#125;<br><br><span class="hljs-comment">// TagPoint就是那种只有一个点的动画通知</span><br>UTagPoint* TagPoint = <span class="hljs-built_in">Cast</span>&lt;UTagPoint&gt;(NotifyEvent.Notify);<br><span class="hljs-keyword">if</span> (TagPoint)<br>&#123;<br><span class="hljs-type">float</span> TagTime = NotifyEvent.<span class="hljs-built_in">GetTriggerTime</span>();<br>int32 TagClosestPoseId = StartPoseId + FMath::<span class="hljs-built_in">RoundHalfToEven</span>(TagTime / PoseInterval);<br>TagClosestPoseId = FMath::<span class="hljs-built_in">Clamp</span>(TagClosestPoseId, <span class="hljs-number">0</span>, Poses.<span class="hljs-built_in">Num</span>());<br><br>TagPoint-&gt;<span class="hljs-built_in">PreProcessTag</span>(Poses[TagClosestPoseId], MotionAnim, <span class="hljs-keyword">this</span>, TagTime);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>概括PreProcessAnim函数就是先提取基础信息，之后通过定义在 <strong>FMMPreProcessUtils</strong> 中的一系列工具函数提取<strong>速度信息</strong>，<strong>轨迹信息</strong>和<strong>关节信息</strong>，最后<strong>处理Tag</strong>；那么我们也需要了解一下具体是怎样提取这些信息的，以后如果加入我们自己关注的信息，就可以使用类似的方法提取；</p><h2 id="FMMPreProcessUtils中的工具函数"><a href="#FMMPreProcessUtils中的工具函数" class="headerlink" title="FMMPreProcessUtils中的工具函数"></a>FMMPreProcessUtils中的工具函数</h2><ol><li>提取根位移速度和根旋转速度：调用了动画序列自带的提取根运动的函数，计算出根位移速度和根旋转速度；<br><img src="/article_img/2024-02-21-19-05-09.png"></li><li>提取轨迹点位置和朝向，分为三个不同的函数：循环，提取过去的，提取未来的；<br>循环就直接根据时间没有调用提取根运动的函数：<br><img src="/article_img/2024-02-21-19-08-43.png"><br>提取过去的：<br>提取未来的：</li><li>提取关节数据：<br><img src="/article_img/2024-02-21-20-03-47.png"></li></ol><h1 id="AnimNode（Motion-Symphony中的动画节点）"><a href="#AnimNode（Motion-Symphony中的动画节点）" class="headerlink" title="AnimNode（Motion Symphony中的动画节点）"></a>AnimNode（Motion Symphony中的动画节点）</h1><p>Motion Symphony提供了许多AnimNode来实现各种功能，其中最重要的是 <strong>AnimNode_MotionMatching</strong>，<strong>AnimNode_MotionRecorder</strong> 以及 <strong>AnimNode_PoseMatching</strong>，这三个节点在官方案例中均被使用：<br><img src="/article_img/2024-01-23-16-44-54.png"><br><img src="/article_img/2024-01-23-16-45-14.png"><br><img src="/article_img/2024-01-23-16-45-28.png"></p><h2 id="AnimNode-MotionMatching（MM节点）"><a href="#AnimNode-MotionMatching（MM节点）" class="headerlink" title="AnimNode_MotionMatching（MM节点）"></a>AnimNode_MotionMatching（MM节点）</h2><p>MM节点继承自 <strong>FAnimNode_AssetPlayerBase</strong>，SequencePlayer和SequenceEvaluator也继承自该类，因此可以感性理解MM节点就是一个复杂的SequenceEvaluator（序列求值器），求出当前要播放哪一帧；<br><img src="/article_img/2024-01-23-17-07-37.png"><br>继承关系：<br><img src="/article_img/MotionSymphonyClass.png"></p><p>所有的AnimNode都继承自 <strong>FAnimNode_Base</strong> 类，其中有几个重要的函数 ：</p><ol><li><strong>Initialize_AnyThread</strong> （节点第一次被调用时的初始化操作）<br><img src="/article_img/2024-01-24-09-31-13.png"></li><li><strong>Update_AnyThread</strong> （图表更新时调用，一般用来计算影响骨骼姿势的权重）<br><img src="/article_img/2024-01-24-09-31-01.png"></li><li><strong>Evaluate_AnyThread</strong> （根据update中计算出的权重估计本地空间下的骨骼变换）<br><img src="/article_img/2024-01-24-09-30-51.png"><br>我们看任何一个AnimNode的代码都可以从这几个函数入手。</li></ol><p>AnimNode_MotionMatching还覆写了几个其他的 <strong>FAnimNode_Base</strong> 函数，如果用到我们后面再提；<br><img src="/article_img/2024-01-24-09-22-48.png"><br>注意到MM节点没有覆写 <strong>Update_AnyThread</strong> 因为MM节点继承自 <strong>FAnimNode_AssetPlayerBase</strong>，该父类将 <strong>Update_AnyThread</strong> 定义为了final，无法覆写：<br><img src="/article_img/2024-01-24-09-27-28.png"><br>MM节点的主要逻辑都写在 <strong>UpdateAssetPlayer</strong> 中，其中关键的函数及调用如下图所示：<br><img src="/article_img/MMFunc.png"></p><p>下面我们阅读一下几个重要函数的代码逻辑：</p><p>首先Motion Matching算法是基于当前姿势去进行匹配的，因此需要得到当前姿势，这里使用 <strong>ComputeCurrentPose</strong> 函数得到当前姿势，要注意的是，Motion Symphony在实现时使用了两个变量来表示当前姿势：</p><ol><li><strong>CurrentInterpolatedPose</strong>：从FAnimNode_MotionRecorder中得到记录的当前姿势；</li><li><strong>CurrentChosenPoseId</strong>：通过与上次MM之间的时间间隔计算出的当前已选择的姿势id；之后如果进行MM得到的匹配结果也要赋值给该变量；</li></ol><p>下面看看源码（省略了大量代码，只展示最核心的代码）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FAnimNode_MotionMatching::ComputeCurrentPose</span><span class="hljs-params">(<span class="hljs-type">const</span> FCachedMotionPose&amp; CachedMotionPose)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> PoseInterval = FMath::<span class="hljs-built_in">Max</span>(<span class="hljs-number">0.01f</span>, MotionData-&gt;PoseInterval);<br><br><span class="hljs-comment">//====== Determine the next chosen pose ========</span><br>FAnimChannelState&amp; ChosenChannel = BlendChannels.<span class="hljs-built_in">Last</span>();<br><br><span class="hljs-type">float</span> TimePassed = TimeSinceMotionChosen;<br>int32 PoseIndex = ChosenChannel.StartPoseId;<br><br>int32 NumPosesPassed = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (TimePassed &lt; <span class="hljs-number">0.0f</span>)&#123;<br>NumPosesPassed = FMath::<span class="hljs-built_in">CeilToInt</span>(TimePassed / PoseInterval);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>NumPosesPassed = FMath::<span class="hljs-built_in">FloorToInt</span>(TimePassed / PoseInterval);<br>&#125;<br><span class="hljs-comment">// 计算得到当前已选择的姿势id</span><br>CurrentChosenPoseId = PoseIndex + NumPosesPassed;<br><br><span class="hljs-comment">//====== Determine the next dominant pose ========</span><br>    <span class="hljs-comment">// 对当前记录的姿势进行轨迹插值，因为正在播放的帧有可能是插值出来的，轨迹信息没有经过预处理得到</span><br>FMotionMatchingUtils::<span class="hljs-built_in">LerpPoseTrajectory</span>(CurrentInterpolatedPose, *BeforePose, *AfterPose, PoseInterpolationValue);<br>    <span class="hljs-comment">// 把FAnimNode_MotionRecorder中记录的姿势赋值给CurrentInterpolatedPose</span><br><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; PoseBoneRemap.<span class="hljs-built_in">Num</span>(); ++i)&#123;<br><span class="hljs-type">const</span> FCachedMotionBone&amp; CachedMotionBone = CachedMotionPose.CachedBoneData[PoseBoneRemap[i]];<br>CurrentInterpolatedPose.JointData[i] = <span class="hljs-built_in">FJointData</span>(CachedMotionBone.Transform.<span class="hljs-built_in">GetLocation</span>(), CachedMotionBone.Velocity);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>清楚了当前姿势是如何得到的我们就可以来看MM算法的“主函数”<strong>UpdateMotionMatching</strong>了，大致流程就是先得到当前姿势，之后进行<strong>SchedulePoseSearch</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FAnimNode_MotionMatching::UpdateMotionMatching</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> DeltaTime, <span class="hljs-type">const</span> FAnimationUpdateContext&amp; Context)</span></span><br><span class="hljs-function"></span>&#123;<br>bForcePoseSearch = <span class="hljs-literal">false</span>;<br>TimeSinceMotionChosen += DeltaTime;<br>TimeSinceMotionUpdate += DeltaTime;<br><br>    <span class="hljs-comment">// 得到负责记录姿势的MotionRecoredNode</span><br>FAnimNode_MotionRecorder* MotionRecorderNode = Context.<span class="hljs-built_in">GetAncestor</span>&lt;FAnimNode_MotionRecorder&gt;();<br><br><span class="hljs-keyword">if</span> (MotionRecorderNode)&#123;   <br><span class="hljs-comment">// 得到顺序播放情况下当前已选择的姿势CurrentChosenPoseId，从MotionRecoredNode中得到当前姿势CurrentInterpolatedPose</span><br><span class="hljs-built_in">ComputeCurrentPose</span>(MotionRecorderNode-&gt;<span class="hljs-built_in">GetMotionPose</span>());<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">ComputeCurrentPose</span>();<br>&#125;<br><br><span class="hljs-comment">//If we have ran into a &#x27;DoNotUse&#x27; pose. We need to force a new pose search</span><br><span class="hljs-keyword">if</span>(CurrentInterpolatedPose.bDoNotUse)&#123;<br>bForcePoseSearch = <span class="hljs-literal">true</span>;<br>&#125;<br><br>UMotionMatchConfig* MMConfig = MotionData-&gt;MotionMatchConfig;<br><br><span class="hljs-comment">//Past trajectory mode</span><br><span class="hljs-keyword">if</span> (PastTrajectoryMode == EPastTrajectoryMode::CopyFromCurrentPose)&#123;<br><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; MMConfig-&gt;TrajectoryTimes.<span class="hljs-built_in">Num</span>(); ++i)&#123;<br><span class="hljs-keyword">if</span> (MMConfig-&gt;TrajectoryTimes[i] &gt; <span class="hljs-number">0.0f</span>)&#123; <br><span class="hljs-keyword">break</span>;<br>&#125;<br>DesiredTrajectory.TrajectoryPoints[i] = CurrentInterpolatedPose.Trajectory[i];<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 上次MM经过更新时间间隔或者强制进行MM</span><br><span class="hljs-keyword">if</span> (TimeSinceMotionUpdate &gt;= UpdateInterval || bForcePoseSearch)&#123;<br>        <span class="hljs-comment">// 重置MM更新时间</span><br>TimeSinceMotionUpdate = <span class="hljs-number">0.0f</span>;<br>        <span class="hljs-comment">// 姿势匹配</span><br><span class="hljs-built_in">SchedulePoseSearch</span>(DeltaTime, Context);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>姿势匹配函数 <strong>SchedulePoseSearch</strong>：首先根据当前已选择的姿势得到下一帧姿势（我们更希望动画连续，也就是尽可能顺着当前动画播放，会在计算Cost更偏向下一帧姿势，使下一帧姿势的Cost更小），开始计算Cost，得到Cost最小的姿势，判断该姿势是否是 <strong>FAnimNode_MotionRecorder</strong> 记录的当前姿势（CurrentInterpolatedPose），以及是否是当前已选择的姿势（CurrentChosenPoseId），都不是就过渡到该Cost最小的姿势；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FAnimNode_MotionMatching::SchedulePoseSearch</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime, <span class="hljs-type">const</span> FAnimationUpdateContext&amp; Context)</span></span><br><span class="hljs-function"></span>&#123;<br>FPoseMotionData&amp; NextPose = MotionData-&gt;Poses[MotionData-&gt;Poses[CurrentChosenPoseId].NextPoseId];<br><br>int32 LowestPoseId = NextPose.PoseId;<br><br><span class="hljs-keyword">switch</span> (PoseMatchMethod)&#123;   <span class="hljs-comment">// 根据搜索方式，分为优化和线性（优化模式不会搜索全部数据库），搜索数据库得到Cost最小的姿势id</span><br><span class="hljs-keyword">case</span> EPoseMatchMethod::Optimized: &#123; LowestPoseId = <span class="hljs-built_in">GetLowestCostPoseId</span>(NextPose); &#125; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> EPoseMatchMethod::Linear: &#123; LowestPoseId = <span class="hljs-built_in">GetLowestCostPoseId_Linear</span>(NextPose); &#125; <span class="hljs-keyword">break</span>;<br>&#125;<br><br>FPoseMotionData&amp; BestPose = MotionData-&gt;Poses[LowestPoseId];<br>FPoseMotionData&amp; ChosenPose = MotionData-&gt;Poses[CurrentChosenPoseId];<br><br><span class="hljs-type">bool</span> bWinnerAtSameLocation = BestPose.AnimId == CurrentInterpolatedPose.AnimId &amp;&amp;<br> BestPose.bMirrored == CurrentInterpolatedPose.bMirrored &amp;&amp;<br>FMath::<span class="hljs-built_in">Abs</span>(BestPose.Time - CurrentInterpolatedPose.Time) &lt; <span class="hljs-number">0.25f</span><br>&amp;&amp; FVector2D::<span class="hljs-built_in">DistSquared</span>(BestPose.BlendSpacePosition, CurrentInterpolatedPose.BlendSpacePosition) &lt; <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-comment">// 判断是否时ChosenPose（当前被选择的姿势）</span><br><span class="hljs-keyword">if</span> (!bWinnerAtSameLocation)&#123;<br>bWinnerAtSameLocation = BestPose.AnimId == ChosenPose.AnimId &amp;&amp;<br>BestPose.bMirrored == ChosenPose.bMirrored &amp;&amp;<br>FMath::<span class="hljs-built_in">Abs</span>(BestPose.Time - ChosenPose.Time) &lt; <span class="hljs-number">0.25f</span><br>&amp;&amp; FVector2D::<span class="hljs-built_in">DistSquared</span>(BestPose.BlendSpacePosition, ChosenPose.BlendSpacePosition) &lt; <span class="hljs-number">1.0f</span>;<br>&#125;<br>    <span class="hljs-comment">// 不是ChosenPose，也不是CurrentInterpolatedPose，过渡到该姿势</span><br><span class="hljs-keyword">if</span> (!bWinnerAtSameLocation)&#123;<br><span class="hljs-built_in">TransitionToPose</span>(BestPose.PoseId, Context);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们就可以看MM算法的核心，匹配算法的实现了，在 <strong>GetLowestCostPoseId</strong> 和 <strong>GetLowestCostPoseId_Linear</strong> 这两个函数中，他们区别不大，唯一的区别就是是否对数据库进行了筛选，因此我们只看 <strong>GetLowestCostPoseId</strong> 即可，同样省略了一些非核心代码；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">int32 <span class="hljs-title">FAnimNode_MotionMatching::GetLowestCostPoseId</span><span class="hljs-params">(FPoseMotionData&amp; NextPose)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 得到计算权重</span><br>FCalibrationData&amp; FinalCalibration = FinalCalibrationSets[RequiredTraits];<br>    <span class="hljs-comment">// 得到候选姿势</span><br>TArray&lt;FPoseMotionData&gt;* PoseCandidates = <br>MotionData-&gt;OptimisationModule-&gt;<br><span class="hljs-built_in">GetFilteredPoseList</span>(CurrentInterpolatedPose, RequiredTraits, FinalCalibration);<br><br><span class="hljs-keyword">if</span> (!PoseCandidates)<br>&#123;   <span class="hljs-comment">// 没有候选姿势，也就是没有配置优化（后面讲），就线性搜索数据库</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">GetLowestCostPoseId_Linear</span>(NextPose);<br>&#125;<br><br>int32 LowestPoseId = <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> LowestCost = <span class="hljs-number">10000000.0f</span>;<br>    <span class="hljs-comment">// 遍历候选姿势，开始计算cost</span><br><span class="hljs-keyword">for</span> (FPoseMotionData&amp; Pose : *PoseCandidates)<br>&#123;<br><span class="hljs-comment">//Body Momentum</span><br><span class="hljs-type">float</span> Cost = FVector::<span class="hljs-built_in">DistSquared</span>(CurrentInterpolatedPose.LocalVelocity, Pose.LocalVelocity) * FinalCalibration.Weight_Momentum;<br><br><span class="hljs-comment">//Body Rotational Momentum</span><br>Cost += FMath::<span class="hljs-built_in">Abs</span>(CurrentInterpolatedPose.RotationalVelocity - Pose.RotationalVelocity)<br>* FinalCalibration.Weight_AngularMomentum;<br><br><span class="hljs-comment">//Trajectory Cost </span><br><span class="hljs-type">const</span> int32 TrajectoryIterations = FMath::<span class="hljs-built_in">Min</span>(DesiredTrajectory.TrajectoryPoints.<span class="hljs-built_in">Num</span>(), FinalCalibration.TrajectoryWeights.<span class="hljs-built_in">Num</span>());<br><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; TrajectoryIterations; ++i)<br>&#123;<br><span class="hljs-type">const</span> FTrajectoryWeightSet WeightSet = FinalCalibration.TrajectoryWeights[i];<br><span class="hljs-type">const</span> FTrajectoryPoint CurrentPoint = DesiredTrajectory.TrajectoryPoints[i];<br><span class="hljs-type">const</span> FTrajectoryPoint CandidatePoint = Pose.Trajectory[i];<br><br>Cost += FVector::<span class="hljs-built_in">DistSquared</span>(CandidatePoint.Position, CurrentPoint.Position) * WeightSet.Weight_Pos;<br>Cost += FMath::<span class="hljs-built_in">Abs</span>(FMath::<span class="hljs-built_in">FindDeltaAngleDegrees</span>(CandidatePoint.RotationZ, CurrentPoint.RotationZ)) * WeightSet.Weight_Facing;<br>&#125;<br>        <span class="hljs-comment">// Pose Cost</span><br><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; CurrentInterpolatedPose.JointData.<span class="hljs-built_in">Num</span>(); ++i)<br>&#123;<br><span class="hljs-type">const</span> FJointWeightSet WeightSet = FinalCalibration.PoseJointWeights[i];<br><span class="hljs-type">const</span> FJointData CurrentJoint = CurrentInterpolatedPose.JointData[i];<br><span class="hljs-type">const</span> FJointData CandidateJoint = Pose.JointData[i];<br><br>Cost += FVector::<span class="hljs-built_in">DistSquared</span>(CurrentJoint.Velocity, CandidateJoint.Velocity) * WeightSet.Weight_Vel;<br>Cost += FVector::<span class="hljs-built_in">DistSquared</span>(CurrentJoint.Position, CandidateJoint.Position) * WeightSet.Weight_Pos;<br>&#125;<br><br><span class="hljs-comment">//Favour Current Pose 如果是顺序播放时当前姿势的下一个姿势，就乘上一个Favour值，让其cost更小（这里默认值是0.95）</span><br><span class="hljs-keyword">if</span> (bFavourCurrentPose &amp;&amp; Pose.PoseId == NextPose.PoseId)<br>&#123;<br>Cost *= CurrentPoseFavour;<br>&#125;<br><br><span class="hljs-comment">//Apply Pose Favour</span><br>Cost *= Pose.Favour;<br><br><span class="hljs-keyword">if</span> (Cost &lt; LowestCost)<br>&#123;<br>LowestCost = Cost;<br>LowestPoseId = Pose.PoseId;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> LowestPoseId;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匹配算法"><a href="#匹配算法" class="headerlink" title="匹配算法"></a>匹配算法</h3><p>看完<strong>GetLowestCostPoseId</strong>函数，我们可以就总结出Motion Symphony使用的匹配算法了！</p><p><img src="/article_img/2024-01-24-20-32-52.png"></p><h1 id="Debug工具"><a href="#Debug工具" class="headerlink" title="Debug工具"></a>Debug工具</h1><p>Motion Symphony提供了一系列Debug工具，大多是通过命令行开启后在视口中打印出相关数据或者绘制出相应轨迹。下面看几个常用的Debug工具如何开启以及如何在代码中如何实现；</p><h2 id="Debugging-the-Trajectory（轨迹线绘制）"><a href="#Debugging-the-Trajectory（轨迹线绘制）" class="headerlink" title="Debugging the Trajectory（轨迹线绘制）"></a>Debugging the Trajectory（轨迹线绘制）</h2><p><img src="/article_img/2024-01-24-16-19-52.png"><br>开启后效果，红色为匹配姿势的轨迹，绿色为输入轨迹：<br><img src="/article_img/2024-01-24-16-19-20.png"></p><p>轨迹线绘制实现在<strong>UpdateAssetPlayer</strong>函数中，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Visualize the trajectroy debugging</span><br><span class="hljs-type">const</span> int32 TrajDebugLevel = CVarMMTrajectoryDebug.<span class="hljs-built_in">GetValueOnAnyThread</span>();<br><br><span class="hljs-keyword">if</span> (TrajDebugLevel &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span> (TrajDebugLevel == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-comment">//Draw chosen trajectory</span><br>        <span class="hljs-built_in">DrawChosenTrajectoryDebug</span>(Context.AnimInstanceProxy);<br>    &#125;<br><br>    <span class="hljs-comment">//Draw Input trajectory</span><br>    <span class="hljs-built_in">DrawTrajectoryDebug</span>(Context.AnimInstanceProxy);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Debugging-the-Pose（绘制Pose位置和速度）"><a href="#Debugging-the-Pose（绘制Pose位置和速度）" class="headerlink" title="Debugging the Pose（绘制Pose位置和速度）"></a>Debugging the Pose（绘制Pose位置和速度）</h2><p><img src="/article_img/2024-01-24-16-23-49.png"><br>开启后效果：<br><img src="/article_img/2024-01-24-16-24-48.png"><br>PoseDebug实现在UpdateAssetPlayer函数中，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">int32 PoseDebugLevel = CVarMMPoseDebug.<span class="hljs-built_in">GetValueOnAnyThread</span>();<br><br><span class="hljs-keyword">if</span> (PoseDebugLevel &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">DrawChosenPoseDebug</span>(Context.AnimInstanceProxy, PoseDebugLevel &gt; <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//Debug the current animation data being played by the motion matching node</span><br>int32 AnimDebugLevel = CVarMMAnimDebug.<span class="hljs-built_in">GetValueOnAnyThread</span>();<br><br><span class="hljs-keyword">if</span>(AnimDebugLevel &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">DrawAnimDebug</span>(Context.AnimInstanceProxy);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Animation-Info-Debugging（当前姿势的相关信息）"><a href="#Animation-Info-Debugging（当前姿势的相关信息）" class="headerlink" title="Animation Info Debugging（当前姿势的相关信息）"></a>Animation Info Debugging（当前姿势的相关信息）</h2><p><img src="/article_img/2024-01-24-16-29-13.png"><br>开启后效果：<br><img src="/article_img/2024-01-24-16-28-10.png"><br>也实现在UpdateAssetPlayer函数中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Debug the current animation data being played by the motion matching node</span><br>int32 AnimDebugLevel = CVarMMAnimDebug.<span class="hljs-built_in">GetValueOnAnyThread</span>();<br><br><span class="hljs-keyword">if</span>(AnimDebugLevel &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">DrawAnimDebug</span>(Context.AnimInstanceProxy);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Search-Optimization-Debugging"><a href="#Search-Optimization-Debugging" class="headerlink" title="Search &#x2F; Optimization Debugging"></a>Search &#x2F; Optimization Debugging</h2><p>显示候选姿势的个数，并绘制所有候选姿势的轨迹；也可以查看使用了优化手段后与使用线性搜索之间的误差；<br><img src="/article_img/2024-01-24-16-33-52.png"><br>开启后效果：<br><img src="/article_img/2024-01-24-16-35-45.png"></p><h2 id="Cost-Debugging"><a href="#Cost-Debugging" class="headerlink" title="Cost Debugging"></a>Cost Debugging</h2><p>许多其他的MM方案会提供Cost的debug工具来显示所有姿势的Cost值，Motion Symphony没有提供类似的工具，无法直接查看每个候选姿势的Cost是多少；之后可以仿照上面的其他Debug工具的写法添加一个。</p><h1 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h1><p>Motion Symphony的优化策略可以分为两类，一类是处理数据集，为数据集中的每个姿势定义一个候选姿势集，减少要搜索的数据数量；另一类是在逻辑中提前结束搜索；</p><p>处理数据集的优化策略都依靠在Motion Data中配置从而在预处理Motion Data时实现候选姿势集的构建，因此定义了几个资产来表示不同的优化策略，分别是<strong>MMOptimisation_MultiClustering</strong>，<strong>MMOptimisation_TraitsBin</strong>和 <strong>MMOptimisation_LayeredAABB</strong>（在编辑器中没找到，应该是功能还没完善），他们均继承自类 <strong>UMMOptimisationModule</strong>；</p><h2 id="K-means-Clustering"><a href="#K-means-Clustering" class="headerlink" title="K-means Clustering"></a>K-means Clustering</h2><p>K-means是一种经典的机器学习分类算法，核心目标是将给定的数据集划分成K个簇（K是超参），并给出每个样本数据对应的中心点。<br>在Motion Symphony中，使用K-means算法将相同Traits划分后的姿势数据集按照<strong>轨迹</strong>分为K个簇，在匹配过程中只搜索与当前姿势在同一个簇中的姿势。</p><p>Motion Symphony定义了一种资产来实现K-means算法：<strong>MMOptimisation_MultiClustering</strong>；其中定义了K-means算法的分簇数，最大迭代次数和期望的查询表的大小，该表中存放一个包含候选姿势集的数组，Desired Lookup Table Size就是这个数组的大小，也是最终姿势数据库会被划分的簇数；<br><img src="/article_img/2024-01-24-19-26-14.png"><br>核心函数是 <strong>BuildOptimisationStructures</strong>，该函数是父类 <strong>UMMOptimisationModule</strong> 中定义的虚函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMMOptimisation_MultiClustering::BuildOptimisationStructures</span><span class="hljs-params">(UMotionDataAsset* InMotionDataAsset)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">BuildOptimisationStructures</span>(InMotionDataAsset);<br><br><span class="hljs-comment">//First create trait bins with which to cluster on. 相当于先按照Traits划分了一次</span><br>TMap&lt;FMotionTraitField, TArray&lt;FPoseMotionData&gt; &gt; PoseBins;<br><br><span class="hljs-keyword">for</span> (FPoseMotionData&amp; Pose : InMotionDataAsset-&gt;Poses)<br>&#123;<br>TArray&lt;FPoseMotionData&gt;&amp; PoseBin = PoseBins.<span class="hljs-built_in">FindOrAdd</span>(Pose.Traits);<br>PoseBin.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">FPoseMotionData</span>(Pose));<br>&#125;<br><br><span class="hljs-comment">//For each trait bin we need to cluster and create a lookup table</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; TraitPoseSet : PoseBins)<br>&#123;<br>FCalibrationData FinalPreProcessCalibration = <span class="hljs-built_in">FCalibrationData</span>();<br>FinalPreProcessCalibration.<span class="hljs-built_in">GenerateFinalWeights</span>(InMotionDataAsset-&gt;PreprocessCalibration, <br>InMotionDataAsset-&gt;FeatureStandardDeviations[TraitPoseSet.Key]);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_EDITORONLY_DATA</span><br>KMeansClusteringSet.<span class="hljs-built_in">Clear</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>FKMeansClusteringSet KMeansClusteringSet = <span class="hljs-built_in">FKMeansClusteringSet</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-comment">// K-Means算法划分</span><br>KMeansClusteringSet.<span class="hljs-built_in">BeginClustering</span>(TraitPoseSet.Value, FinalPreProcessCalibration, KMeansClusterCount, KMeansMaxIterations, <span class="hljs-literal">true</span>);<br><br>FPoseLookupTable&amp; PoseLookupTable = PoseLookupSets.<span class="hljs-built_in">FindOrAdd</span>(TraitPoseSet.Key);<br>        <span class="hljs-comment">// 在LookupTable中再做一次K-Means</span><br>PoseLookupTable.<span class="hljs-built_in">Process</span>(TraitPoseSet.Value, KMeansClusteringSet, FinalPreProcessCalibration,<br>DesiredLookupTableSize);<br><br><span class="hljs-comment">//Set the candidate set Id for each pose that is able to be looked up.</span><br><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; PoseLookupTable.CandidateSets.<span class="hljs-built_in">Num</span>(); ++i)<br>&#123;<br>FPoseCandidateSet&amp; CandidateSet = PoseLookupTable.CandidateSets[i];<br>CandidateSet.SetId = i;<br><br><span class="hljs-keyword">for</span> (FPoseMotionData&amp; Pose : CandidateSet.PoseCandidates)<br>&#123;   <span class="hljs-comment">// 为每个姿势分配其候选集</span><br>InMotionDataAsset-&gt;Poses[Pose.PoseId].CandidateSetId = i;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2024-01-24-20-02-49.png"><br>其中 <strong>BeginClustering</strong> 函数调用了 bool FKMeansClusteringSet::ProcessClusters(TArray<FPoseMotionData>&amp; Poses)函数，其中可见划分方式是按照轨迹距离划分，<strong>也就是每个姿势的候选匹配姿势集中都是与当前姿势轨迹接近的姿势</strong>；</p><h2 id="TraitsBin"><a href="#TraitsBin" class="headerlink" title="TraitsBin"></a>TraitsBin</h2><p>只在需要的Traits里搜索；例如在MM节点里设置需要的Traits为 Walk，那么就只会在Tag被设置为Walk的姿势中搜索；<strong>DoNotUse</strong> Tag原理相同；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TArray&lt;FPoseMotionData&gt;* <span class="hljs-title">UMMOptimisation_TraitBins::GetFilteredPoseList</span><span class="hljs-params">(<span class="hljs-type">const</span> FPoseMotionData&amp; CurrentPose, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FMotionTraitField RequiredTraits, <span class="hljs-type">const</span> FCalibrationData&amp; FinalCalibration)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (PoseBins.<span class="hljs-built_in">Contains</span>(RequiredTraits))<br>&#123;<br><span class="hljs-keyword">return</span> &amp;PoseBins[RequiredTraits].Poses;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Motion-Symphony-2-0"><a href="#Motion-Symphony-2-0" class="headerlink" title="Motion Symphony 2.0"></a>Motion Symphony 2.0</h1><h2 id="Motion-Calibration变为optional"><a href="#Motion-Calibration变为optional" class="headerlink" title="Motion Calibration变为optional"></a>Motion Calibration变为optional</h2><p>在2.0版本中，Motion Calibration变成了可选择的，不是必须的，之前1.0中需要在Motion Calibration中配置权重，而在2.0中权重被定义在Motion Config中；<br><img src="/article_img/2024-04-03-09-55-36.png"></p><h2 id="输入数据更加通用"><a href="#输入数据更加通用" class="headerlink" title="输入数据更加通用"></a>输入数据更加通用</h2><p>在1.0中，mm需要输入一个<strong>trajectory</strong>，而在2.0中这个变量变成了更通用的<strong>input data</strong>，称为“FMotionMatchingInputData”，本质上是一个浮点数组的包装器，其中包含来自所有“输入响应”类型匹配功能的所有数据；<br><img src="/article_img/2024-04-03-10-03-49.png"><br>使用MMBlueprint Function Library中的函数 <strong>Construct Motion Input Feature Array</strong> 填充Input Data。</p><p>函数中会根据MotionConfig中选择的特征数据，调用各特征子类的<strong>SourceInputData</strong>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">int32 FeatureOffset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(TObjectPtr&lt;UMatchFeatureBase&gt; MatchFeature : MotionConfig-&gt;InputResponseFeatures)<br>&#123;<br><span class="hljs-keyword">if</span>(MatchFeature &amp;&amp; MatchFeature-&gt;<span class="hljs-built_in">IsSetupValid</span>())<br>&#123;<br>MatchFeature-&gt;<span class="hljs-built_in">SourceInputData</span>(InputData.DesiredInputArray, FeatureOffset, Actor);<br>FeatureOffset += MatchFeature-&gt;<span class="hljs-built_in">Size</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Error, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;ERROR: &#x27;ConstructMotionInputFeatureArray&#x27; node -  Match feature has an invalid setup and cannot be processed.&quot;</span>))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下图，有这些特征类，均继承自MatchFeatureBase类，都重载SourceInputData函数实现对InputData填充不同的数据：<br><img src="/article_img/2024-04-03-10-42-03.png"><br>如MatchFeature_Trajectory2D类中的覆写如下，从TrajectoryGenerator中得到轨迹并填充InputData：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(UTrajectoryGenerator_Base* TrajectoryGenerator = InActor-&gt;<span class="hljs-built_in">GetComponentByClass</span>&lt;UTrajectoryGenerator_Base&gt;())<br>&#123;<br><span class="hljs-type">const</span> FTrajectory&amp; Trajectory = TrajectoryGenerator-&gt;<span class="hljs-built_in">GetCurrentTrajectory</span>();<br><br><span class="hljs-type">const</span> int32 Iterations = FMath::<span class="hljs-built_in">Min</span>(TrajectoryTiming.<span class="hljs-built_in">Num</span>(), Trajectory.TrajectoryPoints.<span class="hljs-built_in">Num</span>());<br><br><span class="hljs-keyword">for</span>(int32 i = <span class="hljs-number">0</span>; i &lt; Iterations; ++i)<br>&#123;<br><span class="hljs-type">const</span> FTrajectoryPoint&amp; TrajectoryPoint = Trajectory.TrajectoryPoints[i];<br><br>FVector RotationVector = <span class="hljs-built_in">FQuat</span>(FVector::UpVector,<br>FMath::<span class="hljs-built_in">DegreesToRadians</span>(TrajectoryPoint.RotationZ)) * FVector::ForwardVector;<br>RotationVector = RotationVector.<span class="hljs-built_in">GetSafeNormal</span>() * <span class="hljs-number">100.0f</span>;<br><br><span class="hljs-type">const</span> int32 PointOffset = FeatureOffset + (i * <span class="hljs-number">4.0f</span>);<br><br><span class="hljs-keyword">if</span>(PointOffset + <span class="hljs-number">3</span> &gt;= OutFeatureArray.<span class="hljs-built_in">Num</span>())<br>&#123;<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Error, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;UMatchFeature_Trajectory2D: SourceInputData(...) - Feature does not fit in FeatureArray&quot;</span>));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>OutFeatureArray[PointOffset] = TrajectoryPoint.Position.X;<br>OutFeatureArray[PointOffset + <span class="hljs-number">1</span>] = TrajectoryPoint.Position.Y;<br>OutFeatureArray[PointOffset + <span class="hljs-number">2</span>] = RotationVector.X;<br>OutFeatureArray[PointOffset + <span class="hljs-number">3</span>] = RotationVector.Y;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不需要配置优化策略"><a href="#不需要配置优化策略" class="headerlink" title="不需要配置优化策略"></a>不需要配置优化策略</h2><p>1.0中可以配置优化模块，例如cluster或AABB等，在2.0中废弃了这一功能，默认使用AABB进行搜索优化；</p><h2 id="不能显式计算各个特征Cost"><a href="#不能显式计算各个特征Cost" class="headerlink" title="不能显式计算各个特征Cost"></a>不能显式计算各个特征Cost</h2><p>在2.0中由于特征可选择的更多，因此不能确定选择了那些特征，在计算cost时也就不能显示得到如轨迹cost，姿势cost等信息，而是统一对特征数组进行计算；</p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TortoiseGit配置</title>
    <link href="/2024/01/18/TortoiseGit%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/18/TortoiseGit%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>使用TortoiseGit时遇到无法使用ssh链接进行git操作的问题，原因是TortoiseGit配置有问题，这里记录解决方法。</p><span id="more"></span><h1 id="git-bash端口22报错解决方法"><a href="#git-bash端口22报错解决方法" class="headerlink" title="git bash端口22报错解决方法"></a>git bash端口22报错解决方法</h1><p>原因应该是端口22被禁用了，更换端口443，到 <strong>&#x2F;.ssh</strong> 添加一个config文件（可以从别的地方复制一个config），在其中填写：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host github.com<br>Hostname ssh.github.com<br>Port <span class="hljs-number">443</span><br><span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br></code></pre></td></tr></table></figure><p>即可使用ssh进行正常的git操作；</p><h1 id="TortoiseGit无法使用ssh进行git操作"><a href="#TortoiseGit无法使用ssh进行git操作" class="headerlink" title="TortoiseGit无法使用ssh进行git操作"></a>TortoiseGit无法使用ssh进行git操作</h1><p>原因是TortoiseGit的配置不对，首先到 <strong>设置-&gt;网络-&gt;SSH</strong> 中设置ssh；<br><img src="/article_img/2024-01-18-14-02-32.png"></p><p>之后需要为TortoiseGit配置与git相同的密钥，否则需要为TortoiseGit再单独生成一个密钥，再去github配置密钥；</p><p>回到常规设置，点击<strong>重新运行首次启动向导</strong>：<br><img src="/article_img/2024-01-18-14-04-38.png"><br>选择密钥类型为OpenSSH（Git使用的密钥类型，与TortoiseGit默认的密钥类型不同）<br><img src="/article_img/2024-01-18-14-04-59.png"><br>运行<strong>PuTTYgen</strong>，将git使用的密钥（一般在C:\Users.ssh）导入并保存：<br><img src="/article_img/2024-01-18-14-08-11.png"></p><p>完成！可以正常使用TortoiseGit！</p><h1 id="报错no-matching-host-key-type-found-Their-offer-ssh-rsa"><a href="#报错no-matching-host-key-type-found-Their-offer-ssh-rsa" class="headerlink" title="报错no matching host key type found. Their offer: ssh-rsa"></a>报错no matching host key type found. Their offer: ssh-rsa</h1><p>原因就是新的ssh客户端不支持ssh-rsa算法，要修改本地配置重新使用ssh-rsa算法。需要在.ssh文件夹中的config中添加如下代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Host</span> *<br>HostkeyAlgorithms +ssh-rsa<br>PubkeyAcceptedKeyTypes +ssh-rsa<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-二叉树</title>
    <link href="/2024/01/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/01/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>二叉树</p><span id="more"></span><h1 id="二叉树的递归遍历（⭐⭐⭐）"><a href="#二叉树的递归遍历（⭐⭐⭐）" class="headerlink" title="二叉树的递归遍历（⭐⭐⭐）"></a>二叉树的递归遍历（⭐⭐⭐）</h1><p><strong>写递归函数的思考逻辑</strong>：（⭐⭐⭐）</p><ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);  <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, res);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, res);  <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, res);  <span class="hljs-comment">// 左</span><br>    res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);  <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, res);  <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, res);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, res);  <span class="hljs-comment">// 右</span><br>    res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);  <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的迭代遍历（非递归）（⭐⭐⭐）"><a href="#二叉树的迭代遍历（非递归）（⭐⭐⭐）" class="headerlink" title="二叉树的迭代遍历（非递归）（⭐⭐⭐）"></a>二叉树的迭代遍历（非递归）（⭐⭐⭐）</h1><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    stack&lt;TreeNode*&gt; stack;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    stack.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* temp=stack.<span class="hljs-built_in">top</span>();<br>        res.<span class="hljs-built_in">push_back</span>(temp-&gt;val);<br>        stack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 先让右孩子入栈再让左孩子入栈，因为栈是先进后出</span><br>        <span class="hljs-keyword">if</span>(temp-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;  <span class="hljs-comment">// 右孩子不为空，入栈</span><br>            stack.<span class="hljs-built_in">push</span>(temp-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp-&gt;left!=<span class="hljs-literal">nullptr</span>)&#123;<br>            stack.<span class="hljs-built_in">push</span>(temp-&gt;left);  <span class="hljs-comment">// 左孩子不为空，入栈</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历：（⭐⭐⭐）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    stack&lt;TreeNode*&gt; stack;<br>    TreeNode* cur=root;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!stack.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>            stack.<span class="hljs-built_in">push</span>(cur);<br>            cur=cur-&gt;left;  <span class="hljs-comment">// 左</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cur = stack.<span class="hljs-built_in">top</span>();<br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);  <span class="hljs-comment">// 中</span><br>            stack.<span class="hljs-built_in">pop</span>();<br>            cur=cur-&gt;right;  <span class="hljs-comment">// 右</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历：<br>后序遍历的非递归算法有些技巧，不需要模拟后序遍历的递归栈；前序遍历顺序是 <strong>中左右</strong>，后序遍历顺序是 <strong>左右中</strong>，因此可以使用前序遍历顺序为<strong>中右左</strong>得到数组，再reverse数组即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    stack&lt;TreeNode*&gt; stack;<br>    stack.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* tempNode=stack.<span class="hljs-built_in">top</span>();<br>        stack.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">push_back</span>(tempNode-&gt;val);<br>        <span class="hljs-keyword">if</span>(tempNode-&gt;left!=<span class="hljs-literal">nullptr</span>)&#123;<br>            stack.<span class="hljs-built_in">push</span>(tempNode-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tempNode-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;<br>            stack.<span class="hljs-built_in">push</span>(tempNode-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的层序遍历（⭐⭐⭐）"><a href="#二叉树的层序遍历（⭐⭐⭐）" class="headerlink" title="二叉树的层序遍历（⭐⭐⭐）"></a>二叉树的层序遍历（⭐⭐⭐）</h1><h2 id="二叉树的层序遍历（⭐⭐）"><a href="#二叉树的层序遍历（⭐⭐）" class="headerlink" title="二叉树的层序遍历（⭐⭐）"></a>二叉树的层序遍历（⭐⭐）</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode.102</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    queue&lt;TreeNode*&gt; queue;<br>    queue.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> size=queue.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 记录当前队列中元素个数，就是当前层的元素个数</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; secVec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            TreeNode* tempNode=queue.<span class="hljs-built_in">front</span>();<br>            queue.<span class="hljs-built_in">pop</span>();<br>            secVec.<span class="hljs-built_in">push_back</span>(tempNode-&gt;val);<br>            <span class="hljs-keyword">if</span>(tempNode-&gt;left!=<span class="hljs-literal">nullptr</span>)&#123;<br>                queue.<span class="hljs-built_in">push</span>(tempNode-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tempNode-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;<br>                queue.<span class="hljs-built_in">push</span>(tempNode-&gt;right);<br>            &#125;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(secVec);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的层序遍历Ⅱ"><a href="#二叉树的层序遍历Ⅱ" class="headerlink" title="二叉树的层序遍历Ⅱ"></a>二叉树的层序遍历Ⅱ</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">LeetCode.107</a></p><p>和上一题一样，最后翻转结果数组即可；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    queue&lt;TreeNode*&gt; queue;<br>    queue.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> size=queue.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; secVec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            TreeNode* tempNode=queue.<span class="hljs-built_in">front</span>();<br>            secVec.<span class="hljs-built_in">push_back</span>(tempNode-&gt;val);<br>            queue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(tempNode-&gt;left!=<span class="hljs-literal">nullptr</span>)&#123;<br>                queue.<span class="hljs-built_in">push</span>(tempNode-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tempNode-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;<br>                queue.<span class="hljs-built_in">push</span>(tempNode-&gt;right);<br>            &#125;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(secVec);<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h2><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">LeetCode.199</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empt</span>())&#123;<br>    <span class="hljs-type">int</span> size=queue.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span>(i==size<span class="hljs-number">-1</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(tempNode-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h2><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">LeetCode.637</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empt</span>())&#123;<br>    <span class="hljs-type">int</span> size=queue.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">double</span> sum=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-comment">//...</span><br>        sum+=tempNode-&gt;val;<br>    &#125;<br>    res.<span class="hljs-built_in">push_back</span>(sum/size);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h2><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/">LeetCode.429</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empt</span>())&#123;<br>    <span class="hljs-type">int</span> size=queue.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-comment">//...</span><br>        res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;node-&gt;children.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;children[i]!=<span class="hljs-literal">nullptr</span>)&#123;<br>                queue.<span class="hljs-built_in">push</span>(node-&gt;children[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h2><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/">LeetCode.515</a></p><p>记录最大值即可。</p><h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/submissions/496881831/">LeetCode.226</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 迭代法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">swap</span>(root-&gt;right, root-&gt;left);<br>    <span class="hljs-built_in">invert</span>(root-&gt;left);<br>    <span class="hljs-built_in">invert</span>(root-&gt;right); <br>&#125;<br><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-built_in">invert</span>(root);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-comment">// 递归法</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    stack&lt;TreeNode*&gt; stack;<br>    stack.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node=stack.<span class="hljs-built_in">top</span>();<br>        stack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>            stack.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;right)&#123;<br>            stack.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对称二叉树（⭐）"><a href="#对称二叉树（⭐）" class="headerlink" title="对称二叉树（⭐）"></a>对称二叉树（⭐）</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">LeetCode.101</a><br><img src="/article_img/2024-01-20-09-54-59.png"></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 递归法（⭐⭐）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* leftNode, TreeNode* rightNode)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!leftNode&amp;&amp;rightNode)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftNode&amp;&amp;!rightNode)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!leftNode&amp;&amp;!rightNode)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftNode-&gt;val!=rightNode-&gt;val)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> outside=<span class="hljs-built_in">compare</span>(leftNode-&gt;left, rightNode-&gt;right);<br>    <span class="hljs-type">bool</span> inside=<span class="hljs-built_in">compare</span>(leftNode-&gt;right, rightNode-&gt;left);<br>    <span class="hljs-keyword">return</span> outside&amp;&amp;inside;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br>&#125;<br><span class="hljs-comment">// 使用栈迭代法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; st;<br>    st.<span class="hljs-built_in">push</span>(root-&gt;left);<br>    st.<span class="hljs-built_in">push</span>(root-&gt;right);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* rightNode=st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        TreeNode* leftNode=st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(!rightNode&amp;&amp;!leftNode)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((!rightNode||!leftNode||(rightNode-&gt;val!=leftNode-&gt;val)))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(leftNode-&gt;left);<br>        st.<span class="hljs-built_in">push</span>(rightNode-&gt;right);<br>        st.<span class="hljs-built_in">push</span>(leftNode-&gt;right);<br>        st.<span class="hljs-built_in">push</span>(rightNode-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">LeetCode.104</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 递归法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> leftDepth=<span class="hljs-built_in">func</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> rightDepth=<span class="hljs-built_in">func</span>(root-&gt;right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftDepth, rightDepth) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(root);<br>&#125;<br><span class="hljs-comment">// 层序遍历</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            TreeNode* node=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        res+=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最小深度（⭐）"><a href="#二叉树的最小深度（⭐）" class="headerlink" title="二叉树的最小深度（⭐）"></a>二叉树的最小深度（⭐）</h1><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">LeetCode.111</a></p><p>本题递归法和求二叉树最大深度类似，只是要处理<strong>没有子树</strong>的情况，如一个树只有右子树，他的最小深度不是1；<br>本题迭代法使用层序遍历，当一个节点没有左右儿子时说明其是叶子节点，故第一次遇到没有左右儿子的节点时就是最小深度；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 递归法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> depth=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> leftDepth=<span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> rightDepth=<span class="hljs-built_in">minDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(leftDepth!=<span class="hljs-number">0</span>&amp;&amp;rightDepth!=<span class="hljs-number">0</span>)&#123;<br>        depth = <span class="hljs-built_in">min</span>(leftDepth, rightDepth);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftDepth==<span class="hljs-number">0</span>)&#123;<br>        depth=rightDepth;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        depth=leftDepth;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 层序遍历迭代法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        depth++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;left)<br>                que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right)<br>                que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; <span class="hljs-comment">// 没有左右孩子，说明是叶子节点，遇到叶子节点直接返回当前深度</span><br>                <span class="hljs-keyword">return</span> depth;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1><p>本题直接求个数了，没用到完全二叉树的性质；</p><h1 id="平衡二叉树（⭐）"><a href="#平衡二叉树（⭐）" class="headerlink" title="平衡二叉树（⭐）"></a>平衡二叉树（⭐）</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">LeetCode.110</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> leftHeight=<span class="hljs-built_in">getHeight</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> rightHeight=<span class="hljs-built_in">getHeight</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(leftHeight==<span class="hljs-number">-1</span>||rightHeight==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(leftHeight-rightHeight)&lt;=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftHeight, rightHeight)+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getHeight</span>(root)!=<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的所有路径（⭐）"><a href="#二叉树的所有路径（⭐）" class="headerlink" title="二叉树的所有路径（⭐）"></a>二叉树的所有路径（⭐）</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">LeetCode.257</a></p><p>关键在于理解二叉树的遍历；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    vector&lt;string&gt; res;<br>    stack&lt;TreeNode*&gt; treeSt;<br>    stack&lt;string&gt; pathSt;<br>    treeSt.<span class="hljs-built_in">push</span>(root);<br>    pathSt.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">to_string</span>(root));<br>    <span class="hljs-keyword">while</span>(!treeSt.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node=treeSt.<span class="hljs-built_in">top</span>(); treeSt.<span class="hljs-built_in">pop</span>();<br>        string path=pathSt.<span class="hljs-built_in">top</span>(); pathSt.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(!node-&gt;left&amp;&amp;!node-&gt;right)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;right)&#123;<br>            treeSt.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            pathSt.<span class="hljs-built_in">push</span>(path+<span class="hljs-string">&quot;-&gt;&quot;</span>+<span class="hljs-built_in">to_string</span>(node-&gt;right-&gt;val));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>            treeSt.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            pathSt.<span class="hljs-built_in">push</span>(path+<span class="hljs-string">&quot;-&gt;&quot;</span>+<span class="hljs-built_in">to_string</span>(node-&gt;left-&gt;val));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-[刷题]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-栈与队列</title>
    <link href="/2024/01/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2024/01/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>栈与队列</p><span id="more"></span><h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">LeetCode.232</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyQueue</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        MyStackIn.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!MyStackIn.<span class="hljs-built_in">empty</span>())&#123;<br>            MyStackOut.<span class="hljs-built_in">push</span>(MyStackIn.<span class="hljs-built_in">top</span>());<br>            MyStackIn.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> out = MyStackOut.<span class="hljs-built_in">top</span>();<br>        MyStackOut.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">while</span>(!MyStackOut.<span class="hljs-built_in">empty</span>())&#123;<br>            MyStackIn.<span class="hljs-built_in">push</span>(MyStackOut.<span class="hljs-built_in">top</span>());<br>            MyStackOut.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> out;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!MyStackIn.<span class="hljs-built_in">empty</span>())&#123;<br>            MyStackOut.<span class="hljs-built_in">push</span>(MyStackIn.<span class="hljs-built_in">top</span>());<br>            MyStackIn.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> out = MyStackOut.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">while</span>(!MyStackOut.<span class="hljs-built_in">empty</span>())&#123;<br>            MyStackIn.<span class="hljs-built_in">push</span>(MyStackOut.<span class="hljs-built_in">top</span>());<br>            MyStackOut.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> out;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MyStackIn.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; MyStackIn;<br>    stack&lt;<span class="hljs-type">int</span>&gt; MyStackOut;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">LeetCode.225</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        MyQueueIn.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(MyQueueIn.<span class="hljs-built_in">size</span>()!=<span class="hljs-number">1</span>)&#123;<br>            MyQueueOut.<span class="hljs-built_in">push</span>(MyQueueIn.<span class="hljs-built_in">front</span>());<br>            MyQueueIn.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> out = MyQueueIn.<span class="hljs-built_in">front</span>();<br>        MyQueueIn.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">while</span>(!MyQueueOut.<span class="hljs-built_in">empty</span>())&#123;<br>            MyQueueIn.<span class="hljs-built_in">push</span>(MyQueueOut.<span class="hljs-built_in">front</span>());<br>            MyQueueOut.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> out;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MyQueueIn.<span class="hljs-built_in">back</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MyQueueIn.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; MyQueueIn;<br>    queue&lt;<span class="hljs-type">int</span>&gt; MyQueueOut;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="有效的括号（⭐）"><a href="#有效的括号（⭐）" class="headerlink" title="有效的括号（⭐）"></a>有效的括号（⭐）</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">LeetCode.20</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果s的长度为奇数，一定不符合要求</span><br>    stack&lt;<span class="hljs-type">char</span>&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>        <span class="hljs-comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span><br>        <span class="hljs-comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// st.top() 与 s[i]相等，栈弹出元素</span><br>    &#125;<br>    <span class="hljs-comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span><br>    <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="删除字符串中的所有相邻重复项（⭐）"><a href="#删除字符串中的所有相邻重复项（⭐）" class="headerlink" title="删除字符串中的所有相邻重复项（⭐）"></a>删除字符串中的所有相邻重复项（⭐）</h1><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">LeetCode.1047</a></p><p>可以把string当作一个栈来操作。</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 常规做法使用栈</span><br><span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>    string res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>        <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>()||stack.<span class="hljs-built_in">top</span>()!=c)&#123;<br>            stack.<span class="hljs-built_in">push</span>(c);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>())&#123;<br>        res.<span class="hljs-built_in">push_back</span>(stack.<span class="hljs-built_in">top</span>());<br>        stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">// 把sting当作栈</span><br><span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    string res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">empty</span>()||res.<span class="hljs-built_in">back</span>()!=c)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(c);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">LeetCode.150</a></p><p>遇到数字压入栈中，遇到运算符从栈中取出两个元素进行运算；这里注意string到int的转换（⭐），可以使用 <strong>stoi()</strong> 函数；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; numStack;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s:tokens)&#123;<br>        <span class="hljs-keyword">if</span>(s!=<span class="hljs-string">&quot;+&quot;</span>&amp;&amp;s!=<span class="hljs-string">&quot;-&quot;</span>&amp;&amp;s!=<span class="hljs-string">&quot;*&quot;</span>&amp;&amp;s!=<span class="hljs-string">&quot;/&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>                    num+=(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, (s.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>));<br>                &#125;<br>                numStack.<span class="hljs-built_in">push</span>(-num);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>                    num+=(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, (s.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>));<br>                &#125;<br>                numStack.<span class="hljs-built_in">push</span>(num);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> b=numStack.<span class="hljs-built_in">top</span>();<br>            numStack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> a=numStack.<span class="hljs-built_in">top</span>();<br>            numStack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;+&quot;</span>)&#123;<br>                numStack.<span class="hljs-built_in">push</span>(a+b);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;-&quot;</span>)&#123;<br>                numStack.<span class="hljs-built_in">push</span>(a-b);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;*&quot;</span>)&#123;<br>                numStack.<span class="hljs-built_in">push</span>(a*b);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;/&quot;</span>)&#123;<br>                numStack.<span class="hljs-built_in">push</span>(a/b);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numStack.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口最大值（单调队列⭐⭐⭐）"><a href="#滑动窗口最大值（单调队列⭐⭐⭐）" class="headerlink" title="滑动窗口最大值（单调队列⭐⭐⭐）"></a>滑动窗口最大值（单调队列⭐⭐⭐）</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">LeetCode.239</a></p><p><img src="/article_img/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif"><br>需要使用单调队列解题，单调队列指队列中元素从大到小排列，队列头的元素最大，使用<strong>deque</strong>实现单调队列，使用单调队列时间复杂度为O(n)；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>&#123; <span class="hljs-comment">// 单调队列</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!deque.<span class="hljs-built_in">empty</span>()&amp;&amp;x==deque.<span class="hljs-built_in">front</span>())<br>            deque.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(deque.<span class="hljs-built_in">empty</span>()||deque.<span class="hljs-built_in">back</span>()&gt;=x)&#123;<br>            deque.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!deque.<span class="hljs-built_in">empty</span>()&amp;&amp;deque.<span class="hljs-built_in">back</span>()&lt;x)&#123;<br>                deque.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            deque.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> deque.<span class="hljs-built_in">front</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; deque;<br>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;=k)&#123;<br>        <span class="hljs-type">int</span> maxValue=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            maxValue=<span class="hljs-built_in">max</span>(nums[i], maxValue);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(maxValue);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    MyQueue myQueue;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;k)&#123;<br>            <span class="hljs-keyword">while</span>(i&lt;k)&#123;<br>                myQueue.<span class="hljs-built_in">push</span>(nums[i]);<br>                i++;<br>            &#125;<br>            i--;<br>            res.<span class="hljs-built_in">push_back</span>(myQueue.<span class="hljs-built_in">getMaxValue</span>());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            myQueue.<span class="hljs-built_in">pop</span>(nums[i-k]);<br>            myQueue.<span class="hljs-built_in">push</span>(nums[i]);<br>            res.<span class="hljs-built_in">push_back</span>(myQueue.<span class="hljs-built_in">getMaxValue</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="前k个高频元素（⭐⭐⭐）"><a href="#前k个高频元素（⭐⭐⭐）" class="headerlink" title="前k个高频元素（⭐⭐⭐）"></a>前k个高频元素（⭐⭐⭐）</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">LeetCode.347</a></p><p>使用unordered_map记录元素出现次数，使用 <strong>大小为k的小顶堆</strong> 遍历map，小顶堆元素超过k就弹出最小元素（pop），最后剩下的小顶堆中的k个元素就是前k个高频元素。</p><p>大顶堆小顶堆在C++中使用 <strong>priority_queue</strong> 实现；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myCompare</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> lhs.second&gt;rhs.second;<br>    &#125;<br>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>        map[nums[i]]++;<br>    &#125;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, myCompare&gt; pri_que;<br>    <span class="hljs-keyword">for</span>(unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator ite=map.<span class="hljs-built_in">begin</span>();ite!=map.<span class="hljs-built_in">end</span>();ite++)&#123;<br>        pri_que.<span class="hljs-built_in">push</span>(*ite);<br>        <span class="hljs-keyword">if</span>(pri_que.<span class="hljs-built_in">size</span>()&gt;k)&#123;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(k)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        res[i]=pri_que.<span class="hljs-built_in">top</span>().first;<br>        pri_que.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-[刷题]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-双指针</title>
    <link href="/2024/01/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2024/01/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>本章题目之前全都出现过，这里再写一遍进行复习；双指针法是很重要的解题思想，因此本章的题目都很重要（⭐⭐⭐）</p><span id="more"></span><h1 id="移除元素（⭐）"><a href="#移除元素（⭐）" class="headerlink" title="移除元素（⭐）"></a>移除元素（⭐）</h1><p><a href="https://leetcode.cn/problems/remove-element/description/">LeetCode.27</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>,fast=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;fast&lt;nums.<span class="hljs-built_in">size</span>();fast++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[fast]!=val)&#123;<br>            nums[slow]=nums[fast];<br>            slow++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/description/">LeetCode.344</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&lt;j;i++,j--)&#123;<br>        <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h1><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">LeetCode.151</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpace</span><span class="hljs-params">(string&amp; s)</span> </span>&#123; <span class="hljs-comment">// ⭐</span><br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; fast &lt; s.<span class="hljs-built_in">size</span>(); fast++) &#123;<br>        <span class="hljs-keyword">if</span> (s[fast] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>) &#123;<br>                s[slow] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                slow++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                s[slow++] = s[fast++];<br>            &#125;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-built_in">resize</span>(slow);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start,j=end;i&lt;j;i++,j--)&#123;<br>        <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>    &#125;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-built_in">removeExtraSpace</span>(s);<br>    <span class="hljs-built_in">reverse</span>(s,<span class="hljs-number">0</span>,s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    <span class="hljs-type">int</span> begin=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i==s.<span class="hljs-built_in">size</span>()||s[i]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            <span class="hljs-built_in">reverse</span>(s, begin, i<span class="hljs-number">-1</span>);<br>            begin=i+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode.206</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next=pre;<br>        pre=cur;<br>        cur=temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">LeetCode.19</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    ListNode* slow=dummyHead;<br>    ListNode* fast=dummyHead;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        fast=fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;   <br>        slow=slow-&gt;next;<br>        fast=fast-&gt;next;<br>    &#125;<br>    slow-&gt;next=slow-&gt;next-&gt;next;<br>    <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相交链表（⭐）"><a href="#相交链表（⭐）" class="headerlink" title="相交链表（⭐）"></a>相交链表（⭐）</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">LeetCode.160</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-type">int</span> lenA=<span class="hljs-number">0</span>,lenB=<span class="hljs-number">0</span>;<br>    ListNode* pA=headA;<br>    ListNode* pB=headB;<br>    <span class="hljs-keyword">while</span>(pA!=<span class="hljs-literal">nullptr</span>)&#123; <span class="hljs-comment">// 求A链表长度</span><br>        lenA++;<br>        pA=pA-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(pB!=<span class="hljs-literal">nullptr</span>)&#123; <span class="hljs-comment">// 求B链表长度</span><br>        lenB++;<br>        pB=pB-&gt;next;<br>    &#125;<br>    pA=headA,pB=headB;<br>    <span class="hljs-type">int</span> difference=<span class="hljs-number">0</span>; <span class="hljs-comment">// 求差值</span><br>    <span class="hljs-keyword">if</span>(lenA&gt;lenB)&#123; <span class="hljs-comment">// 让长表先走</span><br>        difference=lenA-lenB;<br>        <span class="hljs-keyword">while</span>(difference--)&#123;<br>            pA=pA-&gt;next;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        difference=lenB-lenA;<br>        <span class="hljs-keyword">while</span>(difference--)&#123;<br>            pB=pB-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(pA!=<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span>(pA==pB)&#123;<br>            <span class="hljs-keyword">return</span> pA;<br>        &#125;<br>        pA=pA-&gt;next;<br>        pB=pB-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="环形链表（⭐⭐⭐）"><a href="#环形链表（⭐⭐⭐）" class="headerlink" title="环形链表（⭐⭐⭐）"></a>环形链表（⭐⭐⭐）</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">LeetCode.142</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    ListNode* slow=head;<br>    ListNode* fast=head;<br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>        fast=fast-&gt;next-&gt;next;<br>        slow=slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast==slow)&#123;<br>            ListNode* index1=slow;<br>            ListNode* index2=head;<br>            <span class="hljs-keyword">while</span>(index1!=index2)&#123;<br>                index1=index1-&gt;next;<br>                index2=index2-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> index1;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三数之和（⭐⭐⭐）"><a href="#三数之和（⭐⭐⭐）" class="headerlink" title="三数之和（⭐⭐⭐）"></a>三数之和（⭐⭐⭐）</h1><p><a href="https://leetcode.cn/problems/3sum/description/">LeetCode.15</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i<span class="hljs-number">-1</span>]==nums[i])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> tempSum=nums[i]+nums[left]+nums[right];<br>            <span class="hljs-keyword">if</span>(tempSum&gt;<span class="hljs-number">0</span>)&#123;<br>                right--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tempSum&lt;<span class="hljs-number">0</span>)&#123;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tempSum==<span class="hljs-number">0</span>)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);<br>                <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="hljs-number">1</span>])&#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right<span class="hljs-number">-1</span>])&#123;<br>                    right--;<br>                &#125;<br>                left++;<br>                right--;<br>            &#125;<br>        &#125;<br>    &#125;    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四数之和（⭐⭐）"><a href="#四数之和（⭐⭐）" class="headerlink" title="四数之和（⭐⭐）"></a>四数之和（⭐⭐）</h1><p><a href="https://leetcode.cn/problems/4sum/description/">LeetCode.18</a></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;nums.<span class="hljs-built_in">size</span>();k++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[k]&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[k]&gt;target)&#123;<br>            <span class="hljs-keyword">break</span>; <br>        &#125;<br>        <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>&amp;&amp;nums[k]==nums[k<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k+<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]+nums[k]&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i]&gt;target-nums[k])&#123;<br>                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// ⭐ 一定要用break，否则会漏掉结果</span><br>            &#125; <br>            <span class="hljs-keyword">if</span>(i&gt;k+<span class="hljs-number">1</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> left=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-type">long</span> tempSum=(<span class="hljs-type">long</span>)nums[k]+nums[i]+nums[left]+nums[right];<br>                <span class="hljs-keyword">if</span>(tempSum&gt;target)&#123;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tempSum&lt;target)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[k],nums[i],nums[left],nums[right]&#125;);<br>                    <span class="hljs-comment">// ⭐ 去重逻辑一定要在加入一个数对之后，否则[0,0,0,0]这种就直接漏掉了</span><br>                    <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="hljs-number">1</span>])&#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right<span class="hljs-number">-1</span>])&#123;<br>                        right--;<br>                    &#125;<br>                    left++;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-[刷题]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-字符串</title>
    <link href="/2024/01/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/01/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>字符串</p><span id="more"></span><h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/submissions/495164492/">LeetCode.344</a></p><p>双指针很简单；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-type">char</span> temp;<br>        temp=s[left];<br>        s[left]=s[right];<br>        s[right]=temp;<br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反转字符串Ⅱ（⭐）"><a href="#反转字符串Ⅱ（⭐）" class="headerlink" title="反转字符串Ⅱ（⭐）"></a>反转字符串Ⅱ（⭐）</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/description/">LeetCode.541</a></p><p>在for循环中直接每次递增2k即可，不需要递增1然后再判断相等；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(start&lt;end)&#123;<br>        <span class="hljs-type">char</span> temp=s[start];<br>        s[start]=s[end];<br>        s[end]=temp;<br>        start++;<br>        end--;<br>    &#125;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i+=<span class="hljs-number">2</span>*k)&#123;<br>        <span class="hljs-keyword">if</span>(i+k&gt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-built_in">reverse</span>(s, i, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()-i&gt;=k&amp;&amp;s.<span class="hljs-built_in">size</span>()-i&lt;<span class="hljs-number">2</span>*k)&#123;<br>            <span class="hljs-built_in">reverse</span>(s, i, i+k<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">reverse</span>(s, i, i+k<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="翻转字符串里的单词（⭐⭐⭐）"><a href="#翻转字符串里的单词（⭐⭐⭐）" class="headerlink" title="翻转字符串里的单词（⭐⭐⭐）"></a>翻转字符串里的单词（⭐⭐⭐）</h1><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">LeetCode.151</a></p><p>本题大致思路是先整体反转字符串，再反转每个单词，关键难点在于去除多余的空格，思路是数组章节的<a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a>的思路：快慢指针前进，将快指针值赋给慢指针，遇到空格不操作；难点在于要保留单词间的空格；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start,j=end;i&lt;j;i++, j--)&#123;<br>        <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpace</span><span class="hljs-params">(string&amp; s)</span></span>&#123;<br>    <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(slow!=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 要为每个单词前加一个空格，除了第一个单词</span><br>                s[slow++]=<span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;s[i]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123; <span class="hljs-comment">// 继续操作</span><br>                s[slow++]=s[i++];<br>            &#125;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">// slow的大小为去除多余空格后的大小</span><br>&#125;<br><span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-built_in">removeExtraSpace</span>(s);<br>    <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i==s.<span class="hljs-built_in">size</span>()||s[i]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            <span class="hljs-built_in">reverse</span>(s, slow, i<span class="hljs-number">-1</span>);<br>            slow=i+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="找出字符串中第一个匹配项的下标（KMP⭐⭐）"><a href="#找出字符串中第一个匹配项的下标（KMP⭐⭐）" class="headerlink" title="找出字符串中第一个匹配项的下标（KMP⭐⭐）"></a>找出字符串中第一个匹配项的下标（KMP⭐⭐）</h1><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">LeetCode.28</a></p><p>KMP算法，算法的精髓是每次不是只向后移一位，而是尽可能多的后移，依靠的就是重复的前后缀，也就是尽可能多的利用已经比较过的：<br><img src="/../article_img/KMP1.gif"><br>KMP算法一般不会遇到（但要知道原理），使用string类函数find即可；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> haystack.<span class="hljs-built_in">find</span>(needle);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="重复的子字符串（⭐⭐）"><a href="#重复的子字符串（⭐⭐）" class="headerlink" title="重复的子字符串（⭐⭐）"></a>重复的子字符串（⭐⭐）</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">LeetCode.459</a></p><p><img src="/article_img/2024-01-14-09-32-08.png"><br>如果一个字符串由重复的子字符串组成，那么一定有重复的前后缀，因此把两个字符串相加，前后缀就还可以组成一个原本的字符串，利用这个性质即可解题；注意要掐头去尾，否则原字符串永远存在；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    string t=s+s;<br>    t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">begin</span>());<br>    t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">find</span>(s)!=<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-[刷题]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-哈希表</title>
    <link href="/2024/01/10/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2024/01/10/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>哈希表</p><span id="more"></span><h1 id="哈希表基础"><a href="#哈希表基础" class="headerlink" title="哈希表基础"></a>哈希表基础</h1><p>哈希表是根据关键码的值而<strong>直接</strong>进行访问的数据结构。因此数组就是一种哈希表，通过数组下标直接访问数组内容；</p><h2 id="哈希函数（HashFunc）"><a href="#哈希函数（HashFunc）" class="headerlink" title="哈希函数（HashFunc）"></a>哈希函数（HashFunc）</h2><p>哈希表需要设计一个<strong>哈希函数</strong>用来把元素内容映射到哈希表中；</p><h2 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><p>同时当映射值相同时，称为哈希碰撞，处理哈希碰撞有两种常见的方法：</p><ol><li>线性探索法：发生碰撞时向后寻找可以存放的位置存放；要求哈希表长度一定要大于数据长度，否则就放不下了；</li><li>拉链法：发生碰撞后将新元素链接到原来元素链的尾部，下次查找时通过索引查找元素链表；C++STL的<strong>hashtable</strong>就使用了拉链法，但是当链表过长时，就相当于对链表进行查找，效率很差，因此STL中的 <strong>hashtable</strong> 会在元素个数大于哈希表长度时，扩大哈希表长度为原来的二倍并调整到接近的质数，再进行重新建表（<strong>rehashing</strong>）；</li></ol><h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><ol><li>unordered_set：键值相同；</li><li>unordered_map：键值不同；</li></ol><h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><p><a href="https://leetcode.cn/problems/valid-anagram/description/">LeetCode.242</a></p><p>本题考查对哈希表的理解，<strong>数组也是一个哈希表</strong>，对于简单的元素类型不需要使用unordered_set或unordered_map，使用数组即可。</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 相当于一个哈希表</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s)&#123;  <span class="hljs-comment">// 记录s中出现字母的次数</span><br>        record[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:t)&#123;  <span class="hljs-comment">// 记录t中出现字母的次数</span><br>        record[c-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:record)&#123;  <span class="hljs-comment">// 如果有字母出现次数不为0，说明不是异位词</span><br>        <span class="hljs-keyword">if</span>(c!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="两个数组的交集（unordered-set用法总结⭐）"><a href="#两个数组的交集（unordered-set用法总结⭐）" class="headerlink" title="两个数组的交集（unordered_set用法总结⭐）"></a>两个数组的交集（unordered_set用法总结⭐）</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">LeetCode.349</a></p><p>本题使用哈希表，主要要注意unordered_set的用法：</p><ol><li>初始化：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">unordered_set&lt;<span class="hljs-type">int</span>&gt; set1; <span class="hljs-comment">// 初始化空unordered_set</span><br><span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set2</span><span class="hljs-params">(set1)</span></span>; <span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set3</span><span class="hljs-params">(set2.begin(), set2.end())</span></span>; <span class="hljs-comment">// 选取部分元素构造</span><br><span class="hljs-comment">// 通过数组构造</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set4</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>; <br></code></pre></td></tr></table></figure></li><li>查找：<strong>find(key)</strong> 查找以值为 key 的元素，如果找到，则返回一个指向该元素的<strong>正向迭代器</strong>；反之，则返回一个指向容器中<strong>最后一个元素之后位置的迭代器</strong>：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(i)!=set.<span class="hljs-built_in">end</span>())&#123;<br>     <span class="hljs-comment">// 找到了i</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums1_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>; <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:nums2)&#123;<br>        <span class="hljs-keyword">if</span>(nums1_set.<span class="hljs-built_in">find</span>(i)!=nums1_set.<span class="hljs-built_in">end</span>())&#123;  <span class="hljs-comment">// 查找</span><br>            res.<span class="hljs-built_in">insert</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快乐数（⭐⭐）"><a href="#快乐数（⭐⭐）" class="headerlink" title="快乐数（⭐⭐）"></a>快乐数（⭐⭐）</h1><p><a href="https://leetcode.cn/problems/happy-number/description/">LeetCode.202</a><br><img src="/article_img/2024-01-10-10-04-18.png"><br>题目中说了会 <strong>无限循环</strong>，那么也就是说求和的过程中，<strong>sum会重复出现</strong>，这对解题很重要！</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;  <span class="hljs-comment">// 计算新的n</span><br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>        n=n/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; sum_set;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">getSum</span>(n);<br>    <span class="hljs-keyword">while</span>(sum_set.<span class="hljs-built_in">find</span>(sum)==sum_set.<span class="hljs-built_in">end</span>())&#123; <span class="hljs-comment">// 每位之和没出现过</span><br>        sum_set.<span class="hljs-built_in">insert</span>(sum); <br>        n=sum;<br>        sum=<span class="hljs-built_in">getSum</span>(n);<br>        <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 满足题意</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="两数之和（哈希法妙啊⭐）"><a href="#两数之和（哈希法妙啊⭐）" class="headerlink" title="两数之和（哈希法妙啊⭐）"></a>两数之和（哈希法妙啊⭐）</h1><p><a href="https://leetcode.cn/problems/two-sum/description/">LeetCode.1</a></p><p><img src="/article_img/2024-01-10-10-21-35.png"><br><img src="/article_img/2024-01-10-10-21-42.png"></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; desiredNum_set;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> need = target-nums[i];  <span class="hljs-comment">// 如果当前元素要加一个数得target，应该加哪个数</span><br>        <span class="hljs-keyword">if</span>(desiredNum_set.<span class="hljs-built_in">find</span>(need)!=desiredNum_set.<span class="hljs-built_in">end</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            res.<span class="hljs-built_in">push_back</span>(desiredNum_set[need]);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            desiredNum_set.<span class="hljs-built_in">insert</span>(&#123;nums[i], i&#125;); <span class="hljs-comment">// 添加键值对</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四数相加II（⭐）"><a href="#四数相加II（⭐）" class="headerlink" title="四数相加II（⭐）"></a>四数相加II（⭐）</h1><p><a href="https://leetcode.cn/problems/4sum-ii/">LeetCode.454</a></p><p>本题是两数之和的进阶版，大体思路类似，也是用哈希表记录 <strong>+后等于零需要+的值</strong>，但是由于是四个数组，就两两先相加再判断，需要注意的是要记录相加后结果出现的次数，如前两个数组相加结果为3的数对有2个，后两个数组之和为-3的数组有3个，那么最终结果是2*3&#x3D;6个数对；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:nums1)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b:nums2)&#123;<br>            <span class="hljs-type">int</span> tempSum=a+b;<br>            map[tempSum]++;  <span class="hljs-comment">// 特殊用法，如果没有tempSum就insert，有就对值++</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:nums3)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d:nums4)&#123;<br>            <span class="hljs-type">int</span> tempSum=c+d;<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-tempSum)!=map.<span class="hljs-built_in">end</span>())&#123;<br>                res+=map[<span class="hljs-number">0</span>-tempSum];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h1><p><a href="https://leetcode.cn/problems/ransom-note/description/">LeetCode.383</a></p><p>本题简单，注意不要遇到查找就只想到哈希表（unordered_map等等），<strong>数组也是哈希表！</strong> 本题只需要记录26个字母，使用数组又快内存又小！</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 数组</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>    <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:magazine)&#123;<br>        record[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:ransomNote)&#123;<br>        <span class="hljs-keyword">if</span>(record[c-<span class="hljs-string">&#x27;a&#x27;</span>]!=<span class="hljs-number">0</span>)&#123;<br>            record[c-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 哈希表</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; map;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:magazine)&#123;<br>        map[c]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:ransomNote)&#123;<br>        <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">find</span>(c)!=map.<span class="hljs-built_in">end</span>()&amp;&amp;map[c]!=<span class="hljs-number">0</span>)&#123;<br>            map[c]--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三数之和（用双指针⭐⭐⭐）"><a href="#三数之和（用双指针⭐⭐⭐）" class="headerlink" title="三数之和（用双指针⭐⭐⭐）"></a>三数之和（用双指针⭐⭐⭐）</h1><p><a href="https://leetcode.cn/problems/3sum/description/">LeetCode.15</a></p><p><img src="/article_img/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif"></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> tempSum = nums[i] + nums[left] + nums[right];<br>            <span class="hljs-keyword">if</span> (tempSum &gt; <span class="hljs-number">0</span>) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tempSum &lt; <span class="hljs-number">0</span>) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);<br>                <span class="hljs-keyword">while</span> (right&gt;left&amp;&amp;nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">while</span> (right&gt;left&amp;&amp;nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>                    right--;<br>                &#125;<br>                left++;<br>                right--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四数之和（⭐⭐）"><a href="#四数之和（⭐⭐）" class="headerlink" title="四数之和（⭐⭐）"></a>四数之和（⭐⭐）</h1><p><a href="https://leetcode.cn/problems/4sum/description/">LeetCode.18</a></p><p>注意不是四数之和等于0，而是等于target，target有可能为负数，剪枝时要注意；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] + nums[i] &gt; target &amp;&amp; nums[j] + nums[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> left = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-type">long</span> tempSum = nums[i] + nums[j] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (tempSum &gt; target) &#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tempSum &lt; target) &#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(<br>                        &#123;nums[i], nums[j], nums[left], nums[right]&#125;);<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>                        right--;<br>                    &#125;<br>                    left++;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-[刷题]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-链表</title>
    <link href="/2024/01/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/01/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>链表</p><span id="more"></span><h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">LeetCode.203</a></p><p>很基础的链表操作，需要注意删除头节点与删除其他节点操作不同；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    ListNode* slow = head;<br>    ListNode* p = head;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val == val)&#123;<br>            <span class="hljs-keyword">if</span>(p==head)&#123;<br>                head=p-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                slow-&gt;next = p-&gt;next;<br>                p = p-&gt;next; <span class="hljs-comment">// 成功删除p，slow不变，p指向后一元素</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 未删除元素，slow后移一位到p位置，p指向后一位元素</span><br>            slow = p;<br>            p=p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">LeetCode.707</a></p><p>思路很简单，主要考察有没有注意一些细节，核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyListNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    MyListNode* next;<br>    <span class="hljs-built_in">MyListNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">MyListNode</span>(<span class="hljs-type">int</span> v):<span class="hljs-built_in">val</span>(v),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyLinkedList</span>()&#123;<br>        dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyListNode</span>();<br>        ListLength = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;ListLength)&#123;<br>            <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>            MyListNode* p = dummyHead-&gt;next;<br>            <span class="hljs-keyword">while</span>(i&lt;index)&#123;<br>                p=p-&gt;next;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> p-&gt;val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;  <br>        MyListNode* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyListNode</span>(val);<br>        p-&gt;next = dummyHead-&gt;next;<br>        dummyHead-&gt;next = p;<br>        ListLength++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        MyListNode* p = dummyHead;<br>        <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            p=p-&gt;next;<br>        &#125;<br>        MyListNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyListNode</span>(val);<br>        p-&gt;next = newNode;<br>        ListLength++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;ListLength)&#123;<br>            MyListNode* p=dummyHead;<br>            <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;index)&#123;<br>                p=p-&gt;next;<br>                i++;<br>            &#125;<br>            MyListNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyListNode</span>(val);<br>            newNode-&gt;next = p-&gt;next;<br>            p-&gt;next = newNode;<br>            ListLength++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index==ListLength)&#123;<br>            <span class="hljs-built_in">addAtTail</span>(val);  <span class="hljs-comment">// 不要再更新链表长度，函数中已经更新过了</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;ListLength)&#123;<br>            MyListNode* p = dummyHead;<br>            <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;index)&#123;<br>                p=p-&gt;next;<br>                i++;<br>            &#125;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>            ListLength--;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    MyListNode* dummyHead;<br>    <span class="hljs-type">int</span> ListLength = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="反转链表（⭐⭐）"><a href="#反转链表（⭐⭐）" class="headerlink" title="反转链表（⭐⭐）"></a>反转链表（⭐⭐）</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode.206</a></p><p><img src="/article_img/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif"><br>本题有递归法和双指针法两种解法，递归法就是严格按照双指针思路写的；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 双指针法</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>        ListNode* temp = cur-&gt;next;  <span class="hljs-comment">// 临时变量记录cur下一个要去的位置</span><br>        cur-&gt;next = pre;  <br>        pre = cur;<br>        cur = temp;<br>    &#125;<br>    head = pre;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">// 递归法</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* cur, ListNode* pre)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    ListNode* temp = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(temp, cur);<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(head, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="两两交换链表中的节点（⭐）"><a href="#两两交换链表中的节点（⭐）" class="headerlink" title="两两交换链表中的节点（⭐）"></a>两两交换链表中的节点（⭐）</h1><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">LeetCode.24</a></p><p>链表题最好做的时候画图帮助理解：<br><img src="/article_img/2024-01-04-11-50-09.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    ListNode* cur = dummyHead;<br>    <span class="hljs-keyword">while</span>(cur-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>        ListNode* temp1 = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        ListNode* temp2 = cur-&gt;next-&gt;next;<br>        cur-&gt;next-&gt;next = temp1;<br>        temp1-&gt;next = temp2;<br>        cur=cur-&gt;next-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">LeetCode.19</a></p><p><img src="/article_img/2024-01-09-09-43-37.png"><br>本题是典型的快慢指针，可以实现一次循环删除倒数第N个节点，时间复杂度O(N)；<br><strong>注意：涉及链表删除的题目要使用虚拟头节点！</strong> 可以确保删除头结点时操作和删除中间节点相同，不容易写错；</p><p>关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>ListNode* slow = dummyHead;<br>ListNode* fast = head;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;n)&#123;  <span class="hljs-comment">// 快指针先走</span><br>    fast=fast-&gt;next;<br>    i++;<br>&#125;<br><span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)&#123; <span class="hljs-comment">// 快慢指针一起走，确定倒数第N个节点位置</span><br>    slow=slow-&gt;next;<br>    fast=fast-&gt;next;<br>&#125;<br>slow-&gt;next=slow-&gt;next-&gt;next;  <span class="hljs-comment">// 删除指定节点</span><br><span class="hljs-keyword">return</span> dummyHead-&gt;next; <span class="hljs-comment">//返回头节点</span><br></code></pre></td></tr></table></figure><h1 id="相交链表（⭐）"><a href="#相交链表（⭐）" class="headerlink" title="相交链表（⭐）"></a>相交链表（⭐）</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">LeetCode.160</a></p><p><img src="/article_img/2024-01-09-09-52-36.png"></p><p>思路为先分别求两个链表长度，之后让长链表移动到与短链表长度相同的位置，再同时向后移动两个链表并比较是否相等；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-type">int</span> lenA=<span class="hljs-number">0</span>, lenB=<span class="hljs-number">0</span>;<br>    ListNode* pA = headA;<br>    ListNode* pB = headB;<br>    <span class="hljs-keyword">while</span>(pA!=<span class="hljs-literal">nullptr</span>)&#123;  <span class="hljs-comment">// 求出A链表长度</span><br>        pA=pA-&gt;next;<br>        lenA++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(pB!=<span class="hljs-literal">nullptr</span>)&#123;  <span class="hljs-comment">// 求出B链表长度</span><br>        pB=pB-&gt;next;<br>        lenB++;<br>    &#125;<br>    pA=headA;<br>    pB=headB;<br>    <span class="hljs-keyword">if</span>(lenA&gt;lenB)&#123;  <span class="hljs-comment">// 让长的链表前进到与短链表相同长度</span><br>        <span class="hljs-type">int</span> diff = lenA-lenB;<br>        <span class="hljs-keyword">while</span>(diff--)&#123;<br>            pA=pA-&gt;next;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> diff = lenB-lenA;<br>        <span class="hljs-keyword">while</span>(diff--)&#123;<br>            pB=pB-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(pA!=<span class="hljs-literal">nullptr</span>)&#123;  <span class="hljs-comment">// 同时向后移动，若相同则说明相交</span><br>        <span class="hljs-keyword">if</span>(pA==pB)&#123;<br>            <span class="hljs-keyword">return</span> pA;<br>        &#125;<br>        pA=pA-&gt;next;<br>        pB=pB-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="环形链表（⭐⭐⭐）"><a href="#环形链表（⭐⭐⭐）" class="headerlink" title="环形链表（⭐⭐⭐）"></a>环形链表（⭐⭐⭐）</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">LeetCode.142</a></p><p>本题有一些技巧，首先是如何判断链表有环，使用快慢指针，快指针一次走两步，慢指针一次走一步，如果有环则一定会套圈；之后要判断环的入口在哪：<br><img src="/article_img/2024-01-09-10-39-47.png"><br>做如上图所示的假设，慢指针走过的路程为（x+y），快指针走过的路程为（x+y+n*(y+z)），且由快指针一次两步，慢指针一次一步可以列出等式  <strong>2(x+y)&#x3D;x+y+n(y+z)</strong> ，经过计算可得 <strong>x&#x3D;z</strong>，因此可以记录相遇点，从相遇点和头节点同时向后移动即可找到环的入口：<br><img src="/article_img/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif"></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    ListNode* slow = head;<br>    ListNode* fast = head;<br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>        fast=fast-&gt;next-&gt;next;<br>        slow=slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast==slow)&#123;<br>            ListNode* index1=slow;<br>            ListNode* index2=head;<br>            <span class="hljs-keyword">while</span>(index1!=index2)&#123;<br>                index1=index1-&gt;next;<br>                index2=index2-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> index1;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-[刷题]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-数组</title>
    <link href="/2023/12/28/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%95%B0%E7%BB%84/"/>
    <url>/2023/12/28/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>数组</p><span id="more"></span><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/">LeetCode.704</a></p><p>二分查找针对有序数组，每次能排除一半的元素，查找时间复杂度<strong>O(logN)<strong>；<br>二分查找代码编写时容易出错的是</strong>循环中止条件</strong>以及<strong>缩小区间时首位位置的确定</strong>，主要根据二分区间的<strong>左右开闭</strong>确定，建议使用左闭右闭区间，容易记忆。</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> end = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(begin &lt;= end)&#123;  <span class="hljs-comment">// [begin, end]，左闭右闭区间，左右边界可以相等</span><br>    <span class="hljs-type">int</span> middle = (begin + end)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(nums[middle]&gt;target)&#123;<br>        end = middle<span class="hljs-number">-1</span>;  <span class="hljs-comment">// 搜索左半区间</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle]&lt;target)&#123;<br>        begin = middle +<span class="hljs-number">1</span>;  <span class="hljs-comment">// 搜索右半区间</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> middle;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移除元素（快慢指针）（⭐）"><a href="#移除元素（快慢指针）（⭐）" class="headerlink" title="移除元素（快慢指针）（⭐）"></a>移除元素（快慢指针）（⭐）</h1><p><a href="https://leetcode.cn/problems/remove-element/">LeetCode.27</a></p><p>这题考察的是对数组的元素删除，最暴力的思路是查找到要删除的元素，将其后的所有元素往前移一位并将数组长度减一，实现“删除”操作，这种算法时间复杂度为 <strong>O(N)<strong>。<br>还可以使用</strong>快慢指针</strong>的方法，很巧妙，快指针指向的元素覆盖慢指针指向的元素，但是当快指针指向要删除元素时，不赋值并且<strong>不递增慢指针</strong>（让慢指针指向要删除的元素）；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>;fast&lt;nums.<span class="hljs-built_in">size</span>();fast++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[fast]!=val)&#123;<br>        nums[slow]=nums[fast];<br>        slow++;<br>        <span class="hljs-comment">// nums[slow++]=nums[fast]; 后加加表示先取值进行运算再加</span><br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 当走到要删除的元素时，不赋值并让slow指向该位置，走到不是要删除元素时，就会覆盖当前slow指向的元素，并将数组长度减一</span><br>        len--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> len;<br></code></pre></td></tr></table></figure><h1 id="有序数组的平方（双指针）"><a href="#有序数组的平方（双指针）" class="headerlink" title="有序数组的平方（双指针）"></a>有序数组的平方（双指针）</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LeetCode.977</a></p><p>此题暴力解法就是全平方再排序（快排），时间复杂度O(NlogN)；<br>还可以使用<strong>双指针</strong>的方法，因为有序数组中有负数，那么平方后的最大值一定是最小的负数或者最大的正数，因此用两个指针分别指向头尾，比较平方后的值再填入新数组即可；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> end = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size())</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=end;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>    <span class="hljs-type">int</span> sqrt_begin = nums[begin]*nums[begin];<br>    <span class="hljs-type">int</span> sqrt_end = nums[end]*nums[end];<br>    <span class="hljs-keyword">if</span>(sqrt_begin&gt;sqrt_end)&#123;<br>        res[i]=sqrt_begin;<br>        begin++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        res[i]=sqrt_end;<br>        end--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><h1 id="长度最小的子数组-滑动窗口（⭐⭐）"><a href="#长度最小的子数组-滑动窗口（⭐⭐）" class="headerlink" title="长度最小的子数组|滑动窗口（⭐⭐）"></a>长度最小的子数组|滑动窗口（⭐⭐）</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">LeetCode.209</a></p><p>此题暴力法就是计算每个子数组的长度，时间复杂度为O(N^2)；<br>更好的方法是<strong>滑动窗口</strong>，一个for循环先向后遍历并记录当前sum值，当sum大于等于target时，记录当前子数组长度，之后开始移动慢指针缩小子数组长度，for循环遍历结束后即可得到最小的子数组长度；<br>时间复杂度为**O(N)**，虽然循环中还有一个循环，但是每个元素只被操作了两次（进滑动窗口时加到sum，出滑动窗口时从sum减去），共操作了2N次；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> slowPtr = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>    sum+=nums[i];<br>    <span class="hljs-keyword">while</span>(sum&gt;=target)&#123;   <br>        <span class="hljs-type">int</span> subL = i-slowPtr+<span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录当前子数组长度</span><br>        <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)&#123;<br>            res = subL;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res = <span class="hljs-built_in">min</span>(res, subL);<br>        &#125;<br>        sum-=nums[slowPtr]; <span class="hljs-comment">// 向后移动慢指针</span><br>        slowPtr++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">LeetCode.59</a></p><p><img src="/article_img/2024-01-02-10-19-30.png"></p><p>此题为一道模拟题，没什么算法，主要要注意边界处理要一致（如上图所示）；</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n)); <span class="hljs-comment">// 使用vector定义二维数组</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <br><span class="hljs-type">int</span> loop = n/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> mid = n/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> i, j;<br><span class="hljs-keyword">while</span>(loop&gt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">for</span>(j=starty;j&lt;n-offset;j++)&#123; <span class="hljs-comment">// 每一圈从startx，starty开始，offset控制尾部不处理</span><br>        res[startx][j]=count++; <span class="hljs-comment">// 后加加，先赋值再加；</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=startx;i&lt;n-offset;i++)&#123;<br>        res[i][j]=count++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(;j&gt;starty;j--)&#123;<br>        res[i][j]=count++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(;i&gt;startx;i--)&#123;<br>        res[i][j]=count++;<br>    &#125;<br>    startx++;<br>    starty++;<br>    offset++;<br>    loop--;<br>&#125;<br><span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>    res[mid][mid]=count;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-[刷题]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lyra动画系统-Locomotion</title>
    <link href="/2023/12/23/Lyra%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E5%A4%8D%E7%8E%B0-Locomotion/"/>
    <url>/2023/12/23/Lyra%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E5%A4%8D%E7%8E%B0-Locomotion/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="距离匹配（Distance-Matching）"><a href="#距离匹配（Distance-Matching）" class="headerlink" title="距离匹配（Distance Matching）"></a>距离匹配（Distance Matching）</h1><p>距离匹配是一种避免<strong>胶囊体速度与动画根运动速度不匹配</strong>造成的滑步等现象的技术；我们人类在运动的时候几乎不会是匀速运动或者匀加速运动，因此动捕出来的动画数据的加速度也不是匀速的，而由程序驱动的胶囊体的加速是匀速的，就会造成速度与动画不匹配，产生滑步现象：<br><img src="/article_img/2024-01-03-10-34-26.png"></p><p>在UE中距离匹配是一个大概念，其中包括了三个具体的函数：<strong>Advance Time by Distance Matching</strong>，<strong>Distance Match to Target</strong>，<strong>Set Playrate to Match Speed</strong>；<br><img src="/article_img/2024-01-03-10-12-00.png"></p><p>接下来我们逐一进行分析学习；</p><h2 id="Advance-Time-by-Distance-Matching"><a href="#Advance-Time-by-Distance-Matching" class="headerlink" title="Advance Time by Distance Matching"></a>Advance Time by Distance Matching</h2><p>Advance Time by Distance Matching（根据距离匹配前进时间），看名字我们就可以看出这个函数的作用是前进时间，也就是直接跳到该播放的位置开始播放。下面是<strong>AdvanceTimeByDistanceMatching</strong>函数源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">FSequenceEvaluatorReference <span class="hljs-title">UAnimDistanceMatchingLibrary::AdvanceTimeByDistanceMatching</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...省略一些代码</span><br>   <span class="hljs-type">const</span> <span class="hljs-type">float</span> CurrentTime = InSequenceEvaluator.<span class="hljs-built_in">GetExplicitTime</span>();<br>   <span class="hljs-type">const</span> <span class="hljs-type">float</span> CurrentAssetLength = InSequenceEvaluator.<span class="hljs-built_in">GetCurrentAssetLength</span>();<br>   <span class="hljs-type">const</span> <span class="hljs-type">bool</span> bAllowLooping = InSequenceEvaluator.<span class="hljs-built_in">GetShouldLoop</span>();<br><br>   <span class="hljs-comment">// 得到曲线ID</span><br>   <span class="hljs-type">const</span> USkeleton::AnimCurveUID CurveUID = UE::Anim::DistanceMatchingUtility::<span class="hljs-built_in">GetCurveUID</span>(AnimSequence, DistanceCurveName);<br>   <span class="hljs-comment">// ---------- 核心操作，通过GetTimeAfterDistanceTraveled函数得到应该前进到那一帧 ----------</span><br>   <span class="hljs-type">float</span> TimeAfterDistanceTraveled = UE::Anim::DistanceMatchingUtility::<span class="hljs-built_in">GetTimeAfterDistanceTraveled</span>(AnimSequence, CurrentTime, DistanceTraveled, CurveUID, bAllowLooping);<br>   <span class="hljs-comment">// -------------------------------------------------------------------------------------</span><br><br>   <span class="hljs-comment">// 如果计算出应该前进到的帧比当前帧小，则说明是循环动画</span><br>   <span class="hljs-keyword">if</span> (TimeAfterDistanceTraveled &lt; CurrentTime)<br>   &#123;<br>      TimeAfterDistanceTraveled += CurrentAssetLength;<br>   &#125;<br>   <span class="hljs-comment">// 计算播放速率应该是多少，算出后再做一个clamp，限制在合理的范围</span><br>   <span class="hljs-type">float</span> EffectivePlayRate = (TimeAfterDistanceTraveled - CurrentTime) / DeltaTime;<br>   <span class="hljs-keyword">if</span> (PlayRateClamp.X &gt;= <span class="hljs-number">0.0f</span> &amp;&amp; PlayRateClamp.X &lt; PlayRateClamp.Y)<br>   &#123;<br>      EffectivePlayRate = FMath::<span class="hljs-built_in">Clamp</span>(EffectivePlayRate, PlayRateClamp.X, PlayRateClamp.Y);<br>   &#125;<br><br>   <span class="hljs-comment">// 最后前进时间，这里速率又乘上了时间，表示就是前进到之前GetTimeAfterDistanceTraveled函数算出的那一帧</span><br>   <span class="hljs-type">float</span> NewTime = CurrentTime;<br>   FAnimationRuntime::<span class="hljs-built_in">AdvanceTime</span>(bAllowLooping, EffectivePlayRate * DeltaTime, NewTime, CurrentAssetLength);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过阅读以上源码可以看出函数思路还是较为简单，要注意的是，函数是<strong>正在计算</strong>当前应该播放那一帧动画，也就是说函数中的CurrentTime其实是已经播放完的动画的上一帧，根据胶囊体在当前帧（实际也是上一帧，胶囊体已经移动过了）移动的距离，在根运动曲线中找到要移动到对应距离应该走到那一帧：<br><img src="/article_img/AdvanceTimebyDistanceMatch.jpg"></p><p>其中得到<strong>应该前进到哪一帧</strong>的关键函数<strong>GetTimeAfterDistanceTraveled</strong>的核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 省略一些</span><br><span class="hljs-type">float</span> NewTime = CurrentTime;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> StepTime = <span class="hljs-number">1.f</span> / <span class="hljs-number">30.f</span>; <span class="hljs-comment">// 每次前进的固定步长</span><br><span class="hljs-comment">// 这个循环每次前进固定时长，寻找应该前进到那一帧</span><br><span class="hljs-keyword">while</span> ((AccumulatedDistance &lt; DistanceTraveled) &amp;&amp; (bAllowLooping || (NewTime + StepTime &lt; SequenceLength)))<br>&#123;<br>   <span class="hljs-type">const</span> <span class="hljs-type">float</span> CurrentDistance = AnimSequence-&gt;<span class="hljs-built_in">EvaluateCurveData</span>(CurveUID, NewTime);<br>   <span class="hljs-type">const</span> <span class="hljs-type">float</span> DistanceAfterStep = AnimSequence-&gt;<span class="hljs-built_in">EvaluateCurveData</span>(CurveUID, NewTime + StepTime);<br>   <span class="hljs-type">const</span> <span class="hljs-type">float</span> AnimationDistanceThisStep = DistanceAfterStep - CurrentDistance;<br><br>   <span class="hljs-keyword">if</span> (!FMath::<span class="hljs-built_in">IsNearlyZero</span>(AnimationDistanceThisStep))<br>   &#123;<br>      <span class="hljs-comment">// 没有达到真实前进的位置就继续以固定步长前进</span><br>      <span class="hljs-keyword">if</span> (AccumulatedDistance + AnimationDistanceThisStep &lt; DistanceTraveled)<br>      &#123;<br>         <span class="hljs-comment">// 此函数可以理解为：NewTime=NewTime+StepTime；</span><br>         FAnimationRuntime::<span class="hljs-built_in">AdvanceTime</span>(bAllowLooping, StepTime, NewTime, SequenceLength);<br>         AccumulatedDistance += AnimationDistanceThisStep;<br>      &#125;<br>      <span class="hljs-comment">// 一旦超过了真实前进的距离就按比例计算出应该前进到哪一帧</span><br>      <span class="hljs-keyword">else</span><br>      &#123;<br>         <span class="hljs-type">const</span> <span class="hljs-type">float</span> DistanceAlpha = (DistanceTraveled - AccumulatedDistance) / AnimationDistanceThisStep;<br>         FAnimationRuntime::<span class="hljs-built_in">AdvanceTime</span>(bAllowLooping, DistanceAlpha * StepTime, NewTime, SequenceLength);<br>         AccumulatedDistance = DistanceTraveled;<br>         <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      StuckLoopCounter = <span class="hljs-number">0</span>;<br>   &#125;<br>&#125;<br><span class="hljs-keyword">return</span> NewTime;<br></code></pre></td></tr></table></figure><p>该函数一般用于起步动画：<br><img src="/article_img/2024-01-03-10-18-50.png"></p><h2 id="Distance-Match-to-Target"><a href="#Distance-Match-to-Target" class="headerlink" title="Distance Match to Target"></a>Distance Match to Target</h2><p>Distance Match to Target（距离匹配到目标点），一般用于停步动画，避免总是完整播放停步动画（角色已经停止还在播放剩余的停步动画）从而产生的滑步现象，根据真实停止所需的距离从动画中匹配要开始播放的帧；<br><img src="/article_img/2024-01-03-12-33-05.png"></p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 使用GetAnimPositionFromDistance函数找到开始播放的帧，这个函数实现就是一个二分查找</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> NewTime = UE::Anim::DistanceMatchingUtility::<span class="hljs-built_in">GetAnimPositionFromDistance</span>(AnimSequence, -DistanceToTarget, CurveUID);<br></code></pre></td></tr></table></figure><p>在使用该函数时，提供的 <strong>Stop Location（停止所需的距离）</strong> 可以通过自带的节点根据CharacterMovementComponent中的制动相关参数计算得到：<br><img src="/article_img/2024-01-03-12-48-54.png"></p><h2 id="Set-Playrate-to-Match-Speed"><a href="#Set-Playrate-to-Match-Speed" class="headerlink" title="Set Playrate to Match Speed"></a>Set Playrate to Match Speed</h2><p>Set Playrate to Match Speed（根据匹配速度设置播放速率），一般用在跑步走路等循环动画，用来根据真实移动速度调整动画播放速率，避免滑步；<br><img src="/article_img/2024-01-03-12-52-28.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">float</span> AnimLength = AnimSequence-&gt;<span class="hljs-built_in">GetPlayLength</span>();<br><span class="hljs-keyword">if</span> (!FMath::<span class="hljs-built_in">IsNearlyZero</span>(AnimLength))<br>&#123;<br>   <span class="hljs-comment">// Calculate the speed as: (distance traveled by the animation) / (length of the animation)</span><br>   <span class="hljs-type">const</span> FVector RootMotionTranslation = AnimSequence-&gt;<span class="hljs-built_in">ExtractRootMotionFromRange</span>(<span class="hljs-number">0.0f</span>, AnimLength).<span class="hljs-built_in">GetTranslation</span>();<br>   <span class="hljs-type">const</span> <span class="hljs-type">float</span> RootMotionDistance = RootMotionTranslation.<span class="hljs-built_in">Size2D</span>();<br>   <span class="hljs-keyword">if</span> (!FMath::<span class="hljs-built_in">IsNearlyZero</span>(RootMotionDistance))<br>   &#123;<br>      <span class="hljs-comment">// 计算出动画移动速度</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">float</span> AnimationSpeed = RootMotionDistance / AnimLength;<br>      <span class="hljs-comment">// 根据真实移动速度和动画根移动速度的比值计算应该播放的速率</span><br>      <span class="hljs-type">float</span> DesiredPlayRate = SpeedToMatch / AnimationSpeed;<br>      <span class="hljs-keyword">if</span> (PlayRateClamp.X &gt;= <span class="hljs-number">0.0f</span> &amp;&amp; PlayRateClamp.X &lt; PlayRateClamp.Y) <span class="hljs-comment">// clamp</span><br>      &#123;<br>         DesiredPlayRate = FMath::<span class="hljs-built_in">Clamp</span>(DesiredPlayRate, PlayRateClamp.X, PlayRateClamp.Y);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!InSequencePlayer.<span class="hljs-built_in">SetPlayRate</span>(DesiredPlayRate)) <span class="hljs-comment">// 设置播放速率</span><br>      &#123;<br>         <span class="hljs-comment">//...</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，不要使用CharacterMovementComp中的速度值作为真实移动速度，经测试，在加速和减速过程中速度值和真实移动速度不同：<br><img src="/article_img/2024-01-03-13-02-30.png"><br>因此要重新根据位置计算一个位移速度。</p><h1 id="跨步扭曲（Stride-Warping）"><a href="#跨步扭曲（Stride-Warping）" class="headerlink" title="跨步扭曲（Stride Warping）"></a>跨步扭曲（Stride Warping）</h1><h1 id="朝向扭曲（Orientation-Warping）"><a href="#朝向扭曲（Orientation-Warping）" class="headerlink" title="朝向扭曲（Orientation Warping）"></a>朝向扭曲（Orientation Warping）</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/572811605">UE5 骨骼动画 Lyra 距离匹配 速度匹配</a><br><a href="https://zhuanlan.zhihu.com/p/574219921">Distance Matching in UE5</a><br><a href="https://docs.unrealengine.com/5.0/zh-CN/distance-matching-in-unreal-engine/">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>侯捷C++-STL容器</title>
    <link href="/2023/12/23/%E4%BE%AF%E6%8D%B7C++-STL%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/12/23/%E4%BE%AF%E6%8D%B7C++-STL%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="容器，结构与分类"><a href="#容器，结构与分类" class="headerlink" title="容器，结构与分类"></a>容器，结构与分类</h1><p><img src="/article_img/2023-12-23-09-42-36.png"><br>容器可以分为两种类型，<strong>序列式容器</strong>和<strong>关联式容器</strong>，序列式中存储的就是单一的元素，关联式容器中存储的是一个键值对，并默认会根据个元素的键值大小做排序。<br>这里的符合是指如 <strong>set</strong> 拥有 <strong>rb_tree</strong>，STL的思想是组合优于继承，较少用到继承。容器是一个类，因此容器本身的大小就是容器类的大小，与其中储存的数据无关；</p><p><strong>所有的容器都是前闭后开区间！</strong></p><h1 id="容器的使用场景"><a href="#容器的使用场景" class="headerlink" title="容器的使用场景"></a>容器的使用场景</h1><table><thead><tr><th>容器名称</th><th>概述</th><th>时间复杂度</th><th>优点</th><th>缺点</th><th>总结</th></tr></thead><tbody><tr><td><strong>vector</strong></td><td><strong>动态数组</strong>；在内存中连续存储，内存不够时调用<strong>malloc</strong>在堆分配二倍内存，进行拷贝，并调用<strong>free</strong>释放原内存</td><td><strong>尾插&#x2F;删</strong>：O(1)；<strong>头&#x2F;中间插&#x2F;删</strong>：O(N)；<strong>查找（无序）</strong>：O(N)；<strong>查找（有序二分查找）</strong>：O(logN)</td><td>支持随机访问</td><td>非末尾插入删除效率低</td><td>适合需要经常随机访问，并且不需要堆中间元素插入删除的情况</td></tr><tr><td><strong>list</strong></td><td><strong>双向循环链表</strong>；内存空间不连续</td><td><strong>任何位置插&#x2F;删</strong>：O(1)；<strong>查询</strong>：O(N)</td><td>内存不连续，在任何位置插&#x2F;删效率高</td><td>不能随机访问</td><td>适用于经常插入删除并不需要随机访问的情况</td></tr><tr><td><strong>deque</strong></td><td><strong>双向队列</strong>；内部用vector作为控制中心，用buffer（一段定长的连续内存）存储数据</td><td><strong>头&#x2F;尾插&#x2F;删</strong>：O(1)；<strong>中间插&#x2F;删：O(N)<strong>；</strong>查找</strong>：O(N)；</td><td>支持随机访问（效率比vector差），在首尾操作效率很高</td><td>非首尾操作效率低</td><td>适用于需要随机访问，且需要对首尾频繁操作的情况</td></tr><tr><td><strong>set&#x2F;multiset</strong></td><td>是一种容器适配器，内部由<strong>红黑树rb_tree</strong>（平衡二叉树）实现，内部元素自动排序</td><td><strong>增删改查</strong>：O(logN)</td><td>便于元素查找，支持自动排序</td><td>每次插入元素要调整红黑树，对效率有一定影响</td><td>适用于需要经常查找一个元素是否在某集群中的情况</td></tr><tr><td><strong>map&#x2F;multimap</strong></td><td>是一种容器适配器，内部由<strong>红黑树rb_tree</strong>（平衡二叉树）实现，有键值对，按照key自动排序</td><td><strong>增删改查</strong>：O(logN)</td><td>便于查找，可以创建字典</td><td>每次插入元素要调整红黑树，对效率有一定影响</td><td>适用于需要字典的情况</td></tr><tr><td><strong>unordered_set&#x2F;unordered_map</strong></td><td>是容器适配器,内部由<strong>哈希表hashtable</strong>实现，元素无序</td><td><strong>增删改查（理论上）</strong>：O(1)；<strong>最坏情况</strong>：O(N)</td><td>理论上增删改查极快</td><td>需要较大内存是以空间换时间，插入数据是否均匀影响其性能</td><td>适用于一些特定算法，或者数据很分散的情况</td></tr></tbody></table><h1 id="容器的push-back-和emplace-back-的区别"><a href="#容器的push-back-和emplace-back-的区别" class="headerlink" title="容器的push_back()和emplace_back()的区别"></a>容器的push_back()和emplace_back()的区别</h1><p>emplace&#x2F;emplace_back函数使用传递来的参数<strong>直接</strong>在容器管理的内存空间中<strong>构造元素</strong>（只调用了构造函数）；push_back会创建一个局部<strong>临时对象</strong>，并将其压入容器中（可能调用拷贝构造函数或移动构造函数）</p><h1 id="容器list"><a href="#容器list" class="headerlink" title="容器list"></a>容器list</h1><p>list是STL提供的双向链表；**擅长在任何位置插入或删除元素 O(1)**，不能随机访问；</p><h2 id="list用法："><a href="#list用法：" class="headerlink" title="list用法："></a>list用法：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; L;<br>    L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// 在链表后插入</span><br>    L.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 在链表头插入</span><br>    L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>    L.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">// 链表需要用自带的sort</span><br>    <span class="hljs-comment">/*迭代器用法，使用上和指针相同*/</span><br>    list&lt;<span class="hljs-type">int</span>&gt;::iterator ite;<br>    <span class="hljs-keyword">for</span>(ite = L.<span class="hljs-built_in">begin</span>();ite!=L.<span class="hljs-built_in">end</span>();ite++)&#123;<br>        cout&lt;&lt; *ite &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">/*C++11新用法，很方便*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : L)&#123;<br>        cout&lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="list底层（G2-9）"><a href="#list底层（G2-9）" class="headerlink" title="list底层（G2.9）"></a>list底层（G2.9）</h2><p>侯捷老师使用G2.9编译器的list底层实现作为范例讲解list实现原理，G2.9虽然很古老，但是胜在实现简单，逻辑清晰，很有利于理解实现思路。</p><p><img src="/article_img/2023-12-23-09-46-06.png"></p><p><strong>list</strong> 在底层是一个 <strong>环状双向链表</strong>，并有一个空白节点，用来满足STL规定的容器应该是 <strong>前闭后开</strong> 区间；STL中的数据结构为了搭配迭代器都比我们自己随便写的链表要复杂一些，链表节点（我们的写法，有数据，有两个指针实现双向链表）在 <strong>__list_node</strong> 中，**__list_node** 与 <strong>list</strong> 类是组合关系，同时还在 <strong>list</strong> 类中定义了迭代器（也是组合关系）；</p><h2 id="list的iterator"><a href="#list的iterator" class="headerlink" title="list的iterator"></a>list的iterator</h2><p>值得关注的是迭代器，list的迭代器是一个<strong>希望看上去像一个指针</strong>的类，需要完成 ++ – 等之指针能完成的操作，所以在迭代器的定义中，有很多操作符重载：<br><img src="/article_img/2023-12-23-11-15-14.png"><br>在G4.9，对迭代器的写法进行了一些优化，传递的参数只是模板 _Tp；也对链表节点做了优化，直接将指针类型设为本身（我们平时也这么实现），同时用了继承把数据和指针分开；<br><img src="/article_img/2023-12-23-11-18-43.png"></p><h2 id="forward-list（单向链表）"><a href="#forward-list（单向链表）" class="headerlink" title="forward_list（单向链表）"></a>forward_list（单向链表）</h2><p><img src="/article_img/2023-12-24-13-21-11.png"></p><h1 id="容器vector"><a href="#容器vector" class="headerlink" title="容器vector"></a>容器vector</h1><p>vector在使用上就是一个可变长的数组，**擅长从尾部添加和删除元素 O(1)**，</p><h2 id="vector用法"><a href="#vector用法" class="headerlink" title="vector用法"></a>vector用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;-------------------&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator ite;<br><span class="hljs-keyword">for</span> (ite = v.<span class="hljs-built_in">begin</span>(); ite != v.<span class="hljs-built_in">end</span>(); ite++) &#123;<br>cout &lt;&lt; *ite &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;-------------------&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : v) &#123;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vector的iterator"><a href="#vector的iterator" class="headerlink" title="vector的iterator"></a>vector的iterator</h2><table><thead><tr><th><img src="/article_img/2023-12-23-18-55-29.png"></th><th><img src="/article_img/2023-12-23-18-54-08.png"></th></tr></thead></table><p>vector的iterator就是一个 <strong>T</strong>* 指向T的指针，这是因为对于vector这种在连续内存空间存储的使用指针就完全足够了；</p><h2 id="vector实现"><a href="#vector实现" class="headerlink" title="vector实现"></a>vector实现</h2><p><img src="/article_img/2023-12-23-17-17-00.png"></p><p>vector本身的大小就是三个iterator，也就是三个指针，分别是<strong>start（记录开头位置），finish（记录末尾位置），end_of_storage（记录当前空间的大小也叫容量）</strong>；</p><p>vector的实现简单来说就是 <strong>申请二倍空间，之后把当前vector的元素挨个拷贝过去，再插入新元素，并删除原本的元素</strong>；因此，一旦vector的空间增长，就会涉及大量的<strong>拷贝构造函数</strong>和<strong>析构函数</strong>，这是使用vector时要考虑到的开销；</p><h1 id="容器array"><a href="#容器array" class="headerlink" title="容器array"></a>容器array</h1><h2 id="array的用法"><a href="#array的用法" class="headerlink" title="array的用法"></a>array的用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; myArray;<br><span class="hljs-keyword">auto</span> ite = myArray.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// array&lt;int, 10&gt;::iterator ite = myArray.begin();</span><br><span class="hljs-keyword">for</span> (ite; ite != myArray.<span class="hljs-built_in">end</span>(); ite++) &#123;<br>cout &lt;&lt; *ite;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="array的iterator"><a href="#array的iterator" class="headerlink" title="array的iterator"></a>array的iterator</h2><p>array的迭代器也是一个<strong>指针</strong>；</p><h2 id="array的实现"><a href="#array的实现" class="headerlink" title="array的实现"></a>array的实现</h2><p>array就是要模拟语言中基础的<strong>数组</strong>，所以其实现就是一个数组，专门为语言中自带的数组写一个容器是<strong>为了与算法配合</strong>；</p><h1 id="容器deque"><a href="#容器deque" class="headerlink" title="容器deque"></a>容器deque</h1><p>deque 是 double-ended queue 的缩写，又称双端队列容器。**擅长从首尾添加和删除元素 O(1)**，不擅长从队列中添加和删除；</p><h2 id="deque的用法"><a href="#deque的用法" class="headerlink" title="deque的用法"></a>deque的用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; d1; <span class="hljs-comment">// 初始化空deque</span><br>    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 初始化一个空间为10的deque，元素默认为0</span><br>    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 空间为10，元素为5</span><br>    d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// &#123;1&#125;</span><br>    d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// &#123;2, 1&#125;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = d1.<span class="hljs-built_in">begin</span>(); i!=d1.<span class="hljs-built_in">end</span>();i++)&#123;<br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="deque的iterator"><a href="#deque的iterator" class="headerlink" title="deque的iterator"></a>deque的iterator</h2><p><img src="/article_img/2023-12-24-14-02-17.png"><br>deque的iterator比较复杂，是一个类，其中有四个指针，分别表示<strong>当前位置</strong>，<strong>当前位置所在buffer的首尾位置</strong>，<strong>在map中的位置</strong>；</p><h2 id="deque的实现"><a href="#deque的实现" class="headerlink" title="deque的实现"></a>deque的实现</h2><p><img src="/article_img/2023-12-24-13-54-31.png"><br>deque的实现如上图所示，deque对外声称自己是连续存储的，但其实是由多段 <strong>连续内存（buffer）</strong> 拼起来的，<strong>map</strong> 作为索引（控制中心），用指针负责将多段<strong>buffer</strong>拼起来，<strong>map</strong>本身是一个 <strong>vector</strong>；当向前或者向后插入元素且内存不够时，会申请一个 <strong>buffer</strong>，并用将buffer的头指针插入 <strong>map</strong> 的前端或尾端；<br><img src="/article_img/2023-12-24-14-48-21.png"><br>上面提到，<strong>map</strong> 是用 <strong>vector</strong> 实现的，且map需要在头部插入数据，vector本身不擅长头插，因此在vector扩充内存时，<strong>会将现有数据拷贝到新申请的内存的中部</strong>，减少头插出现的概率；</p><p><strong>deque类实现</strong>：<br><img src="/article_img/2023-12-24-14-06-04.png"></p><h3 id="deque如何模拟连续空间"><a href="#deque如何模拟连续空间" class="headerlink" title="deque如何模拟连续空间"></a>deque如何模拟连续空间</h3><p>deque利用其iterator类中的各种操作符重载模拟连续空间；<br><img src="/article_img/2023-12-24-14-23-48.png"><br><img src="/article_img/2023-12-24-14-14-10.png"><br><img src="/article_img/2023-12-24-14-24-46.png"><br><img src="/article_img/2023-12-24-14-24-58.png"></p><h2 id="queue队列"><a href="#queue队列" class="headerlink" title="queue队列"></a>queue队列</h2><p><strong>queue的实现完全基于deque</strong>，queue类中有一个成员变量是deque，所有的函数都交给这个deque成员变量操作；因此有些人也把queue不叫做一个容器而叫做<strong>适配器（adapter）</strong><br><img src="/article_img/2023-12-24-14-52-58.png"></p><h2 id="stack栈"><a href="#stack栈" class="headerlink" title="stack栈"></a>stack栈</h2><p><strong>stack的实现也是完全基于deque</strong>：<br><img src="/article_img/2023-12-24-14-55-50.png"></p><p><strong>stack和queue都不允许遍历，也不提供iterator！</strong> 因为栈和队列都不能被直接访问元素，应该按照对应的先进后出和先进先出访问元素。</p><h1 id="容器rb-tree"><a href="#容器rb-tree" class="headerlink" title="容器rb_tree"></a>容器rb_tree</h1><p>接下来要介绍的就是<strong>关联式容器</strong>，在STL中有<strong>map，multimap，set，multiset，unordered_map，unordered_set，unordered_multimap，unordered_multiset；</strong> 其中前面几种不带unordered的前缀的底层实现都是<strong>容器rb_tree</strong>，所以它们都可以称为<strong>容器适配器</strong>。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种二叉搜索树，但是多了一个颜色的属性，性质如下：</p><ol><li>每个节点非黑及红</li><li>根节点是黑色的</li><li>如果一个节点是红色，那么其子节点就是黑色</li><li>任一结点到树尾端的路径上含有的黑色节点个数必须相同</li></ol><p>这些性质保证了红黑树没有一条路径会比其他路径多出两倍以上，因此红黑树是一种 <strong>弱平衡二叉树</strong>，相对于严格要求平衡的平衡二叉树来说，旋转次数少，所以对于插入、删除操作较多的情况下，通常使用红黑树。</p><h3 id="红黑树和平衡二叉树（AVL）的区别"><a href="#红黑树和平衡二叉树（AVL）的区别" class="headerlink" title="红黑树和平衡二叉树（AVL）的区别"></a>红黑树和平衡二叉树（AVL）的区别</h3><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance（旋转操作），导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p><h2 id="rb-tree"><a href="#rb-tree" class="headerlink" title="rb_tree"></a>rb_tree</h2><p><img src="/article_img/2023-12-25-10-01-22.png"></p><p>红黑树是一种<strong>平衡二叉树</strong>，它可以自动排序，这里红黑树的原理（如何排序，涉及各种旋转操作）就先不赘述了，rb_tree提供了迭代器，但是我们不应该用迭代器改变元素值，rb_tree提供了迭代器是为了作为set和map的底部支持。<br>rb_tree可以直接使用，但是其实没必要，我们直接使用set和map即可，下面是使用的用例：<br><img src="/article_img/2023-12-25-10-05-39.png"></p><h2 id="set、multiset"><a href="#set、multiset" class="headerlink" title="set、multiset"></a>set、multiset</h2><p>set和multiset的 <strong>键（key）</strong> 和 <strong>数据（data）</strong> 合二为一，set不允许key重复，也就是set的元素不能重复（使用tb_tree的 **insert_unique()**），multiset允许元素重复（使用tb_tree的 **insert_equal()**）；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,                        <span class="hljs-comment">// 键 key 和值 value 的类型</span><br>            <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = less&lt;T&gt;,        <span class="hljs-comment">// 指定 set 容器内部的排序规则</span><br>            <span class="hljs-keyword">class</span> Alloc = allocator&lt;T&gt;      <span class="hljs-comment">// 指定分配器对象的类型</span><br>            &gt; <span class="hljs-keyword">class</span> set;<br></code></pre></td></tr></table></figure><h3 id="set、multiset的实现"><a href="#set、multiset的实现" class="headerlink" title="set、multiset的实现"></a>set、multiset的实现</h3><p><img src="/article_img/2023-12-25-10-12-17.png"><br>set的底层实现完全使用红黑树，但是由于set的键值合二为一，因此set的迭代器不能更改值，这里set类使用<strong>const迭代器</strong>确保迭代器指向的键值对不会被改变。</p><h2 id="map，multimap"><a href="#map，multimap" class="headerlink" title="map，multimap"></a>map，multimap</h2><p>map和multimap就是很明显的关联式容器了，其 <strong>键（key）</strong> 和 <strong>数据（data）</strong> 分离，与set、multiset类似，multimap允许 <strong>键（key）</strong> 重复。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>,                                     <span class="hljs-comment">// 指定键（key）的类型</span><br>           <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,                                       <span class="hljs-comment">// 指定值（value）的类型</span><br>           <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = less&lt;Key&gt;,                     <span class="hljs-comment">// 指定排序规则</span><br>           <span class="hljs-keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="hljs-type">const</span> Key,T&gt; &gt;    <span class="hljs-comment">// 指定分配器对象的类型</span><br>           &gt; <span class="hljs-keyword">class</span> map;<br></code></pre></td></tr></table></figure><h3 id="map，multimap的实现"><a href="#map，multimap的实现" class="headerlink" title="map，multimap的实现"></a>map，multimap的实现</h3><p><img src="/article_img/2023-12-25-10-18-41.png"></p><p>map的 <strong>键（key）</strong> 和 <strong>数据（data）</strong> 分离，所以我们当然应该可以更改每个元素的<strong>数据</strong>，因此map的迭代器就不能简单的设置为const iterator了，STL 提供了 <strong>pair 类模板</strong>，其专门用来将 2 个普通元素 <strong>first</strong> 和 <strong>second</strong>（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素 **&lt;first, second&gt;**。用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    pair&lt;string, <span class="hljs-type">double</span>&gt; pair1;<br>    <span class="hljs-function">pair&lt;string, string&gt; <span class="hljs-title">pair2</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)</span></span>;<br>    cout&lt;&lt; pair1.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>map的 <strong>operator[]</strong> 有独特的设计：<br><img src="/article_img/2023-12-25-10-31-24.png"></p><h1 id="容器hashtable"><a href="#容器hashtable" class="headerlink" title="容器hashtable"></a>容器hashtable</h1><p><img src="/article_img/2023-12-25-14-58-29.png"></p><p>hash表的思路是：先申请一个bucket，为每个元素计算一个编号，根据这个编号和bucket大小的余数将元素放入表中，如果发生碰撞就用链表将碰撞的元素串起来；但是当碰撞太多时，链表过长，查找效率会严重降低，因此当链表过长时（经验上是<strong>元素</strong>个数多于bucket时），<strong>将bucket扩为原来的二倍</strong>并调整为<strong>质数</strong>（可见bucket用vector实现很好），重新计算每个元素应该放在哪里，这个过程也叫<strong>rehashing</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> _stl_num_primes=<span class="hljs-number">28</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _stl_prime_list[_stl_num_primes]=&#123; <span class="hljs-comment">// STL将扩容的大小硬编码</span><br>    <span class="hljs-number">53</span>,<span class="hljs-number">97</span>,<span class="hljs-number">193</span>,<span class="hljs-number">389</span>,<span class="hljs-number">769</span>,<span class="hljs-number">1543</span>,<span class="hljs-number">3079</span>,<span class="hljs-number">6151</span>,<span class="hljs-number">12289</span>,<span class="hljs-number">24593</span>,<span class="hljs-number">1572869</span>,<span class="hljs-number">3145739</span>,<span class="hljs-number">6291469.</span>..<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>由上图可以看出，hashtable这种数据结构是一个指向元素的vector，总占用内存大小为：vector.size()*(4+sizeof(element))</strong></p><h2 id="hashtable的iterator"><a href="#hashtable的iterator" class="headerlink" title="hashtable的iterator"></a>hashtable的iterator</h2><p><img src="/article_img/2023-12-25-15-11-25.png"></p><p>hashtable的迭代器要记录当前指向的链表节点（hashtable_node），也要能在走到一个链表尽头的时候返回bucket走到下一个链表，因此还需要一个指针指向bucket（hashtable* ht）；</p><p>hashtable要用的时候不光要给出<strong>元素的类型（class Value）</strong>，<strong>键的类型（class Key）</strong>，<strong>怎样取出键的函数（class ExtractKey）</strong>，<strong>怎样判断键相等（class EqualKey）</strong> 这些在rb_tree中要给出的模板参数，还要给出一个 <strong>hashFuc</strong> 用来计算 <strong>hash_code</strong> 从而将元素填入哈希表。这个hashFunc在我们使用的时候也要手动给出，不过好在STL已经提供了一些常见类型的hashFunc，我们定义自己的类的hashFunc时可以使用这些hashFunc的和：<br><img src="/article_img/2023-12-25-15-52-45.png"></p><h2 id="unordered-set、unordered-multiset"><a href="#unordered-set、unordered-multiset" class="headerlink" title="unordered_set、unordered_multiset"></a>unordered_set、unordered_multiset</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>,            <span class="hljs-comment">//容器中存储元素的类型</span><br>            <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> = hash&lt;Key&gt;,    <span class="hljs-comment">//确定元素存储位置所用的哈希函数</span><br>            <span class="hljs-keyword">class</span> Pred = equal_to&lt;Key&gt;,   <span class="hljs-comment">//判断各个元素是否相等所用的函数</span><br>            <span class="hljs-keyword">class</span> Alloc = allocator&lt;Key&gt;   <span class="hljs-comment">//指定分配器对象的类型</span><br>            &gt; <span class="hljs-keyword">class</span> unordered_set;<br></code></pre></td></tr></table></figure><p>unordered_set、unordered_multiset这两种容器与set、multiset的区别就在于<strong>无序</strong>，set、multiset底层是红黑树实现，中序遍历可以输出有序元素；</p><h2 id="unordered-map、unordered-multimap"><a href="#unordered-map、unordered-multimap" class="headerlink" title="unordered_map、unordered_multimap"></a>unordered_map、unordered_multimap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>,                        <span class="hljs-comment">//键值对中键的类型</span><br>            <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,                          <span class="hljs-comment">//键值对中值的类型</span><br>            <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> = hash&lt;Key&gt;,           <span class="hljs-comment">//容器内部存储键值对所用的哈希函数</span><br>            <span class="hljs-keyword">class</span> Pred = equal_to&lt;Key&gt;,       <span class="hljs-comment">//判断各个键值对键相同的规则</span><br>            <span class="hljs-keyword">class</span> Alloc = allocator&lt; pair&lt;<span class="hljs-type">const</span> Key,T&gt; &gt;  <span class="hljs-comment">// 指定分配器对象的类型</span><br>            &gt; <span class="hljs-keyword">class</span> unordered_map;<br></code></pre></td></tr></table></figure><p>unordered_map、unordered_multimap这两种容器与map、multimap的区别就在于<strong>无序</strong>，map、multimap底层是红黑树实现，中序遍历可以输出有序元素；</p>]]></content>
    
    
    <categories>
      
      <category>-[C++]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>侯捷C++-STL</title>
    <link href="/2023/12/21/%E4%BE%AF%E6%8D%B7C++-STL/"/>
    <url>/2023/12/21/%E4%BE%AF%E6%8D%B7C++-STL/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>STL</strong>全称 <strong>Standard Template Library（标准模板库）</strong>，<strong>C++ Standard Library标准库</strong>中有百分之八十都是STL；</p><p>参考网站：<br><a href="http://gcc.gnu.org/">gcc.gnu.org</a><br><a href="https://cplusplus.com/">cplusplus</a><br><a href="https://en.cppreference.com/w/">cppreference</a></p><h1 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h1><table><thead><tr><th><img src="/article_img/2023-12-21-10-52-12.png"></th><th><img src="/article_img/2023-12-21-10-58-12.png"></th></tr></thead></table><p><strong>1. 容器（Containers）<br>2. 分配器（Allocators）<br>3. 算法（Algorithms）<br>4. 迭代器（Iterators）<br>5. 适配器（Adapters）<br>6. 仿函数（Functors）</strong></p><p>STL设计的思想不是OOP（Object-Oriented Progragmming）而是<strong>GP（Generic Programming）泛化编程</strong>，这种思想将<strong>数据和方法分开</strong>，在STL里的明显应用就是把数据放在<strong>容器</strong>中，让<strong>算法</strong>通过<strong>迭代器</strong>实现对数据的操作。这种方法可以方便设计容器的团队和设计算法的团队可以独立开发，只要双方迭代器互通即可。</p><h1 id="STL基础——操作符重载和模板"><a href="#STL基础——操作符重载和模板" class="headerlink" title="STL基础——操作符重载和模板"></a>STL基础——操作符重载和模板</h1><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p><img src="/article_img/2023-12-22-14-51-48.png"></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">A</span>(T r=<span class="hljs-number">0</span>, T i=<span class="hljs-number">0</span>):<span class="hljs-built_in">re</span>(r),<span class="hljs-built_in">im</span>(i)&#123;&#125;<br>   <span class="hljs-function">T <span class="hljs-title">GetRe</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> re;&#125;<br><span class="hljs-keyword">private</span>:<br>   T re, im;<br>&#125;;<br>&#123;<br>   <span class="hljs-function">A&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>   <span class="hljs-function">A&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1.3</span>, <span class="hljs-number">2.2</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span>&#123;<br>   <span class="hljs-keyword">return</span> b &lt; a ? b : a;  <span class="hljs-comment">// 经过编译器参数推导，这里会用对应类的&lt;重载</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h3><p><img src="/article_img/2023-12-22-15-26-11.png"><br>最基础的模板函数可以理解为是一种 <strong>泛化</strong>，不管参数是什么类型都一样操作，C++也提供了 <strong>特化</strong> 来进一步提高效率，特化就是当参数是某种类型时，专为这种类型设计对应的函数。</p><h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p><img src="/article_img/2023-12-22-15-34-14.png"><br><strong>偏特化（Partial Specialization）</strong> 如上图所示，当<strong>一部分</strong>参数是某种类型时，为其设计对应的函数，可以理解为 <strong>个数</strong> 上的偏特化；<br><img src="/article_img/2023-12-22-15-37-43.png"><br>另外，还有一种偏特化是 <strong>范围</strong> 上的偏特化，如上图所示。</p><h1 id="分配器-allocators"><a href="#分配器-allocators" class="headerlink" title="分配器 allocators"></a>分配器 allocators</h1><p>每个容器都有一个分配器作为参数，分配器负责真正去<strong>申请开辟内存</strong>；一般我们不需要直接用allocator，让容器去用即可。</p><p><img src="/article_img/2023-12-22-15-52-49.png"></p><p>可以看出在VC6中，allocator就是调用了 <strong>operator new</strong> 和 <strong>operator delete</strong> 去申请和释放内存。而我们又知道，operator new 和 operator delete 底层分别由 <strong>malloc</strong> 和 <strong>free</strong> 实现，malloc真正分配的内存会多出一些（cookie确定内存大小，debug相关内存，变量内存，padding内存）<br><img src="/article_img/2023-12-22-15-53-38.png"></p><p><strong>malloc</strong> 在分配内存的时候不可避免的要多分配一些内存，尤其是<strong>cookie</strong>是不能省略的（<strong>debug</strong>在release模式下就没了，<strong>padding</strong>也有可能恰好没有），因为在拿一块内存的时候系统需要知道拿了多大才能在回收的时候正确回收，<strong>cookie</strong> 就是为了记录申请的内存大小的；<br>那么就有一个问题，如果我们真正想申请的内存很小，比如就1个字节，但是为了申请这一点内存，需要额外的申请cookie的8个字节，这岂不是很<strong>浪费</strong>！那么为了避免这个问题，一些编译器（<strong>G2.9</strong>）的allocator会做一些特殊的操作避免这种浪费，下面会介绍一种操作：**__pool_alloc**；</p><h2 id="pool-alloc"><a href="#pool-alloc" class="headerlink" title="__pool_alloc"></a>__pool_alloc</h2><p>想要不分配cookie，那先要想cookie的作用，上面已经说了很多次了，cookie就是为了记录申请的内存的大小，当我们没有用容器的时候，cookie就没办法省掉，因为我们申请的内存确实是有大有小的，但是当我们使用容器时，<strong>容器内部每个变量的内存一定是一样的！</strong> 那么我们就可以不记录容器中每个变量所占的内存大小了，这就是 <strong>__pool_alloc</strong> 实现的基础。<br><img src="/article_img/2023-12-22-16-33-47.png"><br><strong>__pool_alloc</strong> 设计了如图所示的16个链表，**#0<strong>指向的链表每块内存大小为</strong>8字节<strong>，</strong>#1<strong>指向的链表每块内存大小为</strong>16字节<strong>，</strong>#2<strong>指向的链表每块内存大小为</strong>24字节<strong>，以此类推。在使用时，根据容器中元素的内存大小，分配能满足其的最小的内存块，比如容器中元素内存为20，那就选择 <strong>#2</strong> 指向的链表，并将元素内存</strong>填充到24<strong>，</strong>一次性<strong>向系统申请一大片内存（只用额外分配两个cookie），其中每块都是24，将容器中的元素</strong>依次放进每个块中<strong>，当链表中的内存不够时，再去申请一大片内存。这样就能节省大量的内存空间，因为</strong>只用在每次申请大片内存时额外分配cookie<strong>。<br>同时，_pool_alloc不仅在内存占用上有优势，在效率上也有优势，</strong>每次调用malloc申请内存时，需要从用户态转到内核态<strong>，这会浪费很多时间，</strong>因此_pool_alloc减少内存分配次数也可以减少操作系统的状态切换。**</p><p>这么好的allocator算法，在G4.9又不是默认的了，也不知道为什么，但是该名为 <strong>__pool_alloc</strong> 可以<strong>手动指定</strong>使用。<br><img src="/article_img/2023-12-22-16-52-50.png"></p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>内容较多，见另一篇笔记；</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是算法与容器间的桥梁；STL使用泛型编程把方法与数据分开，那么就需要一个东西把二者联系起来，迭代器充当这个角色，迭代器在使用上和指针类似，有些迭代器（vector）就是一个指针；<br><img src="/article_img/2023-12-23-16-41-38.png"></p><p>迭代器要能从容器中<strong>取出元素</strong>交给算法去操作，迭代器也要能 “回答算法的提问”，算法可能会根据容器内元素类型的不同进行不同的操作，所以迭代器还要能<strong>告知算法一些元素的特性</strong>；<br><img src="/article_img/2023-12-23-16-50-03.png"><br>一种实现思路如图，<strong>规定</strong>迭代器要指明五种特性都是什么（用typedef实现），迭代器里用typedef指明了这些属性之后，算法<strong>直接取得</strong>即可。<br>但是有一种情况会出问题，算法不是专为容器设计的，也就是说非迭代器也应该能用（况且迭代器本身的设计理念就是当作一个指针），普通的指针比如（int*）也应该能使用算法，因此STL设计了 <strong>iterator_traits</strong>;</p><h2 id="iterator-traits"><a href="#iterator-traits" class="headerlink" title="iterator_traits"></a>iterator_traits</h2><p>traits的中文是属性、特性，在这里可以把他理解成一个<strong>萃取器</strong>，我们要求通过这个 <strong>萃取器</strong> 得到我们想要的属性；<br><img src="/article_img/2023-12-23-16-56-09.png"><br><img src="/article_img/2023-12-23-18-47-40.png">s<br>iterator_traits的实现使用了 <strong>范围偏特化</strong>，有一个基础的泛化操作，就是从类（迭代器类）中取特性，之后定义了两个偏特化模板，当<strong>T是指针</strong>时以及<strong>T是常量指针</strong>时，直接返回指针的类型；<br>完整的iterator_traits如下，STL规定迭代器要 “回答” 算法的五个问题：</p><ol><li>容器中元素类型 <strong>value_type</strong></li><li>容器中元素指针类型 pointer</li><li>容器中元素引用类型 reference</li><li>迭代器类型 <strong>iterator_category</strong></li><li>两个迭代器之间的最大距离 <strong>difference_type</strong><br><img src="/article_img/2023-12-23-17-01-53.png"></li></ol><h2 id="iterator-category"><a href="#iterator-category" class="headerlink" title="iterator_category"></a>iterator_category</h2><p>在上面介绍iterator_traits时我们看到<strong>iterator_traits</strong>要回答当前<strong>迭代器类型iterator_category</strong>，迭代器类型有以下五种：<br><img src="/article_img/2024-01-14-13-32-00.png"><br>针对不同的容器其迭代器类型也不同，<strong>反应该容器的迭代器访问性质</strong>:</p><ol><li>数组Array：random_access_iterator_tag 随机访问</li><li>Vector：random_access_iterator_tag</li><li>Deque：random_access_iterator_tag</li><li>List：bidirectional_iterator_tag 双向前进（不能随机访问）</li><li>Forward-List：forward_iterator_tag 单向前进</li><li>Set&#x2F;MultiSet：bidirectional_iterator_tag</li><li>Map&#x2F;MultiMap：bidirectional_iterator_tag</li><li>Unordered Set&#x2F;MultiSet：forward_iterator_tag</li><li>Unordered Map&#x2F;MultiMap：forward_iterator_tag</li></ol><p>iterator_tag有什么用呢，如有算法希望知道两个迭代器之间的距离，这就需要知道迭代器的类型，如果迭代器类型是<strong>random_access_iterator_tag</strong> 支持随机访问，也就是连续存储，就可以直接相减，若不是则就只能步进并计数。同理，如有算法希望前进迭代器也需要根据不同的迭代器类型选择适合的前进策略：</p><table><thead><tr><th><img src="/article_img/2024-01-14-13-43-02.png"></th><th><img src="/article_img/2024-01-14-13-54-29.png"></th></tr></thead></table><p>思考：为什么迭代器类型本身不使用枚举来实现，反而用类通过继承来实现？</p><p>其实看上面两个算法的代码我们就可以看出，使用类实现不需要为每个类型都写一个函数实现，而可以使用基类参数；</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><img src="/article_img/2024-01-14-13-22-40.png"></p><p><strong>算法是一个函数模板</strong>；算法是用来操作数据的，但是算法对存放数据的容器的实现一无所知（也完全不需要了解），只能通过<strong>iterator迭代器</strong>得到想要的数据，上面在迭代器章节我们了解到，迭代器通过<strong>iterator_traits</strong>为算法提供信息，如<strong>iterator_category</strong>，<strong>difference_type</strong>等信息，来方便算法根据不同的数据类型选择不同的算法，以提高效率。</p><p>算法的形态大致如下，都是模板函数，并且都有两个迭代器参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;</span><br><span class="hljs-function"><span class="hljs-title">std::Algorithm</span><span class="hljs-params">(Iterator itr1, Iterator itr2, ...)</span></span>&#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL的排序算法"><a href="#STL的排序算法" class="headerlink" title="STL的排序算法"></a>STL的排序算法</h2><p>快速排序、插入排序和堆排序；当数据量很大的时候用快排，划分区段比较小的时候用插入排序，当划分有导致最坏情况的倾向的时候使用堆排序。</p><h3 id="各种排序算法的原理和时间复杂度"><a href="#各种排序算法的原理和时间复杂度" class="headerlink" title="各种排序算法的原理和时间复杂度"></a>各种排序算法的原理和时间复杂度</h3><p>判断一个排序算法是否稳定就是看 <strong>相同的数位置会不会变化</strong>；</p><p><img src="/article_img/2024-03-02-15-03-48.png"></p><p>快排代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>   <span class="hljs-keyword">if</span>(start&lt;end)&#123;<br>      <span class="hljs-type">int</span> base = nums[start]; <span class="hljs-comment">// 确定基准</span><br>      <span class="hljs-type">int</span> left = start;<br>      <span class="hljs-type">int</span> right = end;<br>      <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>         <span class="hljs-comment">// 先从后往前找第一个比基准小的值</span><br>         <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;base)&#123;<br>            right--;<br>         &#125;<br>         <span class="hljs-comment">// 找到，将其赋值给左指针</span><br>         nums[left]=nums[right];<br>         <span class="hljs-comment">// 从前往后找第一个比基准大的值</span><br>         <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;base)&#123;<br>            left++;<br>         &#125;<br>         <span class="hljs-comment">// 找到，将其赋值给右指针，不用担心右指针的值会丢，已经给了左指针了，而之前的左指针就是base</span><br>         nums[right]=nums[left];<br>      &#125;<br>      <span class="hljs-comment">// 左右指针相遇，将base赋值给当前位置</span><br>      nums[left]=base;<br>      <span class="hljs-built_in">quickSort</span>(nums, start, left<span class="hljs-number">-1</span>);<br>      <span class="hljs-built_in">quickSort</span>(nums, left+<span class="hljs-number">1</span>, end);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最坏情况就是没有划分，时间复杂度为O(n^2)；</p>]]></content>
    
    
    <categories>
      
      <category>-[C++]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lyra动画系统-框架</title>
    <link href="/2023/12/20/Lyra%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E5%A4%8D%E7%8E%B0-%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/12/20/Lyra%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E5%A4%8D%E7%8E%B0-%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Lyra动画系统框架"><a href="#Lyra动画系统框架" class="headerlink" title="Lyra动画系统框架"></a>Lyra动画系统框架</h1><p><img src="/article_img/2023-12-20-16-32-23.png"></p><p>Lyra的动画系统框架很值得学习，他的核心思想就是解耦，不断地解耦。</p><p><strong>主动画蓝图（ABP_Mannequin_Base）</strong> 用来实现最基础的状态机，其中每个状态都 <strong>没有具体实现</strong>，而是直接交给一个动画图层实现，这些动画层又被全部抽象出来，放在一个 <strong>动画层接口（ALI_ItemAnimLayers）</strong> 中，主动画蓝图继承这个动画层接口，但是也不实现这些动画层，把实现的工作交给另一个动画蓝图；<strong>把基础状态机和每个具体状态的实现解耦</strong>；</p><table><thead><tr><th><img src="/article_img/2023-12-21-15-09-40.png"></th><th><img src="/article_img/2023-12-21-15-10-02.png"></th></tr></thead></table><p><strong>状态实现蓝图（ABP_ItemAnimLayersBase）</strong> 也继承自动画层接口，用来实现每个动画层，但是实现时也不会直接把动画序列放进去，而是用序列播放器搭配动画序列变量，完成实现逻辑；<strong>把播放的动画序列和状态的实现解耦</strong>；<br><img src="/article_img/2023-12-21-15-18-53.png"></p><p><strong>资产配置蓝图（ABP_PistolAnimLayers）</strong> 继承自状态实现蓝图，负责把对应的动画序列填入状态实现蓝图的对应变量中：<br><img src="/article_img/2023-12-21-15-22-24.png"></p><p>最后，使用 <strong>关联动画类图层（LinkAnimClassLayer）</strong> 节点，把要要播放的资产配置蓝图和主动画蓝图关联即可；<br><img src="/article_img/2023-12-21-15-28-57.png"></p><p>Lyra这样设计动画系统可以非常方便的完成一个新状态机的制作，比如有使用手枪和使用步枪的两套动画，他们有相同的动画状态机和状态实现，只需要不同的资产配置蓝图用来把两套动画序列配置好即可，在切换武器时变更动画也非常方便。</p><h1 id="动画节点与动画节点函数"><a href="#动画节点与动画节点函数" class="headerlink" title="动画节点与动画节点函数"></a>动画节点与动画节点函数</h1><p>在动画蓝图中，AnimNode是诸多节点的父类，从动画播放器（SequencePlayer）到动画状态机，都是动画节点。</p><h2 id="动画节点函数"><a href="#动画节点函数" class="headerlink" title="动画节点函数"></a>动画节点函数</h2><p>动画节点都可以绑定动画节点函数，按照函数的触发事件分为三种：</p><ol><li><strong>On Initial Update</strong>：在该动画节点所属的AnimBP的生命周期中第一次执行节点时</li><li><strong>On Become Relevant</strong>：节点变为相关时，也就是每次开始执行节点时</li><li><strong>On Update</strong>：节点tick更新时</li></ol><p><strong>执行顺序是先执行上层的节点再执行下层的节点</strong>，如下图，先执行State节点，再执行序列求值器节点：<br><img src="/article_img/2024-01-12-14-35-15.png"></p><h1 id="多线程更新动画（Blueprint-Thread-Safe-Update-Functions）"><a href="#多线程更新动画（Blueprint-Thread-Safe-Update-Functions）" class="headerlink" title="多线程更新动画（Blueprint Thread Safe Update Functions）"></a>多线程更新动画（Blueprint Thread Safe Update Functions）</h1><p>Lyra把原本放在 <strong>事件图标（EventGraph）</strong> 也就是<strong>游戏线程</strong>中执行的逻辑（比如获取角色的速度旋转等信息），放到了 <strong>工作线程</strong> 中执行，可以获得更好的性能。</p><p>但是这样做有个点要注意，由于将数据更新放在工作线程中，许多变量和函数无法直接调用（只有用BlueprintThreadSafe修饰的才可以），因为其他线程可能同时运行并且它们可能正在更改该数据。因此，使用 <strong>属性访问系统（Property Access System）</strong> 来访问数据。属性访问系统会在安全时自动复制数据：<br><img src="/article_img/2023-12-21-15-37-08.png"></p><p>为此，我们需要定义一系列函数来更新变量，这些函数需要勾选 <strong>线程安全</strong> 才能在<strong>BlueprintThreadSafeUpdateAnimation</strong>中被调用：<br><img src="/article_img/2023-12-21-15-40-32.png"></p><h1 id="序列播放器（SequencePlayer）和序列求值器（SequenceEvaluator）"><a href="#序列播放器（SequencePlayer）和序列求值器（SequenceEvaluator）" class="headerlink" title="序列播放器（SequencePlayer）和序列求值器（SequenceEvaluator）"></a>序列播放器（SequencePlayer）和序列求值器（SequenceEvaluator）</h1><p>二者都是用来播放动画序列的动画节点，但序列播放器可以自动播放动画序列，序列求值器需要指出显式时间才能播放对应时间的动画帧；也就是说序列求值器更加灵活，常常将序列求值器播放的<strong>序列</strong>和<strong>显式时间</strong>设为动态值，通过节点函数动态改变动画序列和播放速率：<br><img src="/article_img/2024-01-12-14-50-47.png"></p><h1 id="Animation-Layer-Interface（ALI）"><a href="#Animation-Layer-Interface（ALI）" class="headerlink" title="Animation Layer Interface（ALI）"></a>Animation Layer Interface（ALI）</h1><p>动画层接口是只能用在动画蓝图中的一个接口类，继承自UInterface；和蓝图接口一样，可以在其中创建函数，这些函数被称作AnimationLayers；实现这些函数的方法有：</p><ol><li>继承了ALI的动画蓝图可以在其内部直接实现</li><li>运行时动态指定另一个继承了相同ALI的动画蓝图来实现（使用**关联动画类图层(Link Anim Class Layer)**），Lyra中就是这种方式；</li></ol><h1 id="Animation-Layer"><a href="#Animation-Layer" class="headerlink" title="Animation Layer"></a>Animation Layer</h1><p>动画层也是一种动画蓝图，一种 <strong>子动画蓝图</strong>，本质是一种函数，不过函数处理和输出的都是动画数据；</p><ol><li>AnimLayer：在当前动画蓝图类中直接创建的</li><li>LinkedAnimLayer：继承ALI后获得的</li></ol><p><img src="/article_img/2024-01-12-15-05-01.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/628247619">【UE】Lyra动画系统拆解（框架篇）</a><br><a href="https://zhuanlan.zhihu.com/p/654430436">UE5 白话Lyra动画系统</a></p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>侯捷C++-面向对象编程-OOP</title>
    <link href="/2023/12/18/%E4%BE%AF%E6%8D%B7C++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-OOP/"/>
    <url>/2023/12/18/%E4%BE%AF%E6%8D%B7C++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-OOP/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Composition（组合）"><a href="#Composition（组合）" class="headerlink" title="Composition（组合）"></a>Composition（组合）</h1><p>Composition 表示 <strong>has-a</strong> 的关系，UE中的组件和Actor的关系就是组合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_x;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    A m_A;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-12-19-09-17-03.png"><br><strong>构造由内而外，析构由外而内！</strong> 这个过程完全由编译器实现。</p><h1 id="Delegation（委托）"><a href="#Delegation（委托）" class="headerlink" title="Delegation（委托）"></a>Delegation（委托）</h1><p>委托也叫做 <strong>Composition by reference</strong> （这里叫by ref是因为学术界一般不叫by pointer，实现中用指针也完全可以），他的思想就是用一个指针指向真正的实现类，从而将接口和实现分离（也叫编译防火墙，之后修改实现不用再编译接口类），这种思想又叫做 <strong>pimpl（pointer to implement）</strong> 指针指向实现。</p><p><img src="/article_img/2023-12-19-09-37-45.png"></p><p>委托不光可以描述两个类之间的委托关系，也可以直接委托给某个函数，一般使用函数指针实现，出自<a href="https://zhuanlan.zhihu.com/p/460092901">一文理解透UE委托Delegate</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> DelegateType = <span class="hljs-built_in">void</span> (*)(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y); <span class="hljs-comment">// 给这种函数指针起一个别名DelegateType</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ArtilleryAction</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">// 实现功能的函数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Drop a bomb on the (%d,%d) position\r\n&quot;</span>, x, y);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scout</span>&#123; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Scout</span>(DelegateType Delegate) :<span class="hljs-built_in">ArtilleryDelegate</span>(Delegate)&#123;&#125; <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindInformation</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">// 调用委托</span><br>        (*ArtilleryDelegate)(<span class="hljs-built_in">rand</span>(), <span class="hljs-built_in">rand</span>());<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    DelegateType ArtilleryDelegate; <span class="hljs-comment">// 类中成员变量就是一个指向功能实现的指针</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Scout <span class="hljs-title">OneScout</span><span class="hljs-params">(ArtilleryAction)</span></span>;<br>    OneScout.<span class="hljs-built_in">FindInformation</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Inheritance（继承）"><a href="#Inheritance（继承）" class="headerlink" title="Inheritance（继承）"></a>Inheritance（继承）</h1><p>继承表示 <strong>is-a</strong> 的关系。</p><p><img src="/article_img/2023-12-19-09-56-42.png"><br><strong>构造由内而外，析构由外而内！</strong> 父类的析构函数必须是虚函数。</p><p>继承和组合同时存在时，构造和析构的顺序：<br><img src="/article_img/2023-12-19-10-36-42.png"></p><table><thead><tr><th><img src="/article_img/2023-12-19-10-51-53.png"></th><th><img src="/article_img/2023-12-19-10-52-40.png"></th></tr></thead></table><p>可以看出，第一种情况派生类中有组合时，会先构造基类再构造组合类，最后构造派生类，按相反顺序析构；第二种情况基类中有组合时，会先构造最内层的组合类，再构造基类，最后构造派生类，按相反顺序析构。</p><h2 id="虚函数（多态）"><a href="#虚函数（多态）" class="headerlink" title="虚函数（多态）"></a>虚函数（多态）</h2><ol><li><strong>非虚函数</strong>：不希望派生类重新定义（override）；</li><li><strong>虚函数（Virtual函数</strong>）：希望派生类重新定义，但不定义也没关系，已有默认定义；</li><li><strong>纯虚函数（Pure Virtual函数）</strong>：希望派生类<strong>一定</strong>要重新定义，因为没有默认定义；<br><img src="/article_img/2023-12-19-10-16-18.png"></li></ol><p>虚函数的实现依靠虚函数表，虚函数表不存在类中，类中存的是指向这个<strong>虚函数表的指针</strong>；所以有虚函数的类的内存要加上一个指针的大小；当子类定义一个新的虚函数时，这个虚函数会添加到虚表的末尾。<br><img src="/article_img/2023-12-20-09-42-17.png"><br>子类中有与父类同名的函数，且这个函数不是虚函数，那就不会覆写父类中的同名函数，如图中的子类B、C <strong>都有</strong> 同名函数 <strong>func2</strong>。</p><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p><img src="/article_img/2023-12-20-10-01-50.png"><br>在C语言中，所有的函数调用都是<strong>静态绑定</strong>，即在编译阶段会编译为 <strong>call XXX</strong>，而在C++中会出现<strong>动态绑定</strong>（如图，不能写死为call XXX，而要写成一个指针调用的形式，在执行时会按照走上图流程确定调用哪个函数），需要满足以下条件：</p><ol><li><strong>使用指针调用</strong></li><li><strong>向上转型</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">A* pa = <span class="hljs-keyword">new</span> B; <span class="hljs-comment">// 向上转型，new出来是B，类型却是A的指针</span><br></code></pre></td></tr></table></figure></li><li><strong>调用的是虚函数</strong></li></ol><p>虚函数的经典用法：<br><img src="/article_img/2023-12-19-10-29-03.png"><br>这里的 <strong>Template Method</strong> 不是指C++中的模板，而是一种<strong>设计模式</strong>，先写好通用部分的函数，将不能通用的函数写成虚函数形式，由子类实现其特化的功能；<br>虚函数起作用的流程是：<br>子类对象调用成员函数，成员函数中有一个虚函数<strong>Serialize()<strong>，调用时将</strong>this</strong>指针当作参数传递（所有类函数都有隐藏的参数<strong>this</strong>），在成员函数中完成非虚函数部分，遇到虚函数使用<strong>this</strong>调用虚函数，查询虚函数表确定要调用哪个函数并调用。</p><p><img src="/article_img/2023-12-20-10-29-43.png"><br>上图展示静态绑定，虽然a对象的初值是b，但是没有使用指针调用，不会出现动态绑定，所以是静态绑定。<br><img src="/article_img/2023-12-20-10-32-36.png"><br>上图展示动态绑定，满足<strong>使用指针调用</strong>，<strong>向上转型</strong>，<strong>调用虚函数</strong>三点；</p><h2 id="虚函数与构造析构函数"><a href="#虚函数与构造析构函数" class="headerlink" title="虚函数与构造析构函数"></a>虚函数与构造析构函数</h2><p><strong>1. 构造函数不能是虚函数！<br>2. 析构函数必须是虚函数！</strong></p><p>构造函数不能是虚函数可以从两方面解释：</p><ol><li>设计思想方面：虚函数是接口的思想，我们不想知道其内部是如何实现的，而构造函数要构造出一个对象，就想要知道其内部的实现，因此构造函数<strong>不该</strong>被定义为虚函数；</li><li>语言本身：虚函数在实现时需要用到<strong>vtpr</strong>虚表指针来确定虚函数的定义是哪个，这个虚表指针存在<strong>对象内存空间</strong>中，而构造函数被调用时还没有实例化对象，也就没有虚表指针；</li></ol><p>析构函数（可能会被继承时）必须是虚函数：<br>析构函数会在对象生命周期结束时被自动调用，当用父类指针指向子类对象时，如果析构函数不是虚函数，只能顺利销毁子类对象中的父类部分，如果子类还有别的变量，可能会造成<strong>内存泄漏</strong>；</p>]]></content>
    
    
    <categories>
      
      <category>-[C++]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>侯捷C++-——关键字</title>
    <link href="/2023/12/17/%E4%BE%AF%E6%8D%B7C++-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/12/17/%E4%BE%AF%E6%8D%B7C++-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="inline（内联函数）"><a href="#inline（内联函数）" class="headerlink" title="inline（内联函数）"></a>inline（内联函数）</h1><p>直接定义在类中的函数不用使用 inline关键字也会成为 inline函数，相当于自动添加 inlne关键字，但是是否这个函数真的编程内联函数是完全取决于编译器的。也就是说，我们对一个函数声明他为 inline 只是<strong>建议</strong>编译器将其视作 inline函数，最终还是要由编译器决定（<strong>太复杂的函数编译器没有能力将其变成内联函数</strong>）。</p><h2 id="inline函数的优缺点"><a href="#inline函数的优缺点" class="headerlink" title="inline函数的优缺点"></a>inline函数的优缺点</h2><p>优点：避免函数调用的开销<br>缺点：造成代码膨胀，不方便调试（因为每次修改会重新编译头文件，增加编译时间）</p><h2 id="inline与define的区别"><a href="#inline与define的区别" class="headerlink" title="inline与define的区别"></a>inline与define的区别</h2><ol><li>define宏命令是在预处理阶段对命令进行替换，inline是在编译阶段在函数调用点处直接展开，节省了函数调用开销；</li><li>define不会对参数进行类型检查，inline会进行类型检查</li></ol><h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Cherno把const称为一个假的关键字，因为它并不会对产生的代码造成什么实质上的影响，它只是一种 <strong>承诺</strong> ，承诺这是一个不会被改变的常量，用来方便编程。下面是const的几种用法：</p><h2 id="修饰函数（只能修饰成员函数）"><a href="#修饰函数（只能修饰成员函数）" class="headerlink" title="修饰函数（只能修饰成员函数）"></a>修饰函数（只能修饰成员函数）</h2><p><strong>如果没有修改参数或者不应该修改参数时，总是把这个方法标记为const！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">value</span>(x) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> x;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>; <br>    a.<span class="hljs-built_in">GetValue</span>(); <span class="hljs-comment">// 正确，如果GetValue没有设置为const，编译器会报错，因为GetValue可能会修改常量a</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-12-11-14-37-20.png"><br>如上面的例子，const修饰函数时，可以确保我们不会修改一个常量。当我们忘记写const时，编译会报错，相当于<strong>强迫</strong>我们思考我们的函数中有没有修改常量，如果设置了const还在函数中进行了对非局部变量的修改，也会报错。</p><p><img src="/article_img/2023-12-20-11-06-31.png"><br>如图中右侧的例子，在字符串的实现中，定义了两个操作符重载，一个是const，一个不是，这是因为字符串实现时采用了共享的设计模式（4个字符串对象内容一样会指向同一片内存），共享就导致当要对内容更改时，需要 <strong>COW（Copy On Write）</strong> 先复制再更改，防止影响其他共享对象；那么对于图中的 <strong>[]取</strong> 操作符就有两种情况，一种取出后更改（a[2] &#x3D; ‘a’）要考虑 COW，一种不改只读取不考虑 COW，这两个函数实现会不同，对于<strong>常量字符串</strong>（不能对其进行更改）我们当然希望不要 COW 造成额外的开销，因此就对不考虑 COW 的函数加<strong>const</strong>，让常量字符串<strong>只会</strong>调用该函数。<strong>同时，当const和non-cont同时存在时，非常量对象只能调用non-const版本。</strong><br>也可以看出，const也是函数签名的一部分（返回值不是函数签名的一部分），不会造成同名函数编译不过的情况。 </p><table><thead><tr><th><img src="/article_img/2023-12-20-11-21-44.png"></th><th><img src="/article_img/2023-12-20-11-22-15.png"></th></tr></thead></table><h2 id="const修饰变量"><a href="#const修饰变量" class="headerlink" title="const修饰变量"></a>const修饰变量</h2><ul><li><strong>const变量</strong>，此变量是只读的，不应该被改变；所以被const修饰的变量必须<strong>初始化</strong>，因为如果不初始化又不能被改变该怎么赋值呢；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b; <span class="hljs-comment">// 编译错误</span><br>a = <span class="hljs-number">5</span>; <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure></li><li><strong>const修饰结构体</strong>，则结构体内的成员变量均不能被修改；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>  <span class="hljs-type">int</span> m_a;<br>  <span class="hljs-type">int</span>* m_ptr;<br>&#125;;<br><span class="hljs-type">const</span> A a1; <span class="hljs-comment">// 未初始化</span><br><span class="hljs-type">const</span> A a2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>&#125;;<br><span class="hljs-type">const</span> A a3 = &#123;<span class="hljs-number">3</span>, <span class="hljs-literal">nullptr</span>&#125;;<br>a2 = a3; <span class="hljs-comment">// 编译错误</span><br>a2.m_a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure></li><li><strong>const修饰对象</strong>，对象成员变量不能修改，且该对象<strong>只能调用const成员函数；</strong><br><img src="/article_img/2024-03-05-09-32-17.png"></li><li><strong>const与指针</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* a = &amp;b; <span class="hljs-comment">// const修饰int，a指针指向的内容是常量</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> a = &amp;b; <span class="hljs-comment">// const修饰指针，指针指向的地址是常量（不能指向另一个地址），指向的对象可改变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> a = &amp;b; <span class="hljs-comment">// 指针a指向的地址不可改变，指向的对象本身也不可改变</span><br></code></pre></td></tr></table></figure></li><li><strong>const变量作为函数参数</strong><br>const int* 作为函数参数：<br><img src="/article_img/2024-03-05-09-58-59.png"><br>const int&amp; 作为函数参数：<br><img src="/article_img/2024-03-05-09-59-58.png"><br>const int 作为函数参数就没有任何问题，因为是传值，参数变量本身可以是const或非const：<br><img src="/article_img/2024-03-05-10-02-53.png"></li></ul><h3 id="const的类型转换"><a href="#const的类型转换" class="headerlink" title="const的类型转换"></a>const的类型转换</h3><p><img src="/article_img/2024-03-05-09-49-23.png"><br>如图，指向const变量的指针（const int<em>）<strong>可以</strong>指向<strong>非const变量</strong>，非const变量指针（int</em>）<strong>不能</strong>指向const变量；<br>这是因为 int* 可以隐式转换为 const int*，而反之不可以，<strong>隐式转换不放宽对于变量的要求</strong>，const变量显然比非const变量要求更严格；</p><p><img src="/article_img/2024-03-05-10-06-43.png"><br><strong>const_cast</strong> 可以进行强制类型转换，<strong>为变量添加const属性或者去掉const属性</strong>，一般常用的是去掉const属性，因为添加const属性可以隐式转换；如上图就是去除const属性；</p><table><thead><tr><th><img src="/article_img/2024-03-05-10-09-35.png"></th><th><img src="/article_img/2024-03-05-10-16-07.png"></th></tr></thead></table><p><strong>但是这个类型转换并没有真的转换原变量的const属性！</strong> </p><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><h2 id="类内使用static"><a href="#类内使用static" class="headerlink" title="类内使用static"></a>类内使用static</h2><p><img src="/article_img/2023-12-17-16-35-22.png"></p><p>使用static修饰的变量只有一份（<strong>所有类的实例共享</strong>），使用static修饰的函数称为静态函数，<strong>静态函数没有this指针</strong>，故静态函数不能操作任何非静态变量。对于一般的函数，其函数体当然也只有一份，要操作不同的类实例中的变量，自然就要一个this指针告诉函数体操作的对象是哪一个。</p><p>因此，<strong>静态函数不能是虚函数！</strong> 虚函数调用需要通过this指针找到自己的虚函数表来确定函数体，静态函数没有this指针自然也不能声明为虚函数；<br><img src="/article_img/2024-03-02-16-14-16.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">double</span> m_rate;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">set_rate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> x)</span></span>&#123;m_rate = x;&#125;<br>&#125;;<br><span class="hljs-type">double</span> Account::m_rate = <span class="hljs-number">8.0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Account::<span class="hljs-built_in">set_rate</span>(<span class="hljs-number">5.0</span>); <span class="hljs-comment">// 通过class name调用</span><br><br>    Account a;<br>    a.<span class="hljs-built_in">set_rate</span>(<span class="hljs-number">7.0</span>); <span class="hljs-comment">// 通过对象调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用static函数的方式有：</p><ol><li>通过对象调用</li><li>通过类名调用</li></ol><p>static应用之一单例模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> a;&#125;; <span class="hljs-comment">// 使用静态函数让外界调用仅有的对象</span><br>    <span class="hljs-built_in">setup</span>()&#123;...&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; rhs); <span class="hljs-comment">// 将构造函数放在private防止外界访问</span><br>    <span class="hljs-type">static</span> A a; <span class="hljs-comment">// 将自己声明为static，一开始就会有一个对象</span><br>    ...<br>&#125;;<br>&#123;<br>    A::<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">setup</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以对上面实现的单例做进一步优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 使用静态函数让外界调用仅有的对象</span><br>    <span class="hljs-built_in">setup</span>()&#123;...&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; rhs); <span class="hljs-comment">// 将构造函数放在private防止外界访问</span><br>    ...<br>&#125;;<br><span class="hljs-function">A&amp; <span class="hljs-title">A::getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">static</span> A a;  <span class="hljs-comment">// 只有第一次调用时才会创建唯一的对象，不调用不会创建</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类外使用static"><a href="#类外使用static" class="headerlink" title="类外使用static"></a>类外使用static</h2><p>类外的static修饰的符号在link阶段是<strong>局部</strong>的，也就是说它只对定义它的 <strong>编译单元（.obj）</strong> 可见。</p><p>当链接器（Linker）工作时，他不会找static修饰的变量，如果不是static修饰的全局变量，在link阶段就会随着链接而变成一个“<strong>整个项目的全局变量</strong>”，因为每一个使用到这个全局变量的编译单元都会去其他编译单元中寻找这个全局变量，如果不同的编译单元中定义了命名相同的全局变量，就会在链接阶段报重复定义的错。</p><p>同时static修饰的静态变量在离开作用域时，变量生命周期不会结束，<strong>其生命随程序结束而结束</strong>。由此可看出静态变量存储在 <strong>静态&#x2F;全局存储区</strong>。</p><h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>当它作为一个对函数或者全局变量的外部声明，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(T r=<span class="hljs-number">0</span>, T i=<span class="hljs-number">0</span>): <span class="hljs-built_in">a</span>(r), <span class="hljs-built_in">b</span>(i) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    T a, b;<br>&#125;;<br>&#123;<br>    complex&lt;<span class="hljs-type">double</span>&gt;<span class="hljs-built_in">c1</span>(<span class="hljs-number">2.5</span>, <span class="hljs-number">2.1</span>);<br>    complex&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">c2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 绑定T为int</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> </span><br><span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b&lt;a ? b : a;<br>&#125;<br><span class="hljs-function">stone <span class="hljs-title">r1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span>, <span class="hljs-title">r2</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)</span>, r3</span>;<br>r3 = <span class="hljs-built_in">min</span>(r1, r2);  <span class="hljs-comment">// 不需要告知类型，编译器会自动进行参数推导</span><br></code></pre></td></tr></table></figure><h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><p><img src="/article_img/2023-12-18-10-40-37.png"></p>]]></content>
    
    
    <categories>
      
      <category>-[C++]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Environmental and Motion Matched Interactions</title>
    <link href="/2023/12/14/Environmental%20and%20Motion%20Matched%20Interactions/"/>
    <url>/2023/12/14/Environmental%20and%20Motion%20Matched%20Interactions/</url>
    
    <content type="html"><![CDATA[<p>《Environmental and Motion Matched Interactions; ‘Madden’, ‘FIFA’ and Beyond》演讲</p><span id="more"></span><p>《Environmental and Motion Matched Interactions; ‘Madden’, ‘FIFA’ and Beyond》是一个实现多人物，人物和场景间交互的技术（本文简称为 <strong>EMMI</strong> ），主要为了开发《Madden-NFL》来实现橄榄球运动中众多的身体接触，该技术是EA在GDC2017上分享的 <strong>N-teract</strong> 技术和 <strong>Motion Matching</strong> 技术的结合。要梳理 EMMI 的思路就要先分别了解 N-teract和 Motion Matching。</p><h1 id="N-teract"><a href="#N-teract" class="headerlink" title="N-teract"></a>N-teract</h1><p><a href="https://www.gdcvault.com/play/1024015/EA-Presents-N-teract-Next">EA Presents N-teract: Next Generation Multi-Character Interactions</a></p><p><img src="/article_img/Madden.gif"></p><p>这个演讲首先展示了EA的 N-teract 工具和工作流，类似于插件的形式，之后讲解了实现原理和一些挑战和解决方案。我们直接从实现原理开始梳理。</p><h2 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h2><p>在讲解具体原理之前，需要先了解几个定义：</p><ol><li>多人动画；多人动画是一种同步动画，允许多个轨道分别控制一个角色来播放对应的动画。在N-teract系统中，一个场景（例如Tackle）可以存在多个多人动画，N-teract会从中挑选合适的多人动画播放。<br><img src="/article_img/2023-12-14-09-40-20.png"></li><li>Slot（插槽）；要实现多个角色顺利播放多人动画，那就必须要指定每个角色播放多人动画中的哪个角色动画，这就需要插槽来指定。<br><img src="/article_img/2023-12-14-09-41-51.png"></li><li>Slots；来定义具体的一个多人动画应该如何分配插槽，这是一个自动的过程，但是需要针对不同的动画设置不同的分配规则，例如对于Tackle（橄榄球中常见的拦截动作）动画使用如下方式指定Slot：<br><img src="/article_img/2023-12-14-09-47-52.png"></li></ol><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ol><li>各个角色会根据游戏逻辑发出请求，请求开始播放多人交互动画；<br><img src="/article_img/2023-12-14-09-30-29.png"></li><li>系统会收集发出请求的角色，并为他们分配对应的插槽，这里具体分配哪一个插槽就需要根据不同的场景分别设定；<br><img src="/article_img/2023-12-14-10-10-00.png"></li><li>根据分配好的插槽去多人动画数据库中挑选合适的动画进行播放；<table><thead><tr><th><img src="/article_img/2023-12-14-10-12-40.png"></th><th><img src="/article_img/2023-12-14-10-13-18.png"></th></tr></thead></table></li><li>如果找到了合适的多人动画，就播放并且做一些对齐之类的后处理；<br><img src="/article_img/2023-12-14-10-14-50.png"></li></ol><h2 id="分配插槽和匹配多人动画"><a href="#分配插槽和匹配多人动画" class="headerlink" title="分配插槽和匹配多人动画"></a>分配插槽和匹配多人动画</h2><p>从上述的流程中可以看出N-teract中的核心步骤是<strong>分配插槽</strong>和<strong>从数据库选择多人动画</strong>，这里就很像MotionMatching中选择关注的姿势信息和轨迹然后匹配下一帧姿势，这两步同样也是MM中核心步骤，决定MM实现质量。</p><p>分配插槽确实需要针对每一种不同的场景设计对应的分配规则，但是其实没有想象的那样需要设计很多分配规则，因为一个场景中可以有多种不同的多人动画。比如Tackle就是一个场景，将各种不同的tackle动画放进这个场景就行了，也就是说在实际操作中，我们只需要将动画数据分类，为每种类型的动画设计一个分配规则即可，这种思路就有点类似与状态机分层。</p><p>可以对匹配算法做一些优化，演讲中分为了两部分：</p><ol><li>离线阶段：根据已有的动画数据构建一个动画表，其中标记哪些方向需要我们关注，在实时中，我们只需要关注对应的方向即可，减少开销，如下图，在runtime中只关注3，5，6，8四个方向即可。<br><img src="/article_img/2023-12-14-11-29-38.png"></li><li>Runtime：仅检测离线阶段关注的插槽（方向），如果检测到其他角色就将该角色分配到对应插槽，并在数据库中寻找符合条件的动画。<br><img src="/article_img/2023-12-14-11-34-40.png"></li></ol><p>整个过程如下：</p><table><thead><tr><th><img src="/article_img/2023-12-14-11-35-41.png"></th><th><img src="/article_img/2023-12-14-11-35-58.png"></th></tr></thead></table><p>左图检测到了1号和3号，但是数据库中没有1号和3号同时存在的多人动画，故没有播放tackle动画，继续移动到了右图所示，检测到了1号和2号，数据库中有1号和2号同时存在的动画就播放。</p><h2 id="Late-Join和Invites"><a href="#Late-Join和Invites" class="headerlink" title="Late Join和Invites"></a>Late Join和Invites</h2><p>和MotionMatching一样，N-teract显然也是动画数据越多效果越好，这就造成了Coverage问题，动画数据不可能无限多，那就要尽可能的重用已有的动画，这个思路在动画领域也比较常见了。</p><p>文中主要提到两个重用方法：</p><ol><li><strong>Late Join</strong>：允许角色在播放动画的中途加入，其他角色如果恰好在正在播放的动画的路径上，就直接加入当前动画；<br><img src="/article_img/LateJoin.gif"><br>Late Join的实现基于对动画数据的预处理，将多人动画分为好几段，如下图，每隔四帧标记一个入口并计算出对应入口的进入条件。<br><img src="/article_img/2023-12-15-10-19-48.png"></li><li><strong>Invites</strong>：字面意思邀请角色加入播放的动画，应用于角色不在路线上时，让角色移动到路线上，再用<strong>Late Join</strong>；<br><img src="/article_img/Invites.gif"></li></ol><h2 id="被动交互"><a href="#被动交互" class="headerlink" title="被动交互"></a>被动交互</h2><p><img src="/article_img/EMMI_Env1.gif"></p><p>被动交互是指在多人动画中，其中一个角色在接触之前不播放该多人动画，比如上图中间的角色没有对冲过来的角色进行反应，直到被打击之后才播放受击动画。</p><p>其实我们在UE中做的一般都是被动交互，因为我们没有可以直接播放多人动画的动画状态机，只能在攻击之后让受击方播放受击动画；EA的引擎可以直接播放多人动画，那么猜测实现方式就是先禁用受击方的插槽，当检测到受击时启动插槽。</p><h2 id="环境交互"><a href="#环境交互" class="headerlink" title="环境交互"></a>环境交互</h2><p><img src="/article_img/EMMI_Env2.gif"></p><p>环境交互其实可以理解成和一个不动的角色进行的多人动画，这里还是N-teract的思路，比如对于翻墙动画，要把手扶的点摆在场景中，之后角色进行N-teract的步骤将这个点当作一个角色，在动画库中找到可以播放的动画。</p><p><img src="/article_img/2023-12-15-11-14-15.png"></p><p>这种方式确实可以实现很好的动画效果，对于一些翻墙之类的（不需要很精细的交互）可以通过一些检测自动找到交互点。</p><p>在Madden中，这种环境交互技术主要用于实现下图效果：<br><img src="/article_img/EMMI_Env4.gif"></p><table><thead><tr><th><img src="/article_img/EMMI_Env3.gif"></th><th><img src="/article_img/EMMI_Env5.gif"></th></tr></thead></table><p>所以可以用接口实现，只要有交互接口的对象都能触发N-teract系统：<br><img src="/article_img/2023-12-15-11-39-45.png"></p><h2 id="动态物体交互"><a href="#动态物体交互" class="headerlink" title="动态物体交互"></a>动态物体交互</h2><p>对于动态物体，其实就是提前计算动态物体的轨迹，设置几个交互点：<br><img src="/article_img/2023-12-15-11-44-00.png"></p><h1 id="Environmental-and-Motion-Matched-Interactions"><a href="#Environmental-and-Motion-Matched-Interactions" class="headerlink" title="Environmental and Motion Matched Interactions"></a>Environmental and Motion Matched Interactions</h1><h2 id="Rally-Motion-Matching"><a href="#Rally-Motion-Matching" class="headerlink" title="Rally Motion Matching"></a>Rally Motion Matching</h2><p>演讲中首先提到了最容易想到的Motion Matching的应用，利用MM的轨迹预测，让其他角色移动到可以触发N-teract的位置，也使用MM驱动来减少需要做的对齐或者扭曲。这种方法和Invites类似，不同点可能在于Invites是针对多人的，当一个角色开始交互动画之后将其他角色邀请来参加这个已经启动的交互动画，<strong>RallyMM则是在启动交互动画之前发生的</strong>。感觉没什么用，只是减少了Warping和Alignment。</p><p><img src="/article_img/2023-12-15-14-32-25.png"></p><h2 id="多人动作匹配（MultiChar-MotionMatching）"><a href="#多人动作匹配（MultiChar-MotionMatching）" class="headerlink" title="多人动作匹配（MultiChar MotionMatching）"></a>多人动作匹配（MultiChar MotionMatching）</h2><p>多人动作匹配是将传统动作匹配关注的单个骨架信息扩展为多个骨架，用多个角色的姿势和轨迹信息来匹配一个多人动画。这个理论上是确实是可行的，不过这是基于多人动画数据和EA的能够播放多人动画的状态机才能实现的，想要在UE中复现可能较难。</p><p><img src="/article_img/2023-12-15-14-45-20.png"></p><h2 id="N-teract与MM的结合"><a href="#N-teract与MM的结合" class="headerlink" title="N-teract与MM的结合"></a>N-teract与MM的结合</h2><p>这两个系统本身很相似，核心都是数据驱动的匹配算法，但是他们的匹配算法差异过大（N-teract依靠的分配Slot强制匹配，MM是计算Cost没那么强制），不能直接合并数据库。最终选择保留N-teract的框架，先进行N-teract，再进行MM：<br><img src="/article_img/2023-12-15-14-55-32.png"></p><p>这样的思路就要依靠之前提到的实现Late-Join的方法，将完整的多人动画设置很多入口（其实就是分成很多份），从而实现中途加入。进行改进之后允许在每一段中进行MM：</p><table><thead><tr><th><img src="/article_img/2023-12-15-10-19-48.png"></th><th><img src="/article_img/2023-12-15-15-00-40.png"></th></tr></thead></table><p>结合了MM之后效果如下，左图没有结合MM，在最后时刻由于受击者转身不匹配原本的动画，直接切换到了另一个动画；右图结合了MM，不匹配之后也切换了N-teract状态但是用到了MM，考虑了当前姿势，选择了合理的出拳动画（切换到站在背后的N-teract状态，开始MM选择继续出右拳）。</p><table><thead><tr><th><img src="/article_img/EMMI_Punch1.gif"></th><th><img src="/article_img/EMMI_Punch2.gif"></th></tr></thead></table><p>但是还是切换了动画片段，虽然MM了没有直接播放切换的片段，但是还是能感受到切换时会卡顿，还是希望不切换多人动画片段。这里感觉作者没细讲怎么做的（也可能我单纯没看懂</p><h2 id="问题和解决方案"><a href="#问题和解决方案" class="headerlink" title="问题和解决方案"></a>问题和解决方案</h2><ol><li>EMMI的问题之一是交互状态切换频繁，这是因为交互状态的匹配是强制匹配，很可能在交互过程中稍微不满足条件就切换了状态，所以需要在进入状态后加大容忍，让状态更难切换：<br><img src="/article_img/2023-12-15-16-17-53.png"></li><li>RootMotiom造成控制感较弱，这里解决方式就是一定程度放弃RootMotion，完全由玩家控制；</li><li>性能优化，实现Late-Join时设置了很多入口，其实不用设置那么多，可以进行预处理，减少入口数量；比如一个多人动画可能其中的角色相对位置始终没有改变，那么就只需要一个入口即可，也就是只在相对位置发生变化从而会影响交互状态匹配时，才设置入口。<br> <img src="/article_img/2023-12-15-16-25-29.png"><table><thead><tr><th><img src="/article_img/2023-12-15-16-24-37.png"></th><th><img src="/article_img/2023-12-15-16-24-19.png"></th></tr></thead></table></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>EMMI看起来是用MM对N-teract的一种优化，并没有对MM算法本身进行过多的调整，相当于部分使用MM，类似先使用状态机确定大状态，在大状态中交给MM驱动。</p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>侯捷C++-面向对象高级编程——类相关</title>
    <link href="/2023/12/11/%E4%BE%AF%E6%8D%B7C++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E7%B1%BB/"/>
    <url>/2023/12/11/%E4%BE%AF%E6%8D%B7C++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="access-level（访问级别）"><a href="#access-level（访问级别）" class="headerlink" title="access level（访问级别）"></a>access level（访问级别）</h1><p>一般数据<strong>都要</strong>设置为private，需要外界调用的函数设置为public。在单例模式中，会将构造函数设置为private，确保只能有一个对象。</p><p>friend关键字可以设置友元，友元可以自由取得private成员。<strong>相同的类（class）的各种对象（objects）互为友元</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> v1, v2;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.v1 + a.v2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p><strong>总是使用构造函数初始化列表！</strong>，不使用函数初始化列表会导致一些变量（比如下面的m_A）被初始化多次，造成性能浪费。因为不使用初始化列表时，是给m_A<strong>赋值</strong>，也就是先调用默认构造函数初始化了一个m_A对象，之后再给他赋值。</p><table><thead><tr><th><img src="/article_img/2023-04-21-14-35-19.png"></th><th><img src="/article_img/2023-04-21-14-36-18.png"></th></tr></thead></table><p>其次，使用初始化列表可以<strong>防止增添变量时修改函数体内部</strong>。并且，构造函数不只会给成员变量赋值，还有可能做其他操作，使用初始化列表可以将这两种逻辑分开，<strong>增加代码可读性</strong>。</p><p>总结：</p><ol><li>提高效率，避免不必要的复制操作</li><li>便于维护，增添变量时不用修改函数体内部</li><li>增加可读性，将初始化变量和其他构造函数逻辑分开</li></ol><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>当类内有指针类型的成员变量时，需要手动写拷贝构造函数，进行深拷贝。</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>成员函数都有this指针。<strong>谁调用构造函数，谁就是this</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b);<br></code></pre></td></tr></table></figure><h1 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h1><ol><li>指针是一个地址，有自己的内存空间，引用是别名（底层也是一个指针，可以说是指针的一种特例）</li><li>指针可以指向其他对象，引用初始化之后就不能改变了</li><li>指针可以初始化为nullptr，引用必须被初始化为一个已有对象的引用</li></ol><h1 id="参数传递（passByValue-vs-passByRef）"><a href="#参数传递（passByValue-vs-passByRef）" class="headerlink" title="参数传递（passByValue vs passByRef）"></a>参数传递（passByValue vs passByRef）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// pass by value</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;...&#125;<br><span class="hljs-comment">// pass by ref</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span></span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>传值（byValue）顾名思义是只关注值，也就是说需要新建一个变量来存这个值，这造成了不必要的性能开销，而且对于值很复杂的变量（如一个很大的结构体），传递起来速度也会变慢。因此尽量传递引用，<strong>引用在底层就是一个指针</strong>，传递指针即避免了赋值的开销又保证了传递的数据量较小（一个指针的大小）。</p><p>既然引用是一个指针，那么就要考虑函数内的修改会改变内存中的值，从而影响其他使用这个变量的地方，所以经常用const来修饰引用，保证函数内不会对参数进行修改。<strong>对于不希望改变的函数参数，尽量总是使用 “const引用” 作为函数参数！</strong></p><h1 id="返回值传递（returnByValue-vs-returnByRef）"><a href="#返回值传递（returnByValue-vs-returnByRef）" class="headerlink" title="返回值传递（returnByValue vs returnByRef）"></a>返回值传递（returnByValue vs returnByRef）</h1><p>与参数传递类似，返回值返回引用可以避免赋值开销，但是当返回值为临时变量（临时变量会随函数而消失，造成内存泄漏）时不能返回引用。</p><p><strong>传递者无需知道接收者是以reference形式接收。</strong> 这句话主要是指出引用的优势，使用引用不需要确保使用者事先知道你是否用了引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span> </span>&#123;<br><span class="hljs-keyword">return</span> *a; <span class="hljs-comment">// 直接返回值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span> </span>&#123;<br><span class="hljs-keyword">return</span> *a; <span class="hljs-comment">// 直接返回值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a; <span class="hljs-comment">// 需要返回指针类型</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><p>操作符就是一种函数，C++提供操作符来提高代码可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    complex&amp; complex::<span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp; )&#123;&#125;;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a, b;<br>&#125;;<br><span class="hljs-comment">// 注意返回值时complex&amp; 来实现连加：c3+=c2+=c1</span><br>complex&amp; complex::<span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp; x)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;a += x.a;<br>    <span class="hljs-keyword">this</span>-&gt;b += x.b;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在重载操作符时需要考虑连加的情况，也就是要注意重载+&#x3D;函数的返回值。</p><h2 id="拷贝赋值重载"><a href="#拷贝赋值重载" class="headerlink" title="拷贝赋值重载"></a>拷贝赋值重载</h2><p><strong>当类内有指针类型的成员变量时，要编写拷贝赋值函数（重载operator&#x3D;）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;str)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span>[] m_data;<br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data)+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意点：</p><ol><li><strong>检测自我赋值！</strong><br><img src="/article_img/2023-12-17-14-47-53.png"></li><li><strong>先删除原本的空间！</strong> 防止产生内存泄漏；</li><li><strong>分配新空间，进行深拷贝！</strong></li></ol><h2 id="output函数（"><a href="#output函数（" class="headerlink" title="output函数（&lt;&lt;）"></a>output函数（&lt;&lt;）</h2><p><strong>output函数一定要在类外定义，不要定义为成员函数！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> String&amp; str)&#123;<br>    os&lt;&lt;str.<span class="hljs-built_in">get_c_str</span>();<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="堆（heap），栈（stack）"><a href="#堆（heap），栈（stack）" class="headerlink" title="堆（heap），栈（stack）"></a>堆（heap），栈（stack）</h2><p><strong>栈</strong>是存在于某作用域（Scope）的一块内存空间（memory space）。如当调用某个函数，函数本身即会形成一个栈来放置<strong>接受的参数</strong>，<strong>返回的地址</strong>以及<strong>函数内的临时变量</strong>。</p><p><strong>堆</strong>或称为system heap，是指由操作系统提供的一块全局内存空间，程序可以动态分配从中获得若干区块。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li><strong>栈中的对象</strong>，其生命在作用域（scope）结束之后结束，也就是其内存会被<strong>自动</strong>回收。</li><li><strong>static修饰的静态对象</strong>，其生命随程序结束而结束，static修饰的对象并不是真正意义上的全局对象，其在link阶段是局部的，他们只对同一个 <strong>编译单元（.obj）</strong> 可见。</li><li><strong>全局对象</strong>，其生命随程序结束而结束。</li><li><strong>堆中的对象</strong>，其生命周期完全由程序员决定，要警惕内存泄漏。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;...&#125;<br>...<br>&#123;<br> Comlpex* p = <span class="hljs-keyword">new</span> Complex;<br>&#125; <span class="hljs-comment">// 内存泄漏，指针p的生命结束，但是p所指的堆上的对象仍然存在，这片内存就再也不能用了，相当于丢了这部分内存，这就叫内存泄漏。</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="new与delete"><a href="#new与delete" class="headerlink" title="new与delete"></a>new与delete</h2><p><img src="/article_img/2023-12-17-15-16-29.png"></p><p>可以看出 <strong>new</strong> 先调用用 <strong>malloc</strong> 分配内存，再调用构造函数（可以看出这里把pc当作了this指针，印证了谁调用构造函数谁就是this指针  ）。</p><p><img src="/article_img/2023-12-17-15-24-06.png"></p><p>可以看出 <strong>delete</strong> 先调用析构函数，再调用 <strong>free</strong> 释放内存。如上图案例，其中先调用析构函数释放动态分配的内存，再释放指针本身的内存。</p><h2 id="动态分配的内存细节（VC编译器）"><a href="#动态分配的内存细节（VC编译器）" class="headerlink" title="动态分配的内存细节（VC编译器）"></a>动态分配的内存细节（VC编译器）</h2><p><img src="/article_img/2023-12-17-15-30-25.png"></p><p>在调试模式下，编译器会为了方便调试多加一些灰色的内存，同时不管是不是调试模式，编译器都会在内存首尾添加<strong>cookie</strong>（用来记录分配出去的内存块大小），并且，分配内存必须是<strong>16的整数倍</strong>，所以填补一些pad内存使这块内存变为16的整数倍。 </p><p><img src="/article_img/2023-12-17-15-42-41.png"></p><p>在动态分配<strong>数组</strong>时，大致与上面相同，但是需要多4个字节存储数组的大小。</p><p><img src="/article_img/2023-12-17-15-47-43.png"><br><strong>array new 一定要搭配 array delete！</strong> 否则，指针数组中的指针指向的区域会发生内存泄漏。如果不用delete[] p 而使用 delete p，会把这块内存完美删掉，不会产生任何内存泄漏，但是由于编译器不知道删除的是一个数组，就只会调用一次析构函数，数组中其他指针指向的内存就没有被析构函数释放，造成内存泄漏。</p><h2 id="总结C-的内存布局"><a href="#总结C-的内存布局" class="headerlink" title="总结C++的内存布局"></a>总结C++的内存布局</h2><p><img src="/article_img/2024-03-01-13-03-59.png"></p><ol><li><strong>栈</strong>：系统分配的内存区域，大小较小一般为1M；<strong>存放局部变量，返回值，参数</strong>；由操作系统<strong>自动管理内存的申请和释放</strong>，栈由于由操作系统管理因此<strong>分配效率高</strong>，栈内地址<strong>由高向下</strong>；</li><li><strong>堆</strong>：专门开辟出的一片空间用于给程序员动态申请内存使用，大小较大一般为几个G；<strong>存放malloc，new出来的变量</strong>；需要程序员<strong>手动管理内存的申请和释放</strong>，因此 <strong>分配效率不如栈</strong>，堆内地址 <strong>自下而上</strong>；</li><li>全局&#x2F;静态存储区：存放 <strong>全局变量和静态变量</strong>，程序结束自动释放；初始化了的全局和静态变量放一起，没初始化的放一起，两个区域相邻；</li><li>常量存储区：存放<strong>常量</strong>如 string s&#x3D;”hello world” 中的 “hello world”；</li><li>代码存储区：存放<strong>代码，函数体</strong>，不可更改；生命周期与程序相同；</li></ol><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><h3 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h3><p><strong>关键在于CPU存取的效率问题</strong>。计算机从内存中取数据是按照<strong>固定长度</strong>的，如在32位机上，CPU每次都取32bit数据，也就是4字节，如果不进行对齐，要取出两块地址中的数据，要进行掩码和移位操作，写入目标寄存器内存，效率很低，因此要内存对齐；</p><h3 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h3><ol><li>结构体变量的首地址能被其最宽基本类型成员的对齐值整除</li><li>结构体内每个成员相对于起始地址的偏移量能够被该变量的大小整除</li><li>结构体总体大小能被最宽成员大小整除</li></ol><p>如不满足以上条件，编译器会进行填充（padding）</p><h3 id="如何对齐"><a href="#如何对齐" class="headerlink" title="如何对齐"></a>如何对齐</h3><p>字节对齐的数据依次声明，最后将小成员组合在一起，不要把小成员掺杂在对齐的数据之间；</p><h2 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h2><ul><li>C++中一个空类的大小是1<br><img src="/article_img/2024-03-07-16-23-49.png"></li><li>继承一个空类时，基类的大小就是0了，而不是1+1&#x3D;2：<br><img src="/article_img/2024-03-07-16-28-46.png"></li><li>有虚函数的类，会有一个<strong>虚函数指针</strong></li><li>static成员变量不存储在对象中，存储在 <strong>全局&#x2F;常量存储区</strong>：<br><img src="/article_img/2024-03-07-16-25-41.png"></li><li>static函数存储在代码区，而<strong>不是</strong>全局&#x2F;常量存储区</li></ul>]]></content>
    
    
    <categories>
      
      <category>-[C++]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unreal-Gameplay架构</title>
    <link href="/2023/11/12/Unreal-Gameplay%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/11/12/Unreal-Gameplay%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>《InsideUE》笔记</p><span id="more"></span><h1 id="什么是Gameplay架构"><a href="#什么是Gameplay架构" class="headerlink" title="什么是Gameplay架构"></a>什么是Gameplay架构</h1><p>UE官方文档中对Gameplay框架的定义是：<strong>游戏规则、玩家输出与控制、相机和用户界面等核心系统。</strong> 也就是 <strong>游戏规则、3C（Camera、Character、Control）和UI</strong></p><p><img src="/article_img/2023-11-21-14-44-55.png"></p><p>那么在UE中 <strong>游戏规则、3C和UI</strong> 具体是什么呢？</p><h2 id="游戏规则——GameMode和GameState"><a href="#游戏规则——GameMode和GameState" class="headerlink" title="游戏规则——GameMode和GameState"></a>游戏规则——GameMode和GameState</h2><p><strong>GameMode</strong> 决定游戏规则，比如玩家应该在哪生成，设置当前该显示什么UI等等。每个Level需要设置一个GameMode。GameMode在Unreal里的实现是AGameModeBase类。</p><p><strong>GameState</strong> 指游戏状态，追踪游戏层面的属性，比如当前游戏进行了多长时间，记录剩余敌人数量等等信息。GameState在Unreal中的实现是AGameStateBase类。与GameState类似的还有<strong>PlayerState</strong>用来记录玩家的信息，如血量，得分等信息，由APlayerState实现。</p><h2 id="3C——Camera-Character-Control"><a href="#3C——Camera-Character-Control" class="headerlink" title="3C——Camera Character Control"></a>3C——Camera Character Control</h2><p><strong>Camera</strong>在游戏中十分重要，他决定玩家如何观察这个游戏世界，一般用CameraComponent将其挂载在角色身上。</p><p><strong>Character</strong>就是游戏角色，他的父类是APawn类（<strong>Pawn 是可那些由玩家或 AI 控制的所有 Actor 的基类。Pawn 是玩家或 AI 实体在游戏场景中的具化体现</strong>），Character在Pawn的基础上添加了角色移动组件（CharacterMovementComponent），胶囊体组件（CapsuleComponent）和骨骼网格体组件（SkeletonMeshComponent）。</p><p><strong>Contoller</strong>是一种可以控制Pawn（或Pawn的派生类，例如角色（Character）），从而控制其动作的非实体Actor。默认情况下，控制器与Pawn之间存在一对一的关系；也就是说，每个控制器在任何给定的时间只控制一个Pawn。</p><p><img src="/article_img/2023-11-21-15-11-29.png"></p><h2 id="UI与HUD"><a href="#UI与HUD" class="headerlink" title="UI与HUD"></a>UI与HUD</h2><p><strong>HUD</strong>指的是游戏期间在屏幕上覆盖的状态和信息，不可互动。</p><p><strong>用户界面（UI）</strong> 指的是菜单和其他互动元素。这些元素通常是在屏幕上覆盖绘制的， 就像HUD一样，但是可以互动。</p><p>除了这两种之外，UE还提供了<strong>Slate</strong>，其是一种完全自定义，与平台无关的用户界面框架。</p><p>下面我们按照《InsideUE》的顺序详细学习UE的Gameplay框架。</p><h1 id="Actor和Component"><a href="#Actor和Component" class="headerlink" title="Actor和Component"></a>Actor和Component</h1><p>一个Gameplay框架最基础的问题是如何看待游戏世界，也就是游戏世界中的种种物体应该如何表示，Unity中使用GameObject，UE中就是Actor。</p><h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><p><img src="/article_img/2023-11-22-15-33-51.png"><br>AActor继承自UObject（之前我们提到的虚幻中最基础的类，用于实现反射，序列化等等功能，所有的类都继承自UObject），Actor无疑是UE中最重要的角色之一，组织庞大，最常见的有StaticMeshActor, CameraActor和 PlayerStartActor等。</p><p>与GameObject不同Actor本身不带有Transform属性，我们如果直接新建一个继承自Actor的蓝图，会发现他会自带一个<strong>SceneComponent</strong>，SceneComponent中实现了Transform属性。<br><img src="/article_img/2023-11-22-15-43-19.png"><br>这是因为UE认为一些不被显式表示的东西也是Actor，例如AInfo(派生类AWorldSetting,AGameMode,AGameSession,APlayerState,AGameState等)，AHUD,APlayerCameraManager等，这些不需要“放置”在游戏世界中，所以就没有让Actor自身带有Transform属性。UE游戏世界中的各种显式表示，规则，状态等等都是Actor。</p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><p>Component和Actor组合使用，基本的Actor甚至连Transform能力都要Component来实现也可以看出，<strong>Actor其实更像是一个容器，只提供了基本的创建销毁，网络复制，事件触发等一些逻辑性的功能</strong>，其他的功能由各种各样的Component来实现，需要用到该功能的时候就添加对应的Component即可。UActorComponent类也继承自UObject。<br><img src="/article_img/2023-11-22-15-56-12.png"><br>左侧依次提供了物理，材质，网格最终合成了一个StaticMeshComponent，右侧的ChildActorComponent可以让Actor之间互相嵌套。</p><p>最基本的Component就是SceneComponent，其提供了<strong>Transform</strong>和<strong>SceneComponent的互相嵌套功能</strong>。<br><img src="/article_img/2023-11-22-16-01-18.png"><br>可以看出，Actor本身不关心父子嵌套关系，而把父子的关系维护都交给了具体的Component。这也很能体现UE的设计思想：Actor要尽可能简单，连嵌套关系都交给Component实现。</p><p>有了Actor和Component我们就有了一个构建游戏世界的抓手，之后我们要把这些虚拟“演员”放到哪里呢？也就是该如何组织这些Actor呢？</p><h1 id="Level和World"><a href="#Level和World" class="headerlink" title="Level和World"></a>Level和World</h1><p>最基本的想法就是创建一个虚拟对象“World”来包容所有的Actor们，但是玩家其实不会一次性看到和游玩到整个World，所以一般的游戏引擎会把整个世界拆分为多个部分，Unity中拆成一个个Scene，由一个SceneManager在不同部分之间切换；UE中则是拆成Level，这些Level组成一个World。</p><h2 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h2><p><img src="/article_img/2023-11-22-16-25-48.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/column/insideue4">InsideUE5专栏</a><br><a href="https://zhuanlan.zhihu.com/p/612837045">Unreal Engine的Gameplay框架和重点</a><br><a href="https://www.bilibili.com/video/BV12Y411a75k/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20">UE甜筒#29.UE4&#x2F;UE5虚幻引擎的的Gameplay框架—从Actor聊到GameInstance</a></p>]]></content>
    
    
    <categories>
      
      <category>-[客户端]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于数据的角色动画——PFNN</title>
    <link href="/2023/11/06/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB-PFNN/"/>
    <url>/2023/11/06/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB-PFNN/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="/article_img/2023-11-06-15-03-19.png"></p><h1 id="角色动画控制的实现方法"><a href="#角色动画控制的实现方法" class="headerlink" title="角色动画控制的实现方法"></a>角色动画控制的实现方法</h1><p>在实现实时驱动角色动画时，分为两种主要的实现方法：<strong>运动学方法（Kinematic Approach）</strong>和<strong>基于物理的方法（Physics-based Character Animation）</strong></p><p><img src="/article_img/2023-11-06-15-16-31.png"></p><p>其区别主要在于运动学方法不考虑物理真实，一般只是在播放动画，如今最为成熟的就是动画状态机技术。</p><p>在运动学方法中又有 <strong>数据驱动的方法（Data-Driven）</strong> 尝试不设置状态机，用数据本身驱动角色动画，如Motion Matching在数据库中自动挑选要播放动画，而在此基础上又有 <strong>基于学习的方法（Learning-Based）</strong>，其尝试利用深度学习来学习数据库中的动画，从而不需要将数据库保留在内存中。其中Taku Komura组所做的一系列工作十分具有代表性，PFNN就是后续工作的奠基工作。</p><h1 id="PFNN简介"><a href="#PFNN简介" class="headerlink" title="PFNN简介"></a>PFNN简介</h1><p>PFNN全称Phase-Functional Neural Networks for Character Control，基于相位函数的角色控制神经网络。在此网络结构中，权重是通过使用相位作为输入的循环函数计算的。其中提出的相位函数的概念本质是一种<strong>专家系统（Mixture of Experts, MoE）</strong>，十分适用于动画生成领域，因为角色动画本身具有大量的二义性，如从站立到走路的过程中先迈哪只脚其实没区别，就会导致神经网络学习到的是一个平均值，导致动画生成质量较差，而PFNN根据人类走路的周期性提出Phase Function的概念解决这个二义性问题：</p><p><img src="/article_img/2023-11-07-17-18-23.png"></p><p>本文的核心就这张图：<br><img src="/article_img/2023-11-06-16-00-07.png"></p><p>本文的贡献主要有两点：</p><ol><li>提出一种新颖的动作分析框架PFNN，可以利用大量动画数据实现角色控制（生成可交互角色动画）包括与虚拟环境的交互。</li><li>提出一种为PFNN准备训练数据的工作流程，通过将运动数据与从虚拟环境中提取的几何图形进行拟合。</li></ol><p>其工作流程如下：</p><p><img src="/article_img/2023-11-06-16-04-38.png"></p><ol><li>数据预处理阶段：对捕捉到的运动数据进行处理，并<strong>提取控制参数</strong>。然后将这些数据与虚拟环境中的高度图数据<strong>进行拟合</strong></li><li>训练阶段：使用反向传播进行训练</li><li>执行阶段：根据用户控制和环境几何形状实时计算角色运动</li></ol><p>下面依次介绍这三个阶段。</p><h1 id="数据预处理阶段"><a href="#数据预处理阶段" class="headerlink" title="数据预处理阶段"></a>数据预处理阶段</h1><h2 id="动捕并提取控制参数"><a href="#动捕并提取控制参数" class="headerlink" title="动捕并提取控制参数"></a>动捕并提取控制参数</h2><p>动捕不同步幅和朝向的基础移动，以各种速度越过障碍，走，小跑和跑的动画，得到大概一小时的60帧动捕数据，使用了与 BVH（BioVision Hierarchical Data） 版本的 CMU 运动捕捉数据相同的铰接式人体模型，该模型有 30 个旋转关节，并在臀部下方的地面上添加了额外的根变换。</p><table><thead><tr><th><img src="/article_img/2023-11-06-16-35-39.png"></th><th><img src="/article_img/2023-11-06-16-35-06.png"></th></tr></thead></table><p><img src="/article_img/2023-11-06-16-20-22.png"></p><h3 id="标记Phase"><a href="#标记Phase" class="headerlink" title="标记Phase"></a>标记Phase</h3><p>得到动捕数据后，需要标记Phase，通过计算脚步关节速度检查脚步是否接触地面，之后将右脚接触地面时的Phase设为0，左脚接触时设为pi，下一次右脚接触时设为2pi，并对中间帧进行插值计算出Phase。</p><h3 id="标记步态"><a href="#标记步态" class="headerlink" title="标记步态"></a>标记步态</h3><p>之后标记人为标记步态，如标记走、跑、跳等步态。</p><h3 id="地形拟合"><a href="#地形拟合" class="headerlink" title="地形拟合"></a>地形拟合</h3><p>terrain fitting则是由于在mocap数据时，为了能获得爬山这种动作的数据，有录具有地面高度变化的数据，但是由于地面高度并没有在mocap数据中，所以只能重新反求。其思路是针对已经捕捉好的动作用不同的地形来拟合，也就是改变的是地形而不是动作本身，动作都是动捕到的动作。</p><p>在地形高度图中随机采样大约 20000 个 3x3 米Patch的位置和方向信息，首先针对每一个动作，找到最合适的十个patch（使用一个设计好的误差函数）；之后用 RBF（径向基函数）修改地形使动画中角色脚步接触地面时与地面准确接触。</p><p>计算最合适的Patch时用到的误差函数为：<br><img src="/article_img/2023-11-06-17-19-48.png"><br>其中 $h_i$ 为地形高度，$f_i$ 为脚步关节高度，$c_i$ 表示关节是否接地，$g_i$ 为步态信息；</p><p><img src="/article_img/2023-11-06-17-24-00.png"><br>经过地形拟合后，可以看到不同的patch可以对应同一个动作；</p><h1 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h1><h2 id="神经网络的输入输出参数"><a href="#神经网络的输入输出参数" class="headerlink" title="神经网络的输入输出参数"></a>神经网络的输入输出参数</h2><p>PFNN参数与MotionMatching类似，使用当前姿势和轨迹来得到下一帧姿势；</p><p><img src="/img/bg/PFNN.png"></p><p>输入参数：<strong>上一帧的关节位置和速度</strong>，<strong>当前帧采样窗口中的轨迹位置方向和高度信息（图中黑色点）</strong>（这两项就很类似MotionMatching）以及 <strong>步态信息</strong>（文中是用一个五维二值向量表示五种步态如走，跑，跳等等）；<br>输出参数：<strong>当前帧的关节位置速度和旋转</strong>，<strong>下一帧采样窗口中的轨迹位置和方向</strong>，<strong>根位移相对于前进方向的X速度，Z速度以及相对于向上向量的加速度</strong>（本文实现完全使用根运动，这里应该是得出当前的运动速度），<strong>Phase的变化</strong>，<strong>接地变量</strong>；</p><h2 id="PFNN结构"><a href="#PFNN结构" class="headerlink" title="PFNN结构"></a>PFNN结构</h2><p><img src="/article_img/2023-11-06-16-00-07.png"></p><h3 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h3><p>文章使用一个简单的三层神经网络：<br><img src="/article_img/2023-11-07-14-33-48.png"></p><p>激活函数是ELU函数：<br><img src="/article_img/2023-11-07-14-34-11.png"><br>长这样：<br><img src="/article_img/2023-11-07-14-37-44.png"></p><h3 id="Phase-Function"><a href="#Phase-Function" class="headerlink" title="Phase-Function"></a>Phase-Function</h3><p>Phase-Function选择 <strong>立方Catmull-Rom样条（Cubic Catmull-Rom spline）</strong> 函数，这是一种被广泛应用的曲线绘制函数（在blender中用于建模发丝）:<br><img src="/article_img/2023-11-07-16-18-30.png"><br>Cutmull-Rom样条一般形式如下，其某一点的切线是前一点和后一点的连线，本文中将首尾控制点设置为同一点构成一个圆形：</p><table><thead><tr><th><img src="/article_img/2023-11-07-16-28-30.png"></th><th><img src="/article_img/2023-11-07-16-29-00.png"></th></tr></thead></table><p>为什么要使用Catmull-Rom，因为本质上Phase-Function是想找到一种混合各个权重的方法（MoE），使用Catmull-Rom可以把权重当作控制点，并且可以保证结果是循环的（因为要保证同一个Phase输出的结果要是一样的）。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>训练是一个与相位函数参数有关的优化问题，最终就是要训练出 β，也就是四个权重 {$α_0$, $α_1$, $α_2$, $α_3$}，文章设计的损失函数如下：<br><img src="/article_img/2023-11-07-16-36-46.png"></p><h1 id="执行阶段（Runtime）"><a href="#执行阶段（Runtime）" class="headerlink" title="执行阶段（Runtime）"></a>执行阶段（Runtime）</h1><h2 id="执行阶段的输入参数"><a href="#执行阶段的输入参数" class="headerlink" title="执行阶段的输入参数"></a>执行阶段的输入参数</h2><p>执行阶段的输入根据上述的神经网络输入参数分为两部分介绍，<strong>骨骼信息</strong>和<strong>轨迹信息</strong>：</p><ol><li>骨骼相关的信息直接用上一帧预测出的骨骼信息</li><li>轨迹相关的信息也分为两部分，过去轨迹和未来轨迹，过去轨迹直接记录即可，未来轨迹需要与用户输入进行混合，用来平衡控制灵敏度和可信度：<br><img src="/article_img/2023-11-07-16-47-15.png"></li></ol><p>同时也要考虑用户希望的步态信息，如奔跑，跳跃等；在文章的Demo实现中，如果希望角色跳跃就需要一直按住空格，这是因为动作生成的单位是帧，就需要一段时间内的步态信息都指明是跳跃才能生成完整的跳跃动画（MotionMatching中如果要实现跳跃应该也有类似问题），但是应该可以通过技术操作解决。</p><table><thead><tr><th><img src="/article_img/2023-11-07-17-11-36.png"></th><th><img src="/article_img/2023-11-07-17-11-44.png"></th></tr></thead></table><h2 id="预计算Phase-Function"><a href="#预计算Phase-Function" class="headerlink" title="预计算Phase Function"></a>预计算Phase Function</h2><p>文中指出，计算Phase Function需要一毫秒，因此文章提出两种预计算方案：</p><ol><li>预计算出50个Phase Function的值，在执行过程中直接用临近的值代替，空间换时间；</li><li>预计算10个值，之后线性插值；</li></ol><h1 id="实验结果评估"><a href="#实验结果评估" class="headerlink" title="实验结果评估"></a>实验结果评估</h1><table><thead><tr><th><img src="/article_img/2023-11-07-17-08-05.png"></th><th><img src="/article_img/2023-11-07-17-08-17.png"></th></tr></thead></table><p>文章对各种网络结构进行了实验，发现还是PFNN效果好，并且使用Phase Function直接控制参数与将Phase当作参数相比效果更好。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/115155715">[合集] Data-Driven Character Motion Synthesis</a><br><a href="https://zhuanlan.zhihu.com/p/485607474">动作生成的智能之路(I) : PFNN和MANN</a><br><a href="https://zhuanlan.zhihu.com/p/53596871">phase functioned network for character control</a><br><a href="https://zhuanlan.zhihu.com/p/172254089">一文搞懂激活函数(Sigmoid&#x2F;ReLU&#x2F;LeakyReLU&#x2F;PReLU&#x2F;ELU)</a><br><a href="https://www.bilibili.com/video/BV16B4y1f74s/?spm_id_from=333.880.my_history.page.click&vd_source=93b215eab72b2548f75d0772e28f8b20">Blender几何建模原理（五）曲线</a></p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unreal-虚幻C++基础</title>
    <link href="/2023/10/12/Unreal-%E8%99%9A%E5%B9%BBC++%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/12/Unreal-%E8%99%9A%E5%B9%BBC++%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Unreal项目规范："><a href="#Unreal项目规范：" class="headerlink" title="Unreal项目规范："></a>Unreal项目规范：</h1><h2 id="Allar-ue5-style-guide"><a href="#Allar-ue5-style-guide" class="headerlink" title="Allar&#x2F;ue5-style-guide"></a><a href="https://github.com/Allar/ue5-style-guide">Allar&#x2F;ue5-style-guide</a></h2><h2 id="中文翻译版"><a href="#中文翻译版" class="headerlink" title="中文翻译版"></a><a href="https://github.com/skylens-inc/ue4-style-guide/blob/master/README.md">中文翻译版</a></h2><p>常用的命名规范有：</p><ol><li>派生自UObject类的都以U为前缀（派生自U开头类的类也都已U为前缀）</li><li>派生自AActor的以A为前缀</li><li>bool变量以b前缀，如bPendingDestruction</li><li>抽象接口以I前缀<br><img src="/article_img/2023-11-11-14-59-41.png"><br>虚幻中派生自UInterface的类都有两个定义，一个以U开头实现作为一个基本类的功能，一个以I开头实现接口功能<br><img src="/article_img/2023-10-13-14-17-23.png"></li></ol><h1 id="虚幻C-基础"><a href="#虚幻C-基础" class="headerlink" title="虚幻C++基础"></a>虚幻C++基础</h1><p>虚幻的C++开发不是使用纯粹的C++进行编程，虚幻引擎为了实现各种复杂机制，在C++基础上搭建了一套反射机制。下面是我们新建一个C++类，虚幻自动帮我们生成的头文件的结构，其中有很多宏定义和必须引用的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GameFramework/Actor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SBaseProjectile.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPPRPG_API</span> ASBaseProjectile : <span class="hljs-keyword">public</span> AActor<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Sets default values for this actor&#x27;s properties</span><br><span class="hljs-built_in">ASBaseProjectile</span>();<br><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, Category=<span class="hljs-string">&quot;Attribute of Base Projectile&quot;</span>)<br><span class="hljs-type">float</span> ProjectileMoveSpeed;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Called every frame</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaTime)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射在Java和C#等语言中比较常见，概况的说，反射数据描述了类在运行时的内容。这些数据所存储的信息包括类的名称、类中的数据成员、每个数据成员的类型、每个成员位于对象内存映像的偏移（offset），此外，它也包含类的所有成员函数信息。</p><p>简单来说，反射可以实现在程序运行时<strong>动态地对类，对象，方法等进行操作</strong>。例如在虚幻中，反射用来实现序列化（就是将对象转换为字节流，存储和网络传输使用），编辑器中动态调整各种属性，垃圾回收，网络复制，蓝图&#x2F;C++通信和相互调用的功能。</p><p>虚幻引擎的反射机制的核心是<strong>UObject</strong>类，所有的类都继承自UObject：<br><img src="/article_img/2023-11-11-14-54-02.png"></p><p><strong>#include “xxx.generated.h”</strong> 以及 <strong>UPROPERTY()<strong>，</strong>UFUNCTION()<strong>，</strong>UCLASS()</strong> 等宏定义都用来让UE实现反射。</p><h2 id="UBT（Unreal-Build-Tool）"><a href="#UBT（Unreal-Build-Tool）" class="headerlink" title="UBT（Unreal Build Tool）"></a>UBT（Unreal Build Tool）</h2><p>虚幻项目的编译全权由<strong>UBT</strong>负责，其本质就和其名字一样就是一个<strong>编译工具</strong>，和CMake之类的是一个东西，只不过其是专门为UE量身定做的编译工具。有了UBT就可以方便配置各个平台的参数和编译选项，不用为每个平台单独配置编译了。</p><p>我们可以直接使用Engine\Binaries\DotNET\UnrealBuildTool目录下的UnrealBuildTool.exe再命令行中编译我们的项目。在创建新项目时，自动生成的Target.cs，Build.cs都是为这个工具服务的。</p><p>UBT工作流程分为两步：</p><ol><li>调用UHT（Unreal Header Tool）</li><li>调用平台特定的编译工具（VS，LLVM）编译各个模块</li></ol><h2 id="UHT（Unreal-Header-Tool）"><a href="#UHT（Unreal-Header-Tool）" class="headerlink" title="UHT（Unreal Header Tool）"></a>UHT（Unreal Header Tool）</h2><p>UHT（Unreal Header Tool）是用来解析虚幻C++的，上面我们提到了要实现UE反射需要些各种宏，<strong>UHT就是将这些代码解析成标准的C++代码</strong>，之后再由UBT组织这些标准C++代码进行正常的C++编译。</p><p>可以这样直观理解，我们写的虚幻C++代码其实和标准C++不同，有很多宏以及很多省略或者固定的写法（接口函数实现xxx_Implementation），可以将我们写的代码称为U++。<strong>编译过程就是调用UBT，UBT先调用UHT将U++翻译为C++，再调用C++编译工具对C++编译。</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/562841250">大象无形UE4笔记六：UBT</a><br><a href="https://zhuanlan.zhihu.com/p/60622181">UE4反射机制</a><br><a href="https://zhuanlan.zhihu.com/p/22814098">《InsideUE4》基础概念</a></p>]]></content>
    
    
    <categories>
      
      <category>-[客户端]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unreal-引擎源码编译和打包</title>
    <link href="/2023/09/12/Unreal-%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%93%E5%8C%85/"/>
    <url>/2023/09/12/Unreal-%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="编译虚幻引擎"><a href="#编译虚幻引擎" class="headerlink" title="编译虚幻引擎"></a>编译虚幻引擎</h1><p><a href="https://docs.unrealengine.com/5.2/zh-CN/downloading-unreal-engine-source-code/">官方文档——下载虚幻引擎源代码</a></p><p>虚幻引擎是开源的，但是要访问github上的虚幻引擎源码需要将自己的github账号和epic账号绑定并授权，具体操作流程参考UE<a href="https://www.unrealengine.com/zh-CN/ue-on-github">官方教程</a>。之后我们就可以愉快的访问虚幻引擎的github仓库了：</p><p><img src="/article_img/2023-09-12-09-54-18.png"></p><p><strong>编译源码需要预留大约250G的硬盘空间</strong>，我全部编译完UE5.2的文件夹大小为215G</p><p>clone源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone https://github.com/EpicGames/UnrealEngine.git<br></code></pre></td></tr></table></figure><p>直接clone源码默认是在release分支下，当我们把源码全部clone到本地之后，记得切换到想要编译的版本再进行后续操作，这里选择编译安装的5.2.1版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout 5.2.1-release <br></code></pre></td></tr></table></figure><p>之后依次运行根目录下的 <strong>Setup.bat</strong> (下载一些需要的依赖，需要一两个小时) 和 <strong>GenerateProjectFiles.bat</strong>（生成UE5.sln，几分钟）</p><p>之后就可以从 <strong>VS2022</strong> 打开 <strong>UE5.sln</strong> 开始编译了，为了避免一些可能的编译问题，最好在Visual Studio Installer中安装如下模块（使用Unity的游戏开发可以不安装）：</p><p><img src="/article_img/2023-09-12-10-13-51.png"><br><img src="/article_img/2023-09-12-10-14-11.png"></p><p>在打开UE5.sln之后，VS会自动检测需要安装那些组件，跟随指引安装即可：<br><img src="/article_img/2023-09-09-19-55-45.png"></p><p>安装完成之后，右键UE5，点击生成，开始编译（我电脑编译大约七个小时。。）<br><img src="/article_img/2023-09-12-10-18-00.png"></p><p>编译完成之后找到这个地址 <strong>%Engine-Folder%\UnrealEngine\Engine\Binaries\Win64\UnrealEditor.exe</strong> ，启动！<br><img src="/article_img/2023-09-12-10-32-37.png"></p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>记录从源码版引擎创建第三人称模板，打包到安卓平台的过程。<br>参考<a href="https://docs.unrealengine.com/5.2/zh-CN/getting-started-and-setup-for-android-projects-in-unreal-engine/">官方文档——Android开始入门</a></p><p>打开虚幻编辑器后，按照如下选项新建项目，注意目标平台选择 <strong>移动平台</strong>，质量预设选择 <strong>可缩放</strong>，项目名称为全英文：<br><img src="/article_img/2023-09-12-10-36-08.png"></p><p>创建完成之后会自动打开VS2022，显示刚刚创建的项目工程，右键项目名称，点击生成：<br><img src="/article_img/2023-09-12-10-47-44.png"><br>对于第三人称模板来说大约需要几分钟，之后就可以在虚幻编辑器中找到该项目；</p><p>参考<a href="https://zhuanlan.zhihu.com/p/509308558">《UE4开发笔记》Tip 1 编译完全指南</a>发现，如果将 <strong>%UnrealEngine%\Engine\Build</strong> 目录下的 <strong>SourceDistribution.txt</strong> 文件改名为 <strong>InstalledBuild.txt</strong> 就不需要再在VS中手动点击生成了，会和直接下载UE一样直接打开项目（这两个文件都是空的，可以放心改名），具体原理参考上面的文章。<br><img src="/article_img/2023-09-14-14-20-23.png"></p><p>打开项目之后，由于我们想要打包到安卓平台，为了保证开发中和最后在手机上运行效果一致，我们需要设置预览渲染级别（第一次设置之后编译shader需要一段时间）：<br><img src="/article_img/2023-09-12-10-58-00.png"></p><p>通过运行按钮左边的按钮可以设置当前的预览渲染模式：</p><table><thead><tr><th><img src="/article_img/2023-09-12-10-59-18.png"></th><th><img src="/article_img/2023-09-12-10-59-41.png"></th></tr></thead></table><h1 id="打包到安卓平台"><a href="#打包到安卓平台" class="headerlink" title="打包到安卓平台"></a>打包到安卓平台</h1><p>按照<a href="https://docs.unrealengine.com/5.2/zh-CN/getting-started-and-setup-for-android-projects-in-unreal-engine/">官方文档——Android开始入门</a>步骤进行即可，这里记录几个需要注意的点和自己遇到的报错；</p><h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><p>安装 Android Studio 时需要严格按照官方文档下载 <strong>Android Studio 4.0</strong>，不要下载最新版，因为最新版不自带jdk，会导致之后打包时报错。安装完成之后，要把系统变量中的 <strong>JAVA_HOME</strong> 值改为 Android Studio文件夹中的jre路径（设置完毕后重启电脑），在我们按照教程启动 <strong>SetupAndroid.bat</strong> 的时候会去找系统变量中的 <strong>JAVA_HOME</strong>：<br><img src="/article_img/2023-09-12-11-13-23.png"></p><p>如果使用自己的jdk会报如下错误或者类似的和rungradle.bat有关的错误：<br><img src="/article_img/2023-09-12-12-09-35.png"></p><h2 id="UE项目设置"><a href="#UE项目设置" class="headerlink" title="UE项目设置"></a>UE项目设置</h2><p>需要勾选生成apk，否则不能正常安装到手机：<br><img src="/article_img/2023-09-12-13-54-18.png"></p><p>这里前三项默认即可（会在 <strong>SetupAndroid.bat</strong> 中自动设置），后两项需要和对应的版本一致，<strong>SDK API Level</strong>这里默认填写的是 <strong>latest</strong>，会使用电脑中最新版本的SDK，这里要注意不要和<strong>SetupAndroid.bat</strong> 中的设置冲突（该文件中会定义用到的SDK的版本，如果下载最新版的Android Studio会默认下载更高版本的SDK，也会造成打包失败）；<br><img src="/article_img/2023-09-12-13-55-48.png"></p><h2 id="手机设置"><a href="#手机设置" class="headerlink" title="手机设置"></a>手机设置</h2><p>在完成上面的操作之后，还需要在手机上打开开发者模式，这样就能通过打包完成后的文件夹中的批处理命令将游戏安装到手机上：<br><img src="/article_img/2023-09-12-14-03-24.png"></p><p>手机的具体设置UE官方文档写的很详细：<a href="https://docs.unrealengine.com/5.2/zh-CN/setting-up-your-android-device-for-developing-applications-in-unreal-engine/">设置Android设备</a>，这里记录一下我遇到问题，我准备使用退役的小米8（没有SD卡）当作测试用机，在安装时会报如下错误：<br><img src="/article_img/2023-09-12-14-07-43.png"></p><p>这是由于MIUI禁止了在没有安装SD卡时通过USB安装程序，需要先插上SD卡，打开 <strong>USB安装</strong>，之后再拔掉SD卡，之后不需要SD卡也可以正常安装了：<br><img src="/article_img/2023-09-12-14-11-00.png"></p><p>当手机通过USB连接在电脑上并且设置好上面的各种配置后，可以选择直接在Android设备上启动，如果没有打开USB安装选项也会报如下错误：<br><img src="/article_img/2023-09-11-21-55-11.png"></p><p>启动成功！<br><img src="/article_img/2023-09-12-14-22-38.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.unrealengine.com/5.2/zh-CN/getting-started-and-setup-for-android-projects-in-unreal-engine/">UE文档-分享和发布项目-Android-开始入门</a><br><a href="https://zhuanlan.zhihu.com/p/562504560">Windows10 UE4.27 新手向打包安卓项目流程整理</a><br><a href="https://zhuanlan.zhihu.com/p/655375421">UE4学习笔记（1）：UE源码下载编译+安卓打包</a><br><a href="https://zhuanlan.zhihu.com/p/509308558">《UE4开发笔记》Tip 1 编译完全指南</a></p>]]></content>
    
    
    <categories>
      
      <category>-[客户端]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百人计划-阴影</title>
    <link href="/2023/09/08/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E9%98%B4%E5%BD%B1/"/>
    <url>/2023/09/08/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E9%98%B4%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://www.bilibili.com/read/cv6436088/?spm_id_from=333.999.0.0">urp管线的自学hlsl之路 </a><br>《Unity Shader入门精要》 第9章 更复杂的光照<br><a href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=3&vd_source=93b215eab72b2548f75d0772e28f8b20">Games202</a></p><p>代码标注为C++只是为了会有高亮好看，实际是ShaderLab</p><span id="more"></span><h1 id="阴影的实现原理"><a href="#阴影的实现原理" class="headerlink" title="阴影的实现原理"></a>阴影的实现原理</h1><p>在实时渲染中，阴影一般通过shadow map实现，具体来说就是先将摄像机移到要投射阴影的光源位置，进行一次渲染得到从光源处看到的一张深度图，我们叫这张图为shadow map；之后在正常的渲染pass中，将顶点坐标变换到光源坐标系中，将深度与shadow map中的深度进行比较，如果比shadow map中的深度大，就说明该点应该在阴影中。</p><p><img src="/article_img/2023-09-08-16-51-35.png"></p><p>在unity中阴影的实现分为两部分，<strong>接收阴影（接收别的物体投射出的阴影）和投射阴影（将自身阴影投射到别的物体）</strong>：</p><ol><li><strong>接收阴影</strong>：接收阴影就是要计算那些点在应该在阴影里，也就是需要在正常的光照计算中将顶点在光源坐标系中的深度与shadow map中的深度进行对比，得到阴影衰减。</li><li><strong>投射阴影</strong>：根据上面描述的阴影的实现原理，如果一个物体要投射阴影就需要将让这个物体参与shadow map的生成，在unity中使用一个带有 <strong>Tags { “LightMode” &#x3D; “ShadowCaster”}</strong> 的pass来实现。</li></ol><h2 id="接收阴影"><a href="#接收阴影" class="headerlink" title="接收阴影"></a>接收阴影</h2><p>下面给出在URP中实现接收阴影的关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">HLSLPROGRAM<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ _MAIN_LIGHT_SHADOWS</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ _SHADOWS_SOFT</span><br><span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(in a2v v)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-function">real4 <span class="hljs-title">frag</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET&#123;</span><br>    <span class="hljs-comment">// compute ambient, albedo</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// compute diffuse</span><br>    float4 shodowCoord = <span class="hljs-built_in">TransformWorldToShadowCoord</span>(worldPos);<br>    Light mainLight = <span class="hljs-built_in">GetMainLight</span>(shadowCoord);<br>    half3 diffuse = mainLight.color * albedo * <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(worldNormal, mainLight.direction)) * mainLight.shodowAttenuation;<br>    <span class="hljs-comment">// ... </span><br>&#125;<br>ENDHLSL<br></code></pre></td></tr></table></figure><p>其中 <strong>float4 TransformWorldToShadowCoord(float3 positionWS)</strong> 函数（定义在Shadows.hlsl中）用将顶点坐标从世界坐标转换到光源坐标：<br><img src="/article_img/2023-09-08-14-24-44.png"><br>可以看出函数需要一个宏 <strong>_MAIN_LIGHT_SHADOWS_CASCADE</strong> 所以我们需要在shader中也定义这个宏，用来确定使用哪个尺度的shadow map（在URP资产中可以设置生成不同尺度shadow map的个数），选择的shadow map分辨率越大阴影越细致，这个尺度的选择由函数 <strong>half ComputeCascadeIndex(float3 positionWS)</strong> 实现，离摄像机越远选择分辨率越低的shadow map，之后函数直接用矩阵乘法计算出光源坐标系中的顶点坐标。</p><table><thead><tr><th><img src="/article_img/2023-09-08-14-31-57.png"></th><th><img src="/article_img/2023-09-08-14-32-36.png"></th></tr></thead></table><p>其中的 <strong>Light GetMainLight(float4 shadowCoord)</strong> 函数是原始的 <strong>Light GetMainLight()</strong> 的一个重载：<br><img src="/article_img/2023-09-08-14-42-37.png"><br>相比原函数多出一个计算光照衰减的步骤，通过函数 <strong>half MainLightRealtimeShadow(float4 shadowCoord)</strong> 实现：<br><img src="/article_img/2023-09-08-14-53-21.png"><br>由这个函数就可以看出我们需要定义宏 <strong>_MAIN_LIGHT_COMPUTE_SHADOWS</strong> 来采样shadow map计算阴影衰减。并且如果我们希望生成软阴影也需要定义宏 <strong>_SHADOWS_SOFT</strong>，这个宏会在 <strong>SampleShadowmap</strong> 函数中决定是否生成软阴影。</p><p><img src="/article_img/2023-09-08-15-14-03.png"><br>至此，我们的物体已经可以接收别的物体投射的阴影了，但是可以看到地面上也有一个正方体的阴影，这是因为我们的物体还不能投射阴影，在shadow map中根本没有我们的胶囊体，因此地面去采样shadow map时还是会接收到正方体的阴影，接下来实现投射阴影来解决这个问题。</p><h2 id="投射阴影"><a href="#投射阴影" class="headerlink" title="投射阴影"></a>投射阴影</h2><p>在上面的阴影实现原理中，已经得知投射阴影需要将物体写入shadow map，在unity中实现需要单独实现一个pass并标明其 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong>，这样unity就会在生成shadow map时考虑该物体，也就是将光源坐标下该物体的深度写入shadow map。</p><p>下面给出在URP中实现投射阴影的关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">pass&#123;<br>    Tags &#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;UniversalForward&quot;</span>&#125;<br>    <span class="hljs-comment">// 正向渲染计算光照并实现接收阴影</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br>pass&#123;<br>    Tags &#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ShadowCaster&quot;</span>&#125;<br>     HLSLPROGRAM<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br>    v2f <span class="hljs-built_in">vert</span>(in a2v v)<br>    &#123;<br>        v2f o;<br>        o.positionCS = <span class="hljs-built_in">TransformObjectToHClip</span>(v.positionOS.xyz);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>    <span class="hljs-function">real4 <span class="hljs-title">frag</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    ENDHLSL<br>&#125;<br></code></pre></td></tr></table></figure><p>将 <strong>LightMode</strong> 设置为 <strong>ShadowCaster</strong> 后，只需要实现最简单的顶点和片元着色器就可以投射阴影了，因为将深度写入shadow map本质就是将场景渲染到shadow map上，借助渲染流水线中的深度写入就可以实现渲染出一张深度图了。已经可以渲染出正确的阴影了：</p><p><img src="/article_img/2023-09-08-15-27-58.png"></p><h2 id="Shadow-Mapping的问题"><a href="#Shadow-Mapping的问题" class="headerlink" title="Shadow Mapping的问题"></a>Shadow Mapping的问题</h2><p><img src="/article_img/2023-09-10-15-39-45.png"></p><p><img src="/article_img/2023-09-08-16-52-46.png"></p><p>由于shadow map是有分辨率的，那么每个像素就会对应一片区域，且这片区域的深度是相同的，这样就会导致将连续的深度离散化，就会产生自遮挡的问题。为解决这个问题，我们需要添加一个偏移，忽略一小段深度变化，也就是只有深度相差较大的时候，才认为产生了遮挡。这种解决方案叫做 <strong>深度偏移</strong></p><p><a href="https://zhuanlan.zhihu.com/p/370951892">自适应Shadow Bias算法</a></p><h3 id="深度偏移"><a href="#深度偏移" class="headerlink" title="深度偏移"></a>深度偏移</h3><p><img src="/article_img/2023-09-08-16-59-05.png"></p><p>如下图所示，深度偏移就是将 D点 移动到 G点，将 C点 移动到 H点，这样D点的深度就不会被认为比G点低而被遮挡了。在实际应用中，我们不会为CD线段上的每个点计算准确的偏移，而是直接将每个点都向光源方向平移DG的距离，这一步操作在顶点着色器中进行。</p><table><thead><tr><th><img src="/article_img/2023-09-10-14-20-06.png"></th><th><img src="/article_img/2023-09-10-14-14-58.png"></th></tr></thead></table><h3 id="法线偏移"><a href="#法线偏移" class="headerlink" title="法线偏移"></a>法线偏移</h3><p>还有一种解决方案是将 DG 向上平移一段距离，原理如下：</p><p><img src="/article_img/2023-09-10-15-29-15.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在URP管线下，shadow.hlsl中的函数 <strong>float3 ApplyShadowBias(float3 positionWS, float3 normalWS, float3 lightDirection)</strong> 同时实现了这两种偏移，避免了“漏光”现象：<br><img src="/article_img/2023-09-10-14-26-08.png"></p><p>函数中使用的深度偏移值和法线偏移值均在URP资产中设置：<br><img src="/article_img/2023-09-10-17-21-48.png"></p><p>至此我们可以自己实现一个带阴影偏移的投射阴影的pass:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">pass &#123;<br>    Tags &#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ShadowCaster&quot;</span>&#125;<br>    <br>    HLSLPROGRAM<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br>    half3 _LightDirection; <span class="hljs-comment">// 应该是unity定义的，这里只需要声明即可</span><br>    <span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(in a2v v)</span></span><br><span class="hljs-function">    </span>&#123;<br>        v2f o;<br>        o.worldNormal = <span class="hljs-built_in">TransformObjectToWorldNormal</span>(v.normalOS);<br>        o.worldPos = <span class="hljs-built_in">TransformObjectToWorld</span>(v.positionOS.xyz);<br>        <span class="hljs-comment">// 注意这里是从世界空间转换到裁剪空间！</span><br>        o.positionCS = <span class="hljs-built_in">TransformWorldToHClip</span>(<span class="hljs-built_in">ApplyShadowBias</span>(o.worldPos, o.worldNormal, _LightDirection));<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>    <span class="hljs-function">real4 <span class="hljs-title">frag</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    ENDHLSL<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-09-10-15-40-28.png"></p><p>十分光滑了！</p><h1 id="多光源阴影"><a href="#多光源阴影" class="headerlink" title="多光源阴影"></a>多光源阴影</h1><h2 id="多光源shader"><a href="#多光源shader" class="headerlink" title="多光源shader"></a>多光源shader</h2><p>这里先复习一下多光源的处理，在Build-in管线中多光源需要一个主光源pass（**Tags{“LightMode”&#x3D;”ForwardBase”}<strong>）和一个其他光源pass（</strong>Tags{“LightMode”&#x3D;”AddForward”}**）两个pass来实现，对于URP管线，多光源被整合进一个pass中实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">pass &#123;<br>    Tags &#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;UniversalForward&quot;</span>&#125;<br>    <span class="hljs-comment">// ...</span><br>    real4 <span class="hljs-built_in">frag</span>(in v2f i) : SV_TARGET&#123;<br>        <span class="hljs-comment">// mainlight</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// add light color</span><br>        real3 color = <span class="hljs-built_in">real3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> addLightCount = <span class="hljs-built_in">GetAdditionalLightsCount</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index; index &lt; addLightCount; index++)<br>        &#123;<br>            Light addLight = <span class="hljs-built_in">GetAdditionalLight</span>(index, i.worldPos);<br>            color += addLight.color * albedo * <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(addLight.direction, worldNormal)) * addLight.distanceAttenuation;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">real4</span>(mainLightColor + color + ambient, <span class="hljs-number">1.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多光源阴影-1"><a href="#多光源阴影-1" class="headerlink" title="多光源阴影"></a>多光源阴影</h2><p>和主光源阴影的实现一样，多光源阴影也分为接收阴影和投射阴影两部分，其实现如下：</p><h3 id="多光源阴影接收"><a href="#多光源阴影接收" class="headerlink" title="多光源阴影接收"></a>多光源阴影接收</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++">pass &#123;<br>    Tags &#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;UniversalForward&quot;</span>&#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile _ _ADDITIONAL_LIGHT_SHADOWS</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ...</span><br><span class="hljs-comment">    */</span><br>    real4 <span class="hljs-built_in">frag</span>(in v2f i) : SV_TARGET&#123;<br>        <span class="hljs-comment">// main light color</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// add light color</span><br>        real3 color = <span class="hljs-built_in">real3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> addLightCount = <span class="hljs-built_in">GetAdditionalLightsCount</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index; index &lt; addLightCount; index++)<br>        &#123;<br>            <span class="hljs-comment">// 这里使用GetAdditionalLight的重载</span><br>            Light addLight = <span class="hljs-built_in">GetAdditionalLight</span>(index, i.worldPos, <span class="hljs-built_in">half4</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));  <br>            <span class="hljs-comment">// 这里乘上阴影衰减</span><br>            color += addLight.color * albedo * <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(addLight.direction, worldNormal)) * addLight.distanceAttenuation * addLight.shadowAttenuation;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">real4</span>(mainLightColor + color + ambient, <span class="hljs-number">1.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出其实现几乎和不带阴影的多光源一样，只有几处不同：</p><ol><li>定义 <strong>_ADDITIONAL_LIGHT_SHADOWS</strong> 关键字，这个关键字决定了在shadow.hlsl中是否计算其他光源的阴影：<br><img src="/article_img/2023-09-10-17-45-13.png"></li><li>使用 <strong>GetAddtionalLight</strong> 函数的重载，这个重载中才计算了阴影衰减，参数中的 <strong>shadowMask</strong> 与计算烘焙光照有关；<br><img src="/article_img/2023-09-10-17-46-49.png"></li><li>在计算其他光源的光照时乘上阴影衰减；</li></ol><h3 id="多光源阴影投射"><a href="#多光源阴影投射" class="headerlink" title="多光源阴影投射"></a>多光源阴影投射</h3><p>每个点光源其shadow map为六个方向：<br><img src="/article_img/2023-09-10-17-52-27.png"><br>每个聚光灯其shadow map为其朝向的方向：<br><img src="/article_img/2023-09-10-17-56-01.png"></p><p>unity中的面光源只能用在烘焙中，就不关心其shadow map了。</p><p>使用和主光源阴影shader中相同的 ShadowCaster pass 效果如下：</p><p><img src="/article_img/2023-09-10-18-00-26.png"></p><p>可以看出效果还可以，已经可以清晰的看到可以投射阴影了，但是其实还有问题，当我们把点光和遮挡物体放到胶囊体的漫反射阴影区域时会看到明显的artifact：</p><p><img src="/article_img/2023-09-10-18-01-22.png"></p><p>这和我们之前提到的<strong>深度偏移</strong>有关，我们为了解决模型投射阴影时的自遮挡问题，引入了深度偏移，正常的深度偏移需要根据光源方向决定向哪个方向进行偏移：</p><table><thead><tr><th><img src="/article_img/2023-09-10-14-14-58.png"></th><th><img src="/article_img/2023-09-10-15-29-15.png"></th></tr></thead></table><p>但是在我们之前实现的ShadowCaster中，深度偏移的函数 <strong>ApplyShadowBias</strong> 中使用的是unity提前定义好的一个光源方向 <strong>_LightDirection</strong>，这个变量是主光源的方向，我们在计算其他光源时也用这个变量显然是不对的，看 ShadowCaster.hlsl中的注释也不知道这两个值是如何得到的；<br><img src="/article_img/2023-09-10-18-21-19.png"><br>在URP的Lit shader中专门定义了一个宏来确定深度偏移中的光源方向应该是哪个，当光源方向不是主光源时，手动计算出光源方向：<br><img src="/article_img/2023-09-10-18-10-58.png"></p><p>这里如何得到正在参与计算的光源位置还不知道怎样自己实现，故就直接使用URP自带的ShadowCaster解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">UsePass <span class="hljs-string">&quot;Universal Render Pipeline/Lit/ShadowCaster&quot;</span> <br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-09-10-18-15-08.png"></p><h1 id="透明物体的阴影"><a href="#透明物体的阴影" class="headerlink" title="透明物体的阴影"></a>透明物体的阴影</h1><p>对于透明物体我们主要处理的是使用 <strong>Alpha Test</strong> 的透明物体的阴影，而使用 <strong>Alpha Blend</strong> 的半透明物体的阴影直接当作不透明物体处理。</p><p>对于接收阴影，透明物体和不透明物体完全相同，对于投射阴影，只需要在shadow caster pass中将不能通过 Alpha Test 的片元舍弃，这样他们在shadow map中的深度就是无限了，从而不会投射阴影。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">pass&#123;<br>    Tags &#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ShadowCaster&quot;</span>&#125;<br>    HLSLPRAGMA<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br>    v2f <span class="hljs-built_in">vert</span>(in a2v v)&#123;<br>        v2f o;<br>        o.positionCS = <span class="hljs-built_in">TransformObjectToHClip</span>(v.positionOS.xyz);<br>        o.uv = <span class="hljs-built_in">TRANSFORM_TEX</span>(v.texcoord, _BaseMap);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>    <span class="hljs-function">real4 <span class="hljs-title">frag</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET&#123;</span><br>        half4 texColor = <span class="hljs-built_in">SAMPLE_TEXTURE2D</span>(_BaseMap, sampler_BaseMap, i.uv);<br>        <span class="hljs-built_in">clip</span>(texColor.a - _Cutoff);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    ENDHLSL<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-09-12-17-37-46.png"></p>]]></content>
    
    
    <categories>
      
      <category>-[TA]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>百人计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百人计划-渲染路径</title>
    <link href="/2023/09/05/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/09/05/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://www.bilibili.com/video/BV1244y1i7oV/">百人计划-延迟渲染管线介绍</a><br><a href="https://zhuanlan.zhihu.com/p/28489928">【《Real-Time Rendering 3rd》 提炼总结】(七) 第七章续 · 延迟渲染(Deferred Rendering)的前生今世</a><br><a href="https://zhuanlan.zhihu.com/p/102134614">延迟渲染</a><br>《Unity Shader入门精要》 第9章 更复杂的光照</p><p>代码标注为C++只是为了会有高亮好看，实际是ShaderLab</p><span id="more"></span><h1 id="前向渲染（Forward-Rendering-Path）"><a href="#前向渲染（Forward-Rendering-Path）" class="headerlink" title="前向渲染（Forward Rendering Path）"></a>前向渲染（Forward Rendering Path）</h1><p>前向渲染是指对每一个物体，先计算所有光源对当前物体的影响，再渲染下一个物体，同时，前向渲染是先着色，再进行深度测试的，导致许多光照计算由于最后不会显示在屏幕上而被浪费掉。前向渲染的主要缺点是，对于多光源场景，渲染效率较低，如有 <strong>n</strong> 个物体，<strong>m</strong> 个场景，需要进行 <strong>n*m</strong> 次光照计算。</p><p><img src="/article_img/2023-09-05-19-12-16.png"></p><h2 id="Unity中的前向渲染"><a href="#Unity中的前向渲染" class="headerlink" title="Unity中的前向渲染"></a>Unity中的前向渲染</h2><p>在unity中想要使用前向渲染，需要设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// build-in</span><br>Tags&#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span>&#125;<br>Tags&#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardAdd&quot;</span>&#125;<br><span class="hljs-comment">// URP</span><br>Tags&#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;UniversalForward&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>在unity内置管线中，前向渲染处理多光源时，一般使用两个Pass，Base Pass和Additional Pass，一个Base Pass只会执行一次，additional pass执行的次数和光源数量有关：</p><p><img src="/article_img/2023-09-05-16-57-46.png"></p><p>在URP管线中，前向渲染处理多光源被整合进单个Pass中，使用Lighting.hlsl中的函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">real4 <span class="hljs-title">frag</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET&#123;</span><br>    <span class="hljs-comment">// compute main light</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// compute additional light</span><br>    real3 addColor = <span class="hljs-built_in">real3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> addLightCount = <span class="hljs-built_in">GetAdditionalLightsCount</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; addLightCount; j++)<br>    &#123;<br>        Light addLight = <span class="hljs-built_in">GetAdditionalLight</span>(j, i.worldPos);<br>        addColor += addLight.color * albedo * <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(addLight.direction, i.worldNormal)) * addLight.distanceAttenuation * addLight.shadowAttenuation;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">real4</span>(addColor + mainColor + ambient, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-09-05-17-33-57.png"><br>左侧为多光源shader，右侧为单光源shader</p><h1 id="延迟渲染（Deferred-Rendering-Path）"><a href="#延迟渲染（Deferred-Rendering-Path）" class="headerlink" title="延迟渲染（Deferred Rendering Path）"></a>延迟渲染（Deferred Rendering Path）</h1><p>延迟渲染是一种针对场景有大量光照时前向渲染效率不高的替代方案，由于前向渲染是先计算着色再进行深度测试，其中的每一个片元都要进行着色计算，造成了大量的性能浪费，延迟渲染就反其道而行之，<strong>先进行深度测试，再进行着色计算</strong>。</p><p><img src="/article_img/2023-09-05-19-13-05.png"></p><p>延迟渲染需要两个pass：</p><ol><li>几何处理阶段：<br>在这个阶段，获取渲染对象的各种几何信息，并存储（渲染）到G-buffer中；</li><li>光照处理阶段：<br>之后对屏幕上的每个像素，取出其G-buffer中的几何数据，进行光照计算；</li></ol><p><img src="/article_img/2023-09-05-19-23-02.png"></p><p>可以看出在延迟渲染中，最后进行光照计算的次数就是屏幕上的像素个数，这样就避免了光源过多时，光照计算次数也跟着变多的问题，并且保证了每一次光照计算都是有用的计算。</p><h1 id="延迟渲染和前向渲染的对比"><a href="#延迟渲染和前向渲染的对比" class="headerlink" title="延迟渲染和前向渲染的对比"></a>延迟渲染和前向渲染的对比</h1><p>延迟渲染流程对比前向渲染流程：</p><table><thead><tr><th><img src="/article_img/2023-09-05-19-26-04.png"></th><th><img src="/article_img/2023-09-05-19-27-25.png"></th></tr></thead></table><p><img src="/article_img/2023-09-05-19-44-02.png"></p><p>延迟渲染缺点产生的原因：</p><ol><li>对MSAA支持不好：其实理论上MSAA是可以支持的，具体看这几篇文章<a href="https://www.zhihu.com/question/366668747/answer/977240803">延迟渲染为什么不支持MSAA？</a>，<a href="https://zhuanlan.zhihu.com/p/135444145">延迟渲染与MSAA的那些事</a></li><li>无法渲染透明物体：因为在渲染透明物体时，要对透明物体排序，从后往前渲染透明物体，并且关闭了ZWrite，在延迟渲染的几何处理阶段，实际上就无法记录到透明物体的深度信息，透明物体就被当作不存在了；</li><li>占用显存带宽：因为延迟渲染需要使用G-buffer，往往还是多个G-buffer，存储这些G-buffer需要占用显存；</li><li>只能使用一种光照模型，因为延迟渲染计算光照的时候已经不知道每个像素是哪一个mesh的了；</li></ol><h1 id="延迟渲染的改进"><a href="#延迟渲染的改进" class="headerlink" title="延迟渲染的改进"></a>延迟渲染的改进</h1><h2 id="延迟光照（LightPre-Pass-Deferred-Lighting）"><a href="#延迟光照（LightPre-Pass-Deferred-Lighting）" class="headerlink" title="延迟光照（LightPre-Pass&#x2F;Deferred Lighting）"></a>延迟光照（LightPre-Pass&#x2F;Deferred Lighting）</h2><p>将G-Buffer的数据结构减小，从而减少带宽占用。</p><h2 id="分块延迟渲染（Tile-BasedDeferred-Rendering-TBDR）（？有点胡言乱语，之后补充）"><a href="#分块延迟渲染（Tile-BasedDeferred-Rendering-TBDR）（？有点胡言乱语，之后补充）" class="headerlink" title="分块延迟渲染（Tile-BasedDeferred Rendering TBDR）（？有点胡言乱语，之后补充）"></a>分块延迟渲染（Tile-BasedDeferred Rendering TBDR）（？有点胡言乱语，之后补充）</h2><p>延迟渲染的瓶颈在于读写 G-buffer，在大量光源下，具体瓶颈将位于每个光源对 G-buffer的读取及与颜色缓冲区（color buffer）混合。但是不是每个片元都受到了全部光源的影响，对每个片元都遍历一次全部光源会产生浪费。于是，就想到把屏幕空间分块，事先计算并记录每个块中收到了那些光源的影响，之后渲染这个块的时候就只需要遍历这些光源即可。</p><p><img src="/article_img/2023-09-05-20-40-23.png"></p><p><a href="https://zhuanlan.zhihu.com/p/92840602">【Metal2研发笔录（二）：传统延迟渲染和TBDR】</a></p><p>对于支持TBDR架构的GPU来说，分块还有一个好处是显著降低带宽。传统的延迟渲染由于G-buffer包含整个屏幕空间的像素，需要将G-buffer写入到系统内存中，之后第二个pass中的片元着色器再从系统内存中读取G-buffer进行计算，而分块之后，由于每个块的G-buffer包含的像素不多，可以直接将G-buffer存储在tile memory中，不需要再用第二个pass，可以直接计算。</p><table><thead><tr><th><img src="/article_img/2023-09-05-21-17-08.png"></th><th><img src="/article_img/2023-09-05-21-16-51.png"></th></tr></thead></table>]]></content>
    
    
    <categories>
      
      <category>-[TA]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>百人计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ALS学习笔记</title>
    <link href="/2023/08/31/ALS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/31/ALS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>参考：<br><a href="https://www.bilibili.com/video/BV12f4y1r71N/?spm_id_from=333.999.0.0&vd_source=93b215eab72b2548f75d0772e28f8b20">虚幻4（UE4） 动画技术 深入浅出 高级运动系统</a><br><a href="https://www.bilibili.com/video/BV1ja41197XQ/?spm_id_from=333.788.recommend_more_video.0&vd_source=93b215eab72b2548f75d0772e28f8b20">关于高级运动系统复刻与解耦</a></p><p>部分基础的动画概念在这篇中： <a href="https://kenny-hoho.github.io/2023/06/14/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/">骨骼动画相关技术概述</a></p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>骨骼动画相关技术概述</title>
    <link href="/2023/08/31/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/31/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>骨骼动画相关技术概述</p><span id="more"></span><p>本文结构参考游戏引擎架构（第二版）第11章 动画系统，专注与骨骼蒙皮动画。</p><p>3D动画早期使用<strong>刚性层阶式动画</strong>，将角色模型直接拆分成大腿、小腿、躯干等部分，直接控制这些部分旋转，但是这种技术会在关节位置产生缝隙。还有一种技术是<strong>每顶点动画技术</strong>，这种动画直接控制角色模型的全部顶点，效果很好但是需要储存全部顶点，在实时游戏中几乎无法使用。<strong>变形目标动画</strong>（morph target animation）与顶点动画类似，但是只存储少量极端姿势（extreme pose）在运行时进行混合，常用于面部动画。</p><p>蒙皮动画兼具了刚性层阶式动画和顶点动画的优点，通过蒙皮技术实现，每个骨骼控制一些顶点的移动，在制作动画时只需要控制骨骼的移动即可，是现在最常用的3D动画技术。</p><p><img src="/article_img/2023-06-15-13-51-13.png"></p><h1 id="骨骼与姿势"><a href="#骨骼与姿势" class="headerlink" title="骨骼与姿势"></a>骨骼与姿势</h1><p>骨骼（skeleton）由骨头（bone）组成，骨头几乎只指关节（joint），因为骨头是刚体几乎不会改变形状，动画师通过直接控制关节构造一个个姿势（pose），这些姿势连续播放就形成了动画。</p><h2 id="骨骼层级结构"><a href="#骨骼层级结构" class="headerlink" title="骨骼层级结构"></a>骨骼层级结构</h2><p>骨骼都有一个根（root），所有的其他骨头都是这个根骨的子物体：<br><img src="/article_img/2023-06-15-13-59-08.png"></p><p>典型的骨骼数据结构：<br><img src="/article_img/2023-06-15-14-01-44.png"></p><p>bones或joint中存储了骨骼的名字，绑定姿势的逆变换（将模型坐标转换到该骨骼下的局部坐标，这里存储为4*3的矩阵应该是为了节省存储空间，因为最后一行为（0，0，0，1）），父索引（索引可方便查找和存储）。</p><h2 id="姿势"><a href="#姿势" class="headerlink" title="姿势"></a>姿势</h2><p>把角色摆出各种姿势，插值并播放就产生了动画，每个姿势由每个关节的 <strong>SQT（scale，quaternion，translation）</strong> 表示。</p><table><thead><tr><th><img src="/article_img/2023-06-15-14-07-41.png"></th><th><img src="/article_img/2023-06-15-14-07-52.png"></th></tr></thead></table><h3 id="绑定姿势"><a href="#绑定姿势" class="headerlink" title="绑定姿势"></a>绑定姿势</h3><p>一般为 T-pose 或 A-pose，表示网格绑定到骨骼上时的姿势，也叫参考姿势（reference pose）或放松姿势（rest pose）。</p><table><thead><tr><th><img src="/article_img/2023-06-15-14-13-24.png"></th><th><img src="/article_img/2023-06-15-14-18-05.png"></th></tr></thead></table><h3 id="局部姿势"><a href="#局部姿势" class="headerlink" title="局部姿势"></a>局部姿势</h3><p>最常见的关节姿势是相对于父关节来指定的，有时使用局部姿势描述相对于父关节的姿势，即关节局部坐标中的 SQT 变换。</p><h3 id="全局姿势"><a href="#全局姿势" class="headerlink" title="全局姿势"></a>全局姿势</h3><p>全局姿势指将关节姿势表示为模型空间或者世界空间，通过从该关节遍历至根关节并乘上每个关节的局部姿势算出。<strong>全局姿势在计算蒙皮矩阵时需要</strong>，一般存储在上面的关节数据结构中的<strong>绑定姿势的逆变换</strong>。<br>每个关节的局部姿势就是局部坐标系，局部姿势的变化就是局部坐标系的变化，因此参照<strong>基变换</strong>的概念，可有如下结论，即乘上局部姿势（局部坐标系的基）可以将局部坐标转换到全局坐标（<strong>参照3Blue1Brown的线性代数的本质基变换章节</strong>）<br><img src="/article_img/2023-06-15-14-30-10.png"></p><h1 id="蒙皮绑定"><a href="#蒙皮绑定" class="headerlink" title="蒙皮绑定"></a>蒙皮绑定</h1><p>每个顶点一般绑定至4或4的倍数个关节，其数据结构为：<br><img src="/article_img/2023-06-15-15-32-15.png"><br><strong>这里的position是模型空间（废话…）</strong></p><table><thead><tr><th><img src="/article_img/2023-06-15-15-40-35.png"></th><th><img src="/article_img/2023-06-15-15-44-37.png"></th></tr></thead></table><p>蒙皮可以使顶点跟随骨骼移动的原理如上图所示，先将顶点转换至绑定到的关节空间，因为关节移动时，顶点相对于关节的位置不变，移动关节之后可以将顶点再转换回模型空间，就完成了顶点在模型空间的移动。</p><h2 id="线性混合蒙皮（Linear-Blend-Skining）"><a href="#线性混合蒙皮（Linear-Blend-Skining）" class="headerlink" title="线性混合蒙皮（Linear Blend Skining）"></a>线性混合蒙皮（Linear Blend Skining）</h2><p><img src="/article_img/2023-06-15-15-47-19.png"><br>对每个顶点来说，其被绑定到的每个关节对他的影响程度不同，设定每个关节的权重，就可以通过加权算出顶点受这些关节共同影响后的位置。这就是<strong>线性混合蒙皮（Linear Blend Skinning）</strong></p><p><img src="/article_img/2023-06-15-16-16-44.png"></p><p>但是线性混合不能维持体积，会产生如下的Candy-Wrapper Artifact<br><img src="/article_img/2023-06-15-15-56-55.png"></p><h2 id="双四元数蒙皮（Dual-Quaternion-Skinning）"><a href="#双四元数蒙皮（Dual-Quaternion-Skinning）" class="headerlink" title="双四元数蒙皮（Dual-Quaternion Skinning）"></a>双四元数蒙皮（Dual-Quaternion Skinning）</h2><table><thead><tr><th><img src="/article_img/2023-06-15-16-02-40.png"></th><th><img src="/article_img/2023-06-16-12-43-57.png"></th></tr></thead></table><h2 id="如何解决LBS的问题"><a href="#如何解决LBS的问题" class="headerlink" title="如何解决LBS的问题"></a>如何解决LBS的问题</h2><h3 id="添加修型骨骼"><a href="#添加修型骨骼" class="headerlink" title="添加修型骨骼"></a>添加修型骨骼</h3><p>UE5的小白人就添加了许多修型骨骼，通过ControlRig实现修型。</p><table><thead><tr><th><img src="/article_img/DrivenJoint.gif"></th><th><img src="/article_img/DrivenJoint1.gif"></th></tr></thead></table><h3 id="使用blendshape-morph-target"><a href="#使用blendshape-morph-target" class="headerlink" title="使用blendshape (morph target)"></a>使用blendshape (morph target)</h3><p>对于对动画质量要求更高的3A游戏，添加再多的修型骨骼也较难达到模拟真实的肌肉运动，因此还是使用顶点动画的方法，建模师提前制作多个不同关节运动角度时的肌肉模型，之后在骨骼运动时读取这个结果。<br><img src="/article_img/2023-06-16-13-00-52.png"></p><p>如何驱动BS：</p><ol><li>动画师手K</li><li>JCM(Joint Controlled Morphs)骨骼驱动变形，等于Maya的PSD（Pose space deformations），用骨骼驱动morphs变形</li><li>RBF驱动（之后详细讲）</li></ol><p>PSD的相关技术文章：<br><a href="https://zhuanlan.zhihu.com/p/456538362">Pose Space Deformation——从实践到原理再到实践</a><br><a href="https://zhuanlan.zhihu.com/p/391409060">基于径向基函数的Pose Space Deformation</a></p><p>同时还需要考虑的问题是顶点动画开销太大，还是希望可以使用骨骼驱动，于是希望将blendshape通过某种方法烘焙到骨骼上，就有了蒙皮分解技术（例如SSDR-线性蒙皮分解）</p><h2 id="蒙皮分解（蒙皮动画的逆运算）"><a href="#蒙皮分解（蒙皮动画的逆运算）" class="headerlink" title="蒙皮分解（蒙皮动画的逆运算）"></a>蒙皮分解（蒙皮动画的逆运算）</h2><p>假如有全身所有顶点的每帧的位置信息，能不能反过来推算出如果使用骨骼动画如何达成同样的效果。即假设我们给定骨骼数量，那么能不能推算出骨骼每一帧应该在什么位置，旋转如何（骨骼的全局姿势），以及每一个顶点应该绑定哪根骨骼，权重是多少。</p><table><thead><tr><th><img src="/article_img/2023-06-15-15-44-37.png"></th><th><img src="/article_img/2023-06-15-15-47-19.png"></th></tr></thead></table><p>SSDR是一个优化问题，输入是所有顶点的动画（每一帧来看就是所有顶点的模型空间的坐标），需要拟合出蒙皮计算公式中的 <strong>顶点蒙皮权重，$C_{j \to m}$（每帧的全局姿势）</strong></p><p>原论文：<a href="http://graphics.cs.uh.edu/ble/papers/2012sa-ssdr/">Smooth Skinning Decomposition with Rigid Bones</a><br><a href="https://zhuanlan.zhihu.com/p/384760680">知乎-线性蒙皮分解(SSDR)</a></p><h2 id="ML-Deformer-拟合morph-target"><a href="#ML-Deformer-拟合morph-target" class="headerlink" title="ML Deformer (拟合morph target)"></a>ML Deformer (拟合morph target)</h2><p>SSDR归根结底还是想通过LBS来驱动顶点，但是有一些复杂的BlendShape不是线性变化的，不能用LBS驱动，这种方法解算出来的结果也就不太理想了。于是有了专门针对与BlendShape的拟合方法。</p><p><a href="https://www.youtube.com/watch?v=OmMi6E0EkQw">MetaHuman Framework &amp; Machine Learning for Next-Gen Character Deformation | GDC 2023</a><br><a href="https://zhuanlan.zhihu.com/p/632849525">UE5 机器学习变形器解析</a></p><p>UE5推出的新功能ML Deformer借助Deformer Graph和机器学习完成对复杂的非线性顶点运动的拟合，比如肌肉模拟和布料模拟。工作流程如下：</p><p><img src="/article_img/2023-09-05-14-03-52.png"></p><p>首先在Maya中完成绑定，使用UE官方提供的Maya插件设置每个关节的活动范围限制，之后生成随机动作（ROM-Random of Motion），之后在Houdini中用离线的方法进行肌肉模拟并生成 abc文件（顶点动画），在UE中训练。。</p><p>下图左侧模型身上的绿色信息就是使用LBS蒙皮的模型和Houdini中模拟出来的模型的顶点坐标的差值，这些差值被提供给神经网络，经过训练，更新原本LBS蒙皮的权重来拟合肌肉模拟的结果。</p><p><img src="/article_img/2023-09-05-14-12-36.png"></p><h2 id="自动蒙皮"><a href="#自动蒙皮" class="headerlink" title="自动蒙皮"></a>自动蒙皮</h2><p>Siggraph2021: <a href="https://peizhuoli.github.io/neural-blend-shapes/index.html">Learning Skeletal Articulations with Neural Blend Shapes</a> 类似ML Deformer?</p><p>Siggraph2019: <a href="https://github.com/FuxiCV/NeuroSkinning#:~:text=NeuroSkinning%3A%20Automatic%20Skin%20Binding%20for%20Production%20Characters%20with,skin%20weights%20for%20skeleton-based%20deformation%20of%20production%20characters.">NeuroSkinning: Automatic Skin Binding for Production Characters with Deep Graph Networks</a></p><h1 id="动画混合"><a href="#动画混合" class="headerlink" title="动画混合"></a>动画混合</h1><h2 id="线性插值混合"><a href="#线性插值混合" class="headerlink" title="线性插值混合"></a>线性插值混合</h2><p><img src="/article_img/2023-06-16-14-57-08.png"><br><img src="/article_img/2023-06-16-14-58-35.png"><br>在线性插值时，直接对于矩阵插值不可行，因此一般对 SQT 格式的局部姿势插值，其中尤其注意对旋转的插值，一般使用四元数LERP 或 SLEAP（球面线性插值）</p><p>下面列举几种线性插值混合的应用</p><h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><p>淡入淡出是为了解决不同动画片段间的过渡问题，防止动画出现跳变。<br><img src="/article_img/2023-06-16-15-05-40.png"><br>上图使用贝塞尔曲线的混合因子，可以达到更好的淡入淡出效果。</p><h2 id="惯性化插值"><a href="#惯性化插值" class="headerlink" title="惯性化插值"></a>惯性化插值</h2><p><a href="https://www.gdcvault.com/play/1025165/Inertialization-High-Performance-Animation-Transitions">2018GDC: Inertialization-High-Performance-Animation-Transitions</a><br><a href="https://zhuanlan.zhihu.com/p/390476167">惯性插值-优异的动画过渡算法</a><br><a href="https://docs.unrealengine.com/5.2/zh-CN/animation-blueprint-blend-nodes-in-unreal-engine/#%E6%83%AF%E6%80%A7%E5%8C%96">UE5文档-惯性化</a></p><p>经典的插值算法都需要两个片段（源片段和目标片段），在插值过程中，这两个片段必须保存在内存中，并且如果有在片段中存在其他复杂运算就会对性能造成很大的开销。在日常生活中，我们人体的动作过渡其实也不考虑之前的源动作是什么，而是直接过渡到下一个姿势。因此就希望有一种方法可以实现只考虑目标动作不考虑源动作的过渡方法。</p><p>惯性化过渡不考虑源动作，只需要记录源动作最后一帧的变换，速度，加速度等值，利用五次多项式（<strong>因为五次多项式可以保证加速度是连续的</strong>）直接拟合出过渡曲线。如果直接进行拟合当源动作速度过大时，会出现overshoot的情况，为此将 $t_1$ 时刻的 <strong>跃度</strong>（加速度的导数）设置为零，计算出不会发生overshoot的最小 $t_1$ ，将目标片段开始播放的时刻提前到 $t_1$ 之前。</p><table><thead><tr><th><img src="/article_img/2023-08-31-17-32-27.png"></th><th><img src="/article_img/2023-08-31-17-32-45.png"></th></tr></thead></table><p><img src="/article_img/2023-08-31-16-09-40.png"> </p><p>动画片段的过渡一般都是向量和四元数间的变换，因此在拟合过渡曲线之前还需要对向量和四元数做处理，将其都转换为标量。这里将向量的方向和大小分开，将四元数的旋转轴和角度分开：</p><table><thead><tr><th><img src="/article_img/2023-08-31-17-39-20.png"></th><th><img src="/article_img/2023-08-31-17-39-56.png"></th></tr></thead></table><p>在UE5中已经支持惯性化过渡，在状态机切换，混合节点，分层动画都可以设置一个惯性化请求，在最后输出动作之前添加惯性化节点。</p><table><thead><tr><th><img src="/article_img/2023-08-31-17-44-24.png"></th><th><img src="/article_img/2023-08-31-17-49-37.png"></th></tr></thead></table><h2 id="骨骼分部混合"><a href="#骨骼分部混合" class="headerlink" title="骨骼分部混合"></a>骨骼分部混合</h2><p>在线性插值混合时，屏蔽部分关节，不进行线性插值即可。一般需要创建一个遮罩，在unity中的Avatar Mask（混合模式为override）</p><p>但是这种方法太过生硬，因为一般人类不可能只有一部分关节移动，这些关节的移动都会带动全身移动，单纯进行骨骼分布混合无法实现这种效果。</p><h2 id="加法混合"><a href="#加法混合" class="headerlink" title="加法混合"></a>加法混合</h2><p>加法混合的原理是记录从参考姿势到 <strong>“加法片段”（也叫“区别片段”）</strong> 的变换，再把这个变换应用到其他需要进行加法混合的片段上，就可以实现很多有趣的姿势和动作变换，例如：将表示疲惫的加法片段应用于跑步片段就可以得到疲惫地跑步地动画。在unity中的Avatar Mask（混合模式为additive）</p><table><thead><tr><th><img src="/article_img/2023-06-18-14-09-12.png"></th><th><img src="/article_img/2023-06-18-14-09-20.png"></th></tr></thead></table><p>$D_j$ 表示区别片段，$S_j$ 表示来源动画（也就是例子中的疲惫状态的动画），$R_j^{-1}$ 表示参考姿势的逆变换（D&#x3D;S-R用矩阵表示减法就是乘逆矩阵）， $A_j$ 表示经过变换后的结果动画（疲惫地跑步）， $T_j$ 表示需要被应用的目标动画（跑步动画）。</p><p><img src="/article_img/2023-08-31-12-39-06.png"><br>上图为在虚幻引擎中叠加动画的设置，这里需要选择的基础姿势就是参考姿势，该叠加动画就是来源动画和该参考姿势的 “差值”。</p><p>叠加动画类型分为：<strong>局部空间（Local Space）</strong> 和 <strong>网格体空间（Mesh Space）</strong>，他们的区别在与网格体空间可以保证无论当前骨骼的朝向如何，应用叠加动画之后的结果和网格体空间下的结果一致：<br><img src="/article_img/2023-08-31-13-06-05.png"></p><h2 id="动画片段混合中的同步问题"><a href="#动画片段混合中的同步问题" class="headerlink" title="动画片段混合中的同步问题"></a>动画片段混合中的同步问题</h2><p><a href="https://docs.unrealengine.com/5.2/zh-CN/animation-sync-groups-in-unreal-engine/">Unreal文档-同步组</a></p><p>在混合不同的动画片段时，由于动画片段的长度不一定相同，就会导致某些时刻的混合很不自然，在角色行走到跑步的过渡中尤为明显。（UE5的混合空间似乎自动进行了同步）</p><table><thead><tr><th><img src="/article_img/SyncOFF.gif"></th><th><img src="/article_img/SyncON.gif"></th></tr></thead></table><p>通过同步组可以将两个动画片段的长度变成一样的，可以消除这种不自然感（但是就要注意正在混合的两个片段需要有相似的步态以确保脚步的一致，比如走路和跑步都是先迈左脚并且脚接触地面次数相同）</p><p>或者使用同步标识，显式的标记左右脚：<br><img src="/article_img/2023-08-31-14-13-24.png"></p><h1 id="FK和IK"><a href="#FK和IK" class="headerlink" title="FK和IK"></a>FK和IK</h1><p>FK是Forward Kinematic 前向运动学，IK是Inverse Kinematic 逆向运动学，直观理解假如我们需要用左手拿一个苹果（假设可以拿到），FK需要我们指定从肩膀到左手的每个关节的旋转，IK则是直接将左手固定到苹果处，再计算我们的胳膊上的每个关节要如何旋转。<strong>IK可以看作一个优化问题</strong></p><table><thead><tr><th><img src="/article_img/2023-06-18-15-31-33.png"></th><th><img src="/article_img/2023-06-18-15-37-23.png"></th></tr></thead></table><p><strong>IK可能无解，可能有一个或多个解。</strong><br><img src="/article_img/2023-06-18-15-34-47.png"></p><p>对于IK问题需要注意的有两点：</p><ol><li>IK问题有没有解</li><li>设置IK的终止条件，防止陷入无限循环</li></ol><h2 id="Two-bone-IK"><a href="#Two-bone-IK" class="headerlink" title="Two-bone IK"></a>Two-bone IK</h2><p><img src="/article_img/2023-06-18-15-40-06.png"></p><p>对于TwoBoneIK，可以使用解析法进行计算，由于三个点确定一个平面，所以需要增加一个控制点（也就是UE4中的PoleVector 极坐标点）来解三维空间内的旋转角度。</p><p><img src="/article_img/TwoBoneIK.gif"></p><p>Unreal中的TwoBoneIK节点。</p><h2 id="CCDIK"><a href="#CCDIK" class="headerlink" title="CCDIK"></a>CCDIK</h2><p>循环坐标推演（Cyclic coordinate descent）<br><img src="/article_img/2023-06-18-16-01-57.png"></p><p>计算简单，只需要点乘叉乘，但其会有较强的倾向性，导致某些动作不自然，一般会对CCD添加约束。</p><h2 id="雅可比逆矩阵法"><a href="#雅可比逆矩阵法" class="headerlink" title="雅可比逆矩阵法"></a>雅可比逆矩阵法</h2><p>比较复杂，是一种梯度下降的方法</p><h2 id="FABRIK"><a href="#FABRIK" class="headerlink" title="FABRIK"></a>FABRIK</h2><p>Forward and backward reaching inverse kinematics（前向和后向到达IK）<br><img src="/article_img/2023-06-18-16-54-06.png"><br>原理如图，看上去与CCD类似，但是FABRIK关注的是位置而不是旋转。FABRIK先从末端出发到达IK目标，依次反推回根节点，再让根节点到达初始点，依次反推至末端受动器，循环进行到终止条件即可。</p><p>FABRIK计算简单，并且适用于解决多个末端受动器的问题（如手指，双手指向同个目标），CCD和雅各比矩阵解决起来要困难一些。FABRIK只需要再sub-bases处计算平均值再向根节点迭代即可。<br><img src="/article_img/2023-06-18-17-03-10.png"></p><p><a href="https://www.sciencedirect.com/science/article/pii/S1524070311000178">原论文：FABRIK: A fast, iterative solver for the Inverse Kinematics problem</a></p><h1 id="动画重定向"><a href="#动画重定向" class="headerlink" title="动画重定向"></a>动画重定向</h1><table><thead><tr><th><img src="/article_img/retargeting.gif"></th><th><img src="/article_img/2023-07-06-15-45-10.png"></th></tr></thead></table><p>Siggraph2020: <a href="https://deepmotionediting.github.io/retargeting">Skeleton-Aware Networks for Deep Motion Retargeting</a></p><p>动画重定向技术是将一个角色的动画数据应用于另一个角色，使其看起来像是原始角色在执行相同的动作。最基本的动画重定向是当两套骨骼数目一致结构一致，把动画姿势与参考姿势的差异应用到目标骨架上。</p><p>实际应用：</p><ol><li>Unity中是利用Avatar将两套骨骼映射到同一套Unity自己定义的模板骨骼上</li><li>UE中是允许手动设置骨骼的对应关系，UE5使用IK Rig建立约束关系的对应关系</li></ol><h1 id="数据驱动的角色动画"><a href="#数据驱动的角色动画" class="headerlink" title="数据驱动的角色动画"></a>数据驱动的角色动画</h1><p><a href="/_posts/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%92%E8%89%B2%E5%8A%A8%E7%94%BB-PFNN.md">Phase-Functional Neural Networks for Character Control</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://games-105.github.io/">Games-105</a><br><a href="https://zhuanlan.zhihu.com/p/616173667">建立下个时代的高清游戏美术资源生产管线(五):绑定篇-绑定基本概念</a><br><a href="https://zhuanlan.zhihu.com/p/391409060">基于径向基函数的Pose Space Deformation</a><br><a href="https://zhuanlan.zhihu.com/p/499405167">【游戏开发】逆向运动学（IK）详解</a><br><a href="https://zhuanlan.zhihu.com/p/115155715">[合集] Data-Driven Character Motion Synthesis</a></p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百人计划-透明效果</title>
    <link href="/2023/08/05/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/"/>
    <url>/2023/08/05/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<br>《Unity Shader入门精要》 第8章 透明效果</p><p>代码标注为C++只是为了会有高亮好看，实际是ShaderLab</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/article_img/2023-08-06-14-43-53.png"></p><p>我们通常使用两种方法来实现透明效果：</p><ol><li>使用透明度测试(Alpha Test), 这种方法其实无法得到真正的半透明效果；</li><li>透明度混合 (Alpha Blending)</li></ol><h1 id="透明度测试（Alpha-Test）"><a href="#透明度测试（Alpha-Test）" class="headerlink" title="透明度测试（Alpha Test）"></a>透明度测试（Alpha Test）</h1><p>透明度测试简单粗暴，只要个片元的透明度不满足条件（通常是小千某个阙值），那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体的处理方式来处理它，即进行深度测试、深度写入等。</p><p>透明度测试通过函数 <strong>void clip(float4 x)</strong> 实现剔除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clip</span><span class="hljs-params">(float4 x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">any</span>(x &lt; <span class="hljs-number">0</span>))<br>        discard;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的shader实现要点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++">Shader <span class="hljs-string">&quot;...&quot;</span>&#123;<br>    Properties&#123;<br>        _Color(<span class="hljs-string">&quot;Color&quot;</span>, color)=(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>        _MainTex(<span class="hljs-string">&quot;Tex&quot;</span>, <span class="hljs-number">2</span>D)=<span class="hljs-string">&quot;white&quot;</span>&#123;&#125;<br>        _AlphaCutoff(<span class="hljs-string">&quot;Alpha Cutoff&quot;</span>, <span class="hljs-built_in">Range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))=<span class="hljs-number">0.5</span> <span class="hljs-comment">// 因为Alpha通道是在0到1的范围</span><br>    &#125;<br>    SubShader&#123;<br>        Tags&#123;<span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;AlphaTest&quot;</span> <span class="hljs-string">&quot;IgnoreProjector&quot;</span>=<span class="hljs-string">&quot;True&quot;</span> <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;TransparentCutout&quot;</span>&#125;<br><br>        Pass&#123;<br>            <span class="hljs-comment">//...</span><br>            fixed4 <span class="hljs-built_in">frag</span>(in v2f i) : SV_TARGET&#123;<br>                fixed4 texColor = <span class="hljs-built_in">tex2D</span>(_MainTex, i.uv);<br>                <span class="hljs-comment">// Alpha Test</span><br>                <span class="hljs-built_in">clip</span>(texColor.a - _AlphaCutoff);<br><br>                <span class="hljs-comment">// albedo</span><br>                <span class="hljs-comment">// ...</span><br>                <span class="hljs-comment">// ambient</span><br>                <span class="hljs-comment">// ...</span><br>                <span class="hljs-comment">// diffuse</span><br>                <span class="hljs-comment">// ...</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">fixed4</span>((ambient+diffuse), <span class="hljs-number">1.0</span>);<br>            &#125;<br>            <span class="hljs-comment">//...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单归纳：</p><ol><li>注意设置渲染队列</li><li>注意 <strong>texColor</strong> 要使用 <strong>fixed4</strong> 类型定义接收alpha通道的值</li><li>使用 <strong>clip</strong> 进行透明度测试</li></ol><p><img src="/article_img/2023-08-06-14-45-37.png"></p><h2 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h2><p>真正的透明物体还可以看到物体内部的细节，显然上面的透明效果是错误的，因此就需要进行双面渲染。产生上面的效果的原因是Unity会 <strong>自动进行背面剔除</strong> 来提高渲染效率，不渲染背面，我们只需要关闭背面剔除即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">Pass&#123;<br>    <span class="hljs-comment">// 关闭背面剔除</span><br>    Cull off<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-08-06-14-55-43.png"></p><h1 id="透明度混合（Alpha-Blend）"><a href="#透明度混合（Alpha-Blend）" class="headerlink" title="透明度混合（Alpha Blend）"></a>透明度混合（Alpha Blend）</h1><p>透明度测试的方法很简单，只需要使用clip函数进行剔除即可，但是这种方法过于极端，只能得到完全不透明和完全透明两种效果，这在现实中是不太可能出现的。因此就引入了透明度混合的方法。</p><p>透明度混合的原理是：<strong>使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到最终的颜色。</strong></p><h2 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h2><p>在进行透明效果的渲染时，渲染顺序就尤为重要，在渲染不透明物体时，<strong>深度写入</strong>（ZWrite）是默认打开的，这样就实现了正确的物体间遮挡关系，但是在渲染透明效果时，必须关闭深度写入，否则就会因为透明物体较其后方的物体深度较近而不渲染透明物体后的物体。</p><p>透明效果的原理是，对于透明效果的shader <strong>关闭深度写入（ZWrite Off）</strong>，这样透明物体的深度就一直是默认的最大值，无法遮挡任何物体。但是关闭深度写入之后就需要非常注意渲染的顺序。</p><p><img src="/article_img/2023-08-06-14-13-22.png"></p><p>如图8.1，如果先渲染透明物体A，A不会写入深度缓冲，当之后渲染非透明物体B时，B开启了深度写入发现深度缓冲还是默认值，就会同时将自己的深度写入深度缓冲，将自己的颜色写入颜色缓冲，就<strong>完全覆盖</strong>了透明物体A。<br>如图8.2，对于两个透明物体的情况，如果先渲染物体A，A发现深度缓冲是默认值，将自己的颜色写入颜色缓冲，但是不会写入深度缓冲；渲染物体B时，B也发现深度缓冲时默认值，会将自己的颜色和颜色缓冲中的颜色进行混合（使用透明度混合进行渲染时），看起来就是<strong>B在A前面</strong>。</p><p>因此只要渲染的物体中有透明效果的物体，就需要注意渲染顺序。Unity中使用 <strong>渲染队列（Render Queue）</strong> 定义渲染顺序：<br><img src="/article_img/2023-08-06-14-22-29.png"></p><p>可以发现对于使用了透明度混合的方法渲染的透明物体需要按照 <strong>从后往前</strong> 的顺序依次渲染，原因我们已经分析过了，但是这个<strong>从后往前</strong>其实并不好判断，如图：<br><img src="/article_img/2023-08-06-14-24-42.png"></p><p>一般我们需要让模型尽量是凸面体，并且可以考虑将复杂的模型拆分成可以独立排序的多个子模型，但是一般游戏引擎还是使用最简单的判断方式，忽略了这些问题。</p><h2 id="混合命令"><a href="#混合命令" class="headerlink" title="混合命令"></a>混合命令</h2><p>实现混合需要使用unity内置的 <strong>Blend</strong> 命令：<br><img src="/article_img/2023-08-06-15-00-14.png"></p><p>如果使用了除Blend Off之外的混合命令，Unity会自动将混合模式开启，但是其他一些图形API中还需要手动开启。</p><p>Blend命令后的参数是混合因子，用来设定混合公式，Unity中有如下的混合因子：<br><img src="/article_img/2023-08-06-15-07-18.png"></p><p>BlendOp BlendOperation命令允许使用加法外的方法进行混合，支持如下操作（还有Max和Min类似）：<br><img src="/article_img/2023-08-06-15-08-41.png"></p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>使用透明度混合实现透明效果的Shader关键点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++">Shader<span class="hljs-string">&quot;...&quot;</span><br>&#123;<br>    Properties&#123;<br>        _Color(<span class="hljs-string">&quot;Color&quot;</span>, color)=(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>        _MainTex(<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D)=<span class="hljs-string">&quot;white&quot;</span>&#123;&#125;<br>        _AlphaScale(<span class="hljs-string">&quot;AlphaScale&quot;</span>, <span class="hljs-built_in">Range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))=<span class="hljs-number">0.5</span><br>    &#125;<br>    SubShader&#123;<br>        Tags&#123;<span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span> <span class="hljs-string">&quot;IgnoreProjector&quot;</span>=<span class="hljs-string">&quot;True&quot;</span> <span class="hljs-string">&quot;RanderType&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span>&#125;<br><br>        Pass&#123;<br>            Tags&#123;<span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span>&#125;<br><br>            <span class="hljs-comment">// 关闭深度写入，设置混合因子</span><br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            <span class="hljs-comment">// ...</span><br>            fixed4 <span class="hljs-built_in">frag</span>(in v2f i) : SV_TARGET&#123;<br>                fixed4 texColor = <span class="hljs-built_in">tex2D</span>(_MainTex, i.uv);<br>                <span class="hljs-comment">// albedo</span><br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                <span class="hljs-comment">// ambient</span><br>                <span class="hljs-comment">// ...</span><br>                <span class="hljs-comment">// diffuse</span><br>                <span class="hljs-comment">// ...</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">fixed4</span>((ambient+diffuse), texColor.a * _AlphaScale);<br>            &#125;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单归纳：</p><ol><li>设置渲染队列</li><li>关闭深度写入，设置混合因子</li><li>注意 <strong>texColor</strong> 使用fixed4接收Alpha通道</li><li>返回时的透明通道使用纹理的透明度（<strong>texColor.a</strong>）与透明度（ <strong>_AlphaScale</strong> ）相乘，这里的透明度只有开启混合才有效。</li></ol><p><img src="/article_img/2023-08-06-15-31-46.png"></p><h2 id="双面渲染的透明效果-1"><a href="#双面渲染的透明效果-1" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h2><p>与使用透明度测试类似，由于背面剔除，透明效果实际上是错误的，但是由于透明度混合关闭了深度写入，导致无法得到正确的深度信息，如果简单的关闭背面剔除，并不能得到正确的渲染结果。因此使用两个Pass分别渲染物体的背面和正面，<strong>注意要先渲染物体的背面再渲染正面！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">Shader<span class="hljs-string">&quot;...&quot;</span>&#123;<br>    Properties&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    SubShader&#123;<br>        Tags&#123;<span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span> <span class="hljs-string">&quot;IgnoreProjector&quot;</span>=<span class="hljs-string">&quot;True&quot;</span> <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span>&#125;<br>        Pass&#123;<br>            <span class="hljs-comment">// 剔除正面，先渲染背面</span><br>            Cull Front<br>            <span class="hljs-comment">//...</span><br>        &#125;<br>        Pass&#123;<br>            <span class="hljs-comment">// 剔除背面，后渲染正面</span><br>            Cull Back<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-08-06-15-31-17.png"></p><h2 id="开启深度写入的透明度混合半透明效果"><a href="#开启深度写入的透明度混合半透明效果" class="headerlink" title="开启深度写入的透明度混合半透明效果"></a>开启深度写入的透明度混合半透明效果</h2><p>由于我们进行透明度混合时关闭了深度写入，导致对于一些复杂形状分不清物体内部的遮挡关系，会得到看起来奇怪的渲染结果：<br><img src="/article_img/2023-08-06-15-34-25.png"></p><p>对于这种情况，我们使用两个Pass渲染，第一个Pass仅开启深度写入将深度正确的记录到深度缓冲中，而不向颜色缓冲写入任何颜色；第二个Pass按照普通的透明度混合实现即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">Shader<span class="hljs-string">&quot;...&quot;</span>&#123;<br>    SubShader&#123;<br>        <span class="hljs-comment">// ...</span><br>        Pass&#123;<br>            ZWrite On<br>            <span class="hljs-comment">// 设置颜色通道的写掩码</span><br>            ColorMask <span class="hljs-number">0</span> <span class="hljs-comment">// ColorMask RGB | A | 0 | 其他RGBA的任意组合</span><br>        &#125;<br>        Pass&#123;<br>            <span class="hljs-comment">// ...</span><br>            ZWrite Off<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-08-06-15-41-07.png"></p><p>“看上去”正确不少，但是还是不能透过物体看到内部。因为第一个Pass将深度写进深度缓冲后已经将背面和被遮挡的片元剔除了。</p>]]></content>
    
    
    <categories>
      
      <category>-[TA]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>百人计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百人计划-纹理</title>
    <link href="/2023/07/15/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E7%BA%B9%E7%90%86/"/>
    <url>/2023/07/15/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E7%BA%B9%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://www.bilibili.com/video/BV1sA411N7z3/?spm_id_from=333.999.0.0&vd_source=93b215eab72b2548f75d0772e28f8b20">百人计划-纹理基础</a><br>《Unity Shader入门精要》 第7章 基础纹理</p><p>代码标注为C++只是为了会有高亮好看，实际是ShaderLab</p><span id="more"></span><h1 id="纹理是什么"><a href="#纹理是什么" class="headerlink" title="纹理是什么"></a>纹理是什么</h1><p>纹理可以避免复杂的建模，给予模型相对较好的细节的一种技术。通过纹理映射的方式纹理贴图上的细节“黏”在模型上，伪造出丰富的细节。纹理直观来讲是一张图片，但是纹理说到底是一个<strong>容器</strong>，因为纹理不仅仅能存储颜色信息，还可以存储深度信息，法线信息等等，还可以存储一个函数来动态计算。</p><h1 id="纹理过大过小问题"><a href="#纹理过大过小问题" class="headerlink" title="纹理过大过小问题"></a>纹理过大过小问题</h1><p>这部分更详细的讲解在 <a href="/_posts/Games101-4-%E7%9D%80%E8%89%B2.md">Games101-着色</a> 的笔记</p><h2 id="纹理分辨率过小"><a href="#纹理分辨率过小" class="headerlink" title="纹理分辨率过小"></a>纹理分辨率过小</h2><p><img src="/article_img/2023-07-10-17-05-20.png"></p><p>几种采样方法：</p><ol><li>最近邻</li><li>双线性插值</li><li>三线性插值</li></ol><table><thead><tr><th><img src="/article_img/2022-08-29-18-33-20.png"></th><th><img src="/article_img/2022-08-29-18-52-05.png"></th></tr></thead></table><h2 id="纹理分辨率过大"><a href="#纹理分辨率过大" class="headerlink" title="纹理分辨率过大"></a>纹理分辨率过大</h2><h3 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h3><table><thead><tr><th><img src="/article_img/2022-08-29-18-41-41.png"></th><th><img src="/article_img/2022-08-29-18-41-51.png"></th></tr></thead></table><p>多级渐远纹理技术将原纹理提前用滤波处理来得到很多更小的图像， 形成了一个图像金字塔，每一层都是对上一层图像降采样的结果。 这样在实时运行时， 就可以快速得到结果像素， 如当物体远离摄像机时，可以直接使用较小的纹理。但缺点是需要使用一定的空间用于存储这些多级渐远纹理，通常会多占用33%的内存空间。 </p><table><thead><tr><th><img src="/article_img/2023-07-10-17-07-48.png"></th><th><img src="/article_img/2023-07-10-17-08-25.png"></th></tr></thead></table><h3 id="Ripmap"><a href="#Ripmap" class="headerlink" title="Ripmap"></a>Ripmap</h3><h1 id="凹凸映射（Bump-mapping）"><a href="#凹凸映射（Bump-mapping）" class="headerlink" title="凹凸映射（Bump mapping）"></a>凹凸映射（Bump mapping）</h1><p>凹凸映射的目的是使用 张纹理来修改模型表面的法线，以便为模型提供更多的细节。这种方法不会真的改变模型的顶点位置，只是让模型看起来好像是“凹凸不平”的，但可以从模型的轮廓处看出“破绽”。</p><h2 id="法线贴图（Normal-Map）"><a href="#法线贴图（Normal-Map）" class="headerlink" title="法线贴图（Normal Map）"></a>法线贴图（Normal Map）</h2><p>法线贴图记录了表面的法线信息，法线方向的分量范围是 [-1, 1] ，像素分量的范围是 [0, 1] ，要把纹理信息记录在图片上就需要做一个映射：$pixel &#x3D; (normal + 1)&#x2F;2$，在shader中就需要做一个反映射：$normal &#x3D; pixel*2-1$。<br>法线贴图分为定义在<strong>模型空间下的法线纹理</strong>和定义在<strong>切线空间下的法线纹理</strong>两种。</p><p><img src="/article_img/2023-07-10-17-24-48.png"></p><p>一般来说使用<strong>切线空间下的法线纹理</strong>，对于模型的每个顶点，都有一个自己的切线空间，这个切线空间的原点就是该顶点本身，而z轴就是顶点的法线方向，因此对于大部分顶点来说，其法线坐标是（0，0，1），转换到像素存储到贴图中就是（0.5，0.5，1）就是看上去的浅蓝色。<strong>这种法线纹理其实就是存储了每个点在各自的切线空间中的法线 “扰动” 方向。</strong></p><h3 id="切线空间下的法线纹理的优点："><a href="#切线空间下的法线纹理的优点：" class="headerlink" title="切线空间下的法线纹理的优点："></a>切线空间下的法线纹理的优点：</h3><ol><li>模型空间下的法线纹理记录绝对法线信息，只可以用于创建时的模型，切线空间下的法线纹理可以通用</li><li>可以进行UV动画</li><li>可以重用法线纹理</li><li>可以压缩，由于切线空间下的法线纹理中法线的方向总是正方向，因此我们可以仅存储 XY 方向，而推导得到 Z 方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储3个方向的值，不可压缩。</li></ol><h3 id="Shader中的实现方法"><a href="#Shader中的实现方法" class="headerlink" title="Shader中的实现方法"></a>Shader中的实现方法</h3><p>在shader中计算光照时，需要让法线，光源方向，观察方向都在同一个坐标系中（无论在哪一个坐标系中，都不会对计算结果产生影响），因此针对切线空间下的法线纹理，就有两种实现方式：<strong>将所有向量转换到切线空间下</strong>和<strong>将所有向量转换到世界空间下</strong>。</p><ol><li>转换到切线空间：这种方法可以在顶点着色器中实现，将光源方向和观察方向转换到切线空间即可，这种方法由于在顶点着色器中实现所以计算量较小</li><li>转换到世界空间：这种方法要将切线空间的法线转换到世界空间，因此必须在片元着色器中对法线贴图采样后进行一次矩阵乘法，效率上比较低，但是通用性更好，有时我们需要在世界空间下进行一些计算，如Cubemap。在构建转换矩阵时一定要注意顺序必须是：<strong>切线，副切线，法线</strong> 的顺序！（因为这是切线空间对xyz轴的定义，见上图，如果顺序不对在转换时就会计算错误），按列构建矩阵（即从世界空间到切线空间矩阵的转置）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vert</span><span class="hljs-params">(in a2v v, out v2f o)</span></span>&#123;<br>   <span class="hljs-comment">//...</span><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   构建从切线空间转换到世界空间的转换矩阵</span><br><span class="hljs-comment">   */</span><br>   o.TtoW0 = <span class="hljs-built_in">float3</span>(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);<br>   o.TtoW1 = <span class="hljs-built_in">float3</span>(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);<br>   o.TtoW2 = <span class="hljs-built_in">float3</span>(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);<br>   <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-function">fixed4 <span class="hljs-title">frag</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET&#123;</span><br>   <span class="hljs-comment">//...</span><br>   fixed3 bump = <span class="hljs-built_in">UnpackNormal</span>(<span class="hljs-built_in">tex2D</span>(_BumpMap, i.uv)); <span class="hljs-comment">// 解包法线</span><br>   bump = <span class="hljs-built_in">fixed3</span>(<span class="hljs-built_in">dot</span>(i.TtoW0.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW1.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW2.xyz, bump))  <span class="hljs-comment">// 转换到世界空间</span><br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>在对使用法线贴图时，需要先对法线贴图进行<strong>解包</strong>（从像素颜色转换到法线方向）:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在Unity中设置纹理为法线贴图，可以使用内置函数否则要手动解包：normal = pixel*2-1</span><br>fixed3 normal = UnpackNormal(tex2D(_NormalMap, i.uv.zw));<br></code></pre></td></tr></table></figure><p>上面介绍了切线下的法线贴图可以压缩，我们一般只存储法线的xy分量，z分量通过法线是单位向量的性质计算得出（当在Unity中将纹理属性设置为Normal Map后直接使用内置函数<strong>UnpackNormal</strong>解包后直接使用），下面的代码是UnpackNormal的实现，对不同平台对法线有不同的压缩方式，所以还是<strong>尽量使用UnpackNormal</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> fixed3 <span class="hljs-title function_">UnpackNorma1DXT5nm</span> <span class="hljs-params">(fixed4 packednormal)</span> <br>&#123; <br>   fixed3 normal; <br>   normal.xy = packednormal.wy * <span class="hljs-number">2</span> - l; <br>   normal.z = sqr-t(l - saturate(dot(normal.xy, normal.xy))); <br>   <span class="hljs-keyword">return</span> normal ; <br>&#125;<br><span class="hljs-keyword">inline</span> fixed3 <span class="hljs-title function_">UnpackNormal</span><span class="hljs-params">(fixed4 packednormal)</span> <br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined (UNITY NO DXT5nm) </span><br>   <span class="hljs-keyword">return</span> packednormal.xyz * <span class="hljs-number">2</span> - l; <br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br>   <span class="hljs-keyword">return</span> UnpackNorrna1DXT5nm(packednormal); <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>一定注意在导入法线贴图时，要将法线贴图的纹理类型（Texture Type）设置为 <strong>Normal map</strong>，这是因为如果使用 <strong>UnpackNormal</strong> 等类似函数解包法线贴图时会按照针对法线贴图的压缩规则： <strong>a通道当作x，g通道当作y，而r和b通道不存储任何数据</strong> 进行解包。如果没有设置为法线贴图类型，则没有进行压缩操作，最后使用解包函数的结果也当然是错误的。</p><p><img src="/article_img/2023-07-11-17-02-05.png"><br>从左到右：单张纹理，转换到切线空间下，转换到世界空间下</p><h2 id="高度贴图（Height-Map）"><a href="#高度贴图（Height-Map）" class="headerlink" title="高度贴图（Height Map）"></a>高度贴图（Height Map）</h2><p>高度图存储的是强度值（intensity），颜色越深该位置越向里凹，颜色越浅越向外凸，高度图不能直接得到法线信息，一般和法线贴图一起使用，用来给出表面凹凸的额外信息。</p><h1 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h1><p>人们法线纹理可以用于存储任何表面信息，就想到用纹理存储漫反射光照的结果，这种技术常用来实现卡通化渲染.</p><p>在具体实现时，使用half-lambert计算漫反射，因为half-lambert是一个 [0, 1] 的映射，正好可以用来采样RampMap，如果使用lambert那么会有整个半球的颜色我们无法控制，那就背离了我们使用渐变纹理来更灵活的控制光照的初衷。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">fixed halfLambert = <span class="hljs-number">0.5</span> * dot(worldNormal, worldLight)+<span class="hljs-number">0.5</span>;<br>fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, <span class="hljs-number">0</span>)).rgb * _Color.rgb;<br>fixed3 diffuse = diffuseColor * _LightColor0.rgb;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-07-11-18-06-47.png"></p><p>同时要注意在使用渐变纹理时，将纹理的 <strong>Wrap Mode</strong> 设置为 <strong>clamp</strong>，这样可以有效防止由于计算精度问题（halfLambert计算结果可能会出现1.0001这种值，如果是 <strong>repeat</strong> 模式，会舍弃整数部分编程0.0001，就会采样到黑色区域）在高光区域出现的黑点和在背光区域出现的亮点：</p><table><thead><tr><th>![](&#x2F;article_img&#x2F;2023-07-11-18-21-     15.png)</th><th><img src="/article_img/2023-07-11-18-21-51.png"></th></tr></thead></table><h1 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h1><p>遮罩允许我们可以保护某些区域，使它们免于某些修改。使用遮罩纹理的流程一般是通过采样得到遮罩纹理的纹素值，然后使用其中某个（或某几个）通道的值（例如 texel.r 来与某种表面属性进行相乘，这样，当该通道的值为0时，可以保护表面不受该屈性的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(saturate(dot(lightDir, normal)), _Gloss) * specularMask;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-07-11-20-36-51.png"><br>从左至右：无高光遮罩，有高光遮罩，无高光</p><h1 id="环境贴图（立方体纹理-Cubemap）"><a href="#环境贴图（立方体纹理-Cubemap）" class="headerlink" title="环境贴图（立方体纹理&#x2F;Cubemap）"></a>环境贴图（立方体纹理&#x2F;Cubemap）</h1><p>在图形学中，立方体纹理(Cubemap)是环境映射(Environment Mapping)的一种实现方法。 环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像锁了层金属一样反射出周围的环境。</p><p>Cubemap包含了6张图像，就相当于用一个正方体包裹住场景，天空盒一般就用Cubemap来实现，同时，通过cubemap可以实现环境映射，因此一些高级的光线效果得以利用cubemap实现。</p><h2 id="反射（Reflection）"><a href="#反射（Reflection）" class="headerlink" title="反射（Reflection）"></a>反射（Reflection）</h2><p>反射的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">pass&#123;<br>   <span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(in a2v v)</span></span>&#123;<br>      v2f o;<br>      <span class="hljs-comment">// ...</span><br>      o.worldReflct = <span class="hljs-built_in">reflect</span>(-o.worldView, o.worldNormal);<br>      <span class="hljs-keyword">return</span> o;<br>   &#125;<br>   <span class="hljs-function">real4 <span class="hljs-title">frag</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET&#123;</span><br>      <span class="hljs-comment">// reflection</span><br>      half3 reflection = <span class="hljs-built_in">SAMPLE_TEXTURECUBE</span>(_Cubemap, sampler_Cubemap, i.worldReflct).rgb * _ReflectColor.rgb;<br>      half atten = mainLight.shadowAttenuation;<br>      half3 color = ambient + <span class="hljs-built_in">lerp</span>(diffuse, reflection, _ReflectAmount) * atten;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">real4</span>(color, <span class="hljs-number">1.0</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-09-13-19-34-02.png"></p><h2 id="折射（Refraction）"><a href="#折射（Refraction）" class="headerlink" title="折射（Refraction）"></a>折射（Refraction）</h2><p>折射的实现需要注意使用 <strong>refract()</strong> 函数中的参数要先归一化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">pass&#123;<br>   <span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(in a2v v)</span></span>&#123;<br>      v2f o;<br>      <span class="hljs-comment">// ...</span><br>      o.worldRefract = <span class="hljs-built_in">refract</span>(-<span class="hljs-built_in">normalize</span>(o.worldView), <span class="hljs-built_in">normalize</span>(o.worldNormal));<br>      <span class="hljs-keyword">return</span> o;<br>   &#125;<br>   <span class="hljs-function">real4 <span class="hljs-title">frag</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET&#123;</span><br>      <span class="hljs-comment">// refraction</span><br>      half3 refraction = <span class="hljs-built_in">SAMPLE_TEXTURECUBE</span>(_Cubemap, sampler_Cubemap, i.worldRefract).rgb;<br>      half atten = mainLight.shadowAttenuation;<br>      half3 color = ambient + <span class="hljs-built_in">lerp</span>(diffuse, refraction, _RefractAmount) * atten;<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">real4</span>(color, <span class="hljs-number">1.0</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>折射效果很差，就不放图了。。</p><h2 id="菲涅尔效应（Fresnel）"><a href="#菲涅尔效应（Fresnel）" class="headerlink" title="菲涅尔效应（Fresnel）"></a>菲涅尔效应（Fresnel）</h2><p>菲涅尔效应在实现中通过Schlick近似来实现：<br><img src="/article_img/2023-09-13-19-31-53.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">pass&#123;<br>   <span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(in a2v v)</span></span>&#123;<br>      v2f o;<br>      <span class="hljs-comment">// ...</span><br>      o.worldReflect = <span class="hljs-built_in">reflect</span>(-<span class="hljs-built_in">normalize</span>(o.worldView), <span class="hljs-built_in">normalize</span>(o.worldNormal));<br>      <span class="hljs-keyword">return</span> o;<br>   &#125;<br>   <span class="hljs-function">real4 <span class="hljs-title">frag</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET&#123;</span><br>      <span class="hljs-comment">// fresnel</span><br>      float3 fresnel = _FresnelScale + (<span class="hljs-number">1</span> - _FresnelScale) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - <span class="hljs-built_in">dot</span>(i.worldView, worldNormal), <span class="hljs-number">5</span>); <span class="hljs-comment">// schlick</span><br>      half3 reflection = <span class="hljs-built_in">SAMPLE_TEXTURECUBE</span>(_Cubemap, sampler_Cubemap, worldReflect).rgb;<br><br>      half3 color = ambient + <span class="hljs-built_in">lerp</span>(diffuse, reflection, <span class="hljs-built_in">saturate</span>(fresnel)) * atten;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">real4</span>(color, <span class="hljs-number">1.0</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-09-13-19-35-03.png"></p><h1 id="渲染纹理（Render-Texture）"><a href="#渲染纹理（Render-Texture）" class="headerlink" title="渲染纹理（Render Texture）"></a>渲染纹理（Render Texture）</h1><h1 id="程序纹理（Procedure-Texture）"><a href="#程序纹理（Procedure-Texture）" class="headerlink" title="程序纹理（Procedure Texture）"></a>程序纹理（Procedure Texture）</h1>]]></content>
    
    
    <categories>
      
      <category>-[TA]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>百人计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百人计划-传统经验光照模型详解</title>
    <link href="/2023/07/09/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E7%BB%8F%E9%AA%8C%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/07/09/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E7%BB%8F%E9%AA%8C%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://www.bilibili.com/video/BV1B54y1j7zE/?spm_id_from=333.999.0.0&vd_source=93b215eab72b2548f75d0772e28f8b20">百人计划-传统经验光照模型详解</a><br>《Unity Shader入门精要》 第6章 基础光照<br><a href="https://zhuanlan.zhihu.com/p/172496451">Shader学习 （12）使用Unity和UE4实现三个经典光照模型</a></p><p>代码标注为C++只是为了会有高亮好看，实际是ShaderLab</p><span id="more"></span><p>经验光照模型只是看上去近似，不是真正正确的光照模型。</p><h1 id="漫反射（Diffuse）"><a href="#漫反射（Diffuse）" class="headerlink" title="漫反射（Diffuse）"></a>漫反射（Diffuse）</h1><table><thead><tr><th><img src="/article_img/2022-08-29-15-23-14.png"></th><th><img src="/article_img/2022-08-29-15-18-42.png"></th></tr></thead></table><p>漫反射假设一束光达到着色点后均匀的向各个反向反射，而根据<strong>Lambert余弦定理</strong>认为反射光强度与入射角度与法线方向的余弦成正比，因此就有了漫反射公式。</p><h1 id="镜面反射-高光-（Specular）"><a href="#镜面反射-高光-（Specular）" class="headerlink" title="镜面反射&#x2F;高光 （Specular）"></a>镜面反射&#x2F;高光 （Specular）</h1><p><img src="/article_img/2022-08-29-15-35-09.png"></p><p>镜面反射与入射光和观察角度有关。正常计算应该计算出射方向与观察方向（从着色点指向摄像机的方向，UE中的<strong>CameraDirectionVector</strong>是从摄像机指向着色点的向量，要注意取反）的夹角，但是出射方向计算复杂，一般使用<strong>半程向量</strong>（观察方向与入射方向的和的单位向量）与法线方向的夹角近似计算。</p><table><thead><tr><th><img src="/article_img/2022-08-29-15-38-15.png"></th><th><img src="/article_img/2022-08-29-15-39-32.png"></th></tr></thead></table><h1 id="环境光（ambient）"><a href="#环境光（ambient）" class="headerlink" title="环境光（ambient）"></a>环境光（ambient）</h1><p>环境光是为了模拟现实世界中光的反射会经过多次弹射照亮其他物体的效果，环境光一般是一个常量，也可以使用环境光贴图。</p><h1 id="几种光照模型"><a href="#几种光照模型" class="headerlink" title="几种光照模型"></a>几种光照模型</h1><h2 id="Lambert模型"><a href="#Lambert模型" class="headerlink" title="Lambert模型"></a>Lambert模型</h2><p>最简单的光照模型，只考虑用Lambert余弦定理计算得到的漫反射的光照模型。</p><h2 id="Half-Lambert模型"><a href="#Half-Lambert模型" class="headerlink" title="Half-Lambert模型"></a>Half-Lambert模型</h2><p>使用Lambert模型计算光照时，会把计算结果截取到 [0, 1] 的范围，导致在夹角大于90°时就全是黑色，这看上去不太符合现实世界，因为完全没有全局光照，因此Half-Lambert提出：dot(n,l) * 0.5 + 0.5 ，这样将大于90°的半球也点亮。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">fixed4 <span class="hljs-title function_">fragmentShader</span><span class="hljs-params">(in v2f i)</span> : SV_TARGET&#123;<br>   <span class="hljs-comment">//...</span><br>   fixed3 halfLambert = dot(worldNormal, worldLight) * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;<br>   fixed3 color = ambient + _LightColor0.rgb * _Diffuse.rgb * halfLambert;<br>   <span class="hljs-keyword">return</span> fixed4(color, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Phong模型"><a href="#Phong模型" class="headerlink" title="Phong模型"></a>Phong模型</h2><p>Phong模型是第一个有影响力的光照模型，由越南学者裴祥风（Bui Tuong Phong）提出，将环境光，漫反射和镜面反射的结果相加。</p><h2 id="Blinn-Phong模型"><a href="#Blinn-Phong模型" class="headerlink" title="Blinn-Phong模型"></a>Blinn-Phong模型</h2><p>Blinn-Phong模型是在Phong模型上的改进，使用<strong>半程向量和法线的夹角</strong>代替出射方向和观察方向的夹角，简化了计算。</p><p><img src="/article_img/2022-08-29-15-42-40.png"></p><p>Blinn-Phon 光照模型的高光反射部分看起来更大、更亮一些。</p><p><img src="/article_img/2023-07-10-15-28-50.png"></p><h1 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h1><p><img src="/article_img/2022-08-29-15-48-55.png"></p><p>着色频率一般有逐平面着色（Flat shading），逐顶点着色（Gouraud shading）和逐像素着色（Phong shading），区别在于对于光照的计算在渲染流水线的哪个阶段，逐顶点着色在顶点着色器计算光照，逐像素着色在片元着色器计算光照。</p><p>计算光照时需要注意要将顶点着色器中计算好的法线在片元着色器中 <strong>归一化</strong>。<br>原因是在片元着色器中每个片元计算用到的法线是由顶点着色器中计算好的法线<strong>插值</strong>得来的，如果不进行归一化，插值得到的法线的模长不为一，点乘计算出的结果会看起来不平滑：</p><table><thead><tr><th><img src="/article_img/2023-09-04-14-12-39.png"></th><th><img src="/article_img/2023-09-04-14-13-05.png"></th></tr></thead></table><p>观察上图中的高光部分可以明显看出区别。</p><h1 id="在UE和Unity中分别实现各种光照模型"><a href="#在UE和Unity中分别实现各种光照模型" class="headerlink" title="在UE和Unity中分别实现各种光照模型"></a>在UE和Unity中分别实现各种光照模型</h1><table><thead><tr><th>UE5</th><th>Unity</th></tr></thead><tbody><tr><td>AtmosphericLightVector</td><td>WorldLightDir</td></tr><tr><td>CameraDirectionVector</td><td>-ViewDir</td></tr><tr><td>PixelNormal WS</td><td>WorldNormalDir</td></tr></tbody></table><h2 id="UE5"><a href="#UE5" class="headerlink" title="UE5"></a>UE5</h2><p><img src="/article_img/2023-07-09-20-21-01.png"><br>从左至右依次：Lambert，Half-Lambert，Blinn-Phong+Half-Lambert</p><h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><p><img src="/article_img/2023-07-09-20-21-13.png"><br>从左至右依次：逐顶点Lambert，逐像素Lambert，逐像素Half-Lambert，逐顶点Blinn-Phong，逐像素Blinn-Phong，逐像素Blinn-Phong+Half-Lambert</p>]]></content>
    
    
    <categories>
      
      <category>-[TA]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>百人计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百人计划-渲染流水线</title>
    <link href="/2023/07/07/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <url>/2023/07/07/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<br><a href="https://www.bilibili.com/video/BV1L54y1s7xw/?p=2&spm_id_from=pageDriver&vd_source=93b215eab72b2548f75d0772e28f8b20">百人计划-渲染流水线</a><br>《Unity Shader入门精要》 第2章 渲染流水线</p><span id="more"></span><h1 id="1-整体流程"><a href="#1-整体流程" class="headerlink" title="1 整体流程"></a>1 整体流程</h1><p><img src="/article_img/2023-07-06-16-14-09.png"></p><ol><li>应用阶段：粗粒度剔除，进行渲染设置，准备基本数据，输出到几何阶段</li><li>几何阶段：顶点着色器，曲面细分，几何着色器，顶点裁剪，屏幕映射</li><li>光栅化阶段：三角形（点&#x2F;线）设置，三角形（点&#x2F;线）遍历，片段着色器</li><li>逐片元操作：裁剪测试，透明度测试，深度测试，模板测试，混合</li><li>后处理</li></ol><p><img src="/article_img/2023-07-06-16-21-18.png"></p><p>不同的教材和资料对渲染流水线的划分有所不同，有些将片元着色器和逐片元操作都归入光栅化阶段，有些将这两步独立为逐片元操作阶段，不用过于纠结。</p><h1 id="2-应用阶段"><a href="#2-应用阶段" class="headerlink" title="2 应用阶段"></a>2 应用阶段</h1><p><img src="/article_img/2023-07-06-16-23-54.png"></p><p><strong>1. 把数据加载到显存中<br>2. 设置渲染状态<br>3. 调用Draw Call</strong></p><h2 id="2-1-基本场景数据（把数据加载到显存中）"><a href="#2-1-基本场景数据（把数据加载到显存中）" class="headerlink" title="2.1 基本场景数据（把数据加载到显存中）"></a>2.1 基本场景数据（把数据加载到显存中）</h2><p><img src="/article_img/2023-07-07-15-09-53.png"></p><ol><li>场景物体数据：Transform（位置，旋转，缩放）+ 网格数据（顶点位置，UV，法线，切线）</li><li>摄像机数据：参数（位置，朝向，远近裁剪面，透视方式，比例）</li><li>光源数据：类型（方向光，点光，面光）+ 参数（位置，方向，角度）</li><li>阴影数据：是否需要阴影，阴影参数（对应光源，强度，级联参数，深度偏移，近平面偏移）</li></ol><h2 id="2-2-优化（算法加速，剔除）"><a href="#2-2-优化（算法加速，剔除）" class="headerlink" title="2.2 优化（算法加速，剔除）"></a>2.2 优化（算法加速，剔除）</h2><ol><li>碰撞检测</li><li>加速算法</li><li>遮挡剔除（粗略）：裁剪光源，物体（八叉树，K-D树，BVH）</li></ol><h2 id="2-3-设置渲染状态，准备渲染参数"><a href="#2-3-设置渲染状态，准备渲染参数" class="headerlink" title="2.3 设置渲染状态，准备渲染参数"></a>2.3 设置渲染状态，准备渲染参数</h2><p>渲染状态定义了场景中的网格是怎样被渲染的，例如使用哪个顶点着色器&#x2F;片元着色器，材质，光源等等。<br><img src="/article_img/2023-07-07-15-13-47.png"></p><ol><li>绘制设置：着色器，合批方式（减少Draw Call的方式使用批处理，合批方式决定哪些网格被合并）</li><li>绘制顺序：透明物体的渲染顺序</li><li>渲染目标：RenderTexture，FrameBuffer</li><li>渲染模式：前向渲染，延迟渲染</li></ol><h2 id="2-4-调用DrawCall"><a href="#2-4-调用DrawCall" class="headerlink" title="2.4 调用DrawCall"></a>2.4 调用DrawCall</h2><p>CPU 调用一个渲染命令来告诉GPU: “嘿！老兄， 我都帮你把数据准备好啦， 你可以按照我的设置来开始渲染啦！” 而这个渲染命令就是 Draw Call。<br><img src="/article_img/2023-07-07-15-14-57.png"></p><p>Draw Call中造成的性能问题主要来自CPU</p><table><thead><tr><th><img src="/article_img/2023-07-07-16-16-58.png"></th><th><img src="/article_img/2023-07-07-16-17-07.png"></th><th><img src="/article_img/2023-07-07-16-17-14.png"></th></tr></thead></table><p>调用完Draw Call之后，我们完成了CPU和GPU之间的通信，接下来进入了GPU流水线阶段，包括几何阶段和光栅化阶段。<br><img src="/article_img/2023-07-07-15-16-56.png"><br>GPU流水线不是完全可控的，但是GPU向我们开放了很多控制权，<strong>绿色表示完全可编程完全可控，黄色表示不可编程但可以配置，蓝色表示完全不可编程。</strong></p><h1 id="3-几何阶段"><a href="#3-几何阶段" class="headerlink" title="3 几何阶段"></a>3 几何阶段</h1><p><img src="/article_img/2023-07-06-16-28-50.png"></p><h2 id="3-1-顶点着色器（vertex-shader）"><a href="#3-1-顶点着色器（vertex-shader）" class="headerlink" title="3.1 顶点着色器（vertex shader）"></a>3.1 顶点着色器（vertex shader）</h2><p><img src="/article_img/2023-07-07-15-24-40.png"><br>顶点着色器负责坐标变换和逐顶点光照，除此之外，顶点着色器也可以输出后续阶段所需的数据。</p><ol><li>坐标变换：顶点着色器必须完成的一个工作是 <strong>把顶点坐标从模型空间转换到齐次裁剪空间（即完成MVP变换）</strong> <a href="/_posts/Games101-2-%E5%8F%98%E6%8D%A2.md">Games101-变换</a>，<img src="/article_img/2023-07-07-15-30-15.png"><br>还可以完成一些顶点动画来模拟水面，布料等。</li></ol><h2 id="3-2-裁剪"><a href="#3-2-裁剪" class="headerlink" title="3.2 裁剪"></a>3.2 裁剪</h2><p><img src="/article_img/2023-07-07-15-32-10.png"><br>裁剪阶段是不可编程的，是硬件上的固定操作，但我们可以自定义个裁剪操作来进行配置</p><h2 id="3-3-屏幕映射"><a href="#3-3-屏幕映射" class="headerlink" title="3.3 屏幕映射"></a>3.3 屏幕映射</h2><table><thead><tr><th><img src="/article_img/2023-07-07-15-34-47.png"></th><th><img src="/article_img/2023-07-07-15-34-56.png"></th></tr></thead></table><p>屏幕映射就是一个缩放过程，其对z坐标不做任何变换。<strong>要注意OpenGL和DirectX的屏幕坐标系有所不同。</strong></p><h1 id="4-光栅化阶段"><a href="#4-光栅化阶段" class="headerlink" title="4 光栅化阶段"></a>4 光栅化阶段</h1><p>光栅化阶段有两个最重要的目标 计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色。</p><h2 id="4-1-三角形设置-图元组装（Primitive-Assembly）"><a href="#4-1-三角形设置-图元组装（Primitive-Assembly）" class="headerlink" title="4.1 三角形设置&#x2F;图元组装（Primitive Assembly）"></a>4.1 三角形设置&#x2F;图元组装（Primitive Assembly）</h2><p><img src="/article_img/2023-07-06-16-55-05.png"></p><h2 id="4-2-三角形遍历"><a href="#4-2-三角形遍历" class="headerlink" title="4.2 三角形遍历"></a>4.2 三角形遍历</h2><p>三角形遍历（Triangle Traversal）检查每个像素是否被一个三角网格所覆盖，若覆盖则会生成一个片元（fragment），在这个阶段，GPU会对所有信息进行插值，也就是说对每一个片元来说其中包含了顶点位置，深度，法线等所有信息，这也就是为什么我们可以在片元着色器中仍然使用顶点计算光照并得到更好的效果。</p><table><thead><tr><th><img src="/article_img/2023-07-06-16-55-00.png"></th><th><img src="/article_img/2023-07-07-15-42-20.png"></th></tr></thead></table><p><strong>需要注意：片元并不完全等于像素，片元中包含了很多状态（屏幕坐标，深度信息，法线，纹理坐标等等）</strong></p><h1 id="5-逐片元操作"><a href="#5-逐片元操作" class="headerlink" title="5 逐片元操作"></a>5 逐片元操作</h1><h2 id="5-1-片元着色器"><a href="#5-1-片元着色器" class="headerlink" title="5.1 片元着色器"></a>5.1 片元着色器</h2><p>片元着色器 (Fragment Shader) 是另一个非常重要的可编程着色器阶段。在 DirectX 中，片元着色器被称为像素着色器 (Pixel Shader), 但片元着色器是个更合适的名字，因为此时的片元并不是一个真正意义上的像素。</p><p><img src="/article_img/2023-07-07-15-50-58.png"></p><h2 id="5-2-逐片元操作"><a href="#5-2-逐片元操作" class="headerlink" title="5.2 逐片元操作"></a>5.2 逐片元操作</h2><p><img src="/article_img/2023-07-07-15-53-04.png"><br>逐片元操作 (Per Fragment Operations) OpenGL 中的说法 Direct.X 这一阶段被称为输出合井阶段 (Output-Merger)，该阶段对每个片元进行操作，将它们的颜色以某种形式合并，得到最终在屏幕上像素显示的颜色。主要的工作有两个：</p><ol><li>对片元进行测试（Test）</li><li>合并（Merge）</li></ol><p><img src="/article_img/2023-07-06-16-50-30.png"></p><h2 id="5-3-双重缓冲（Double-Buffering）"><a href="#5-3-双重缓冲（Double-Buffering）" class="headerlink" title="5.3 双重缓冲（Double Buffering）"></a>5.3 双重缓冲（Double Buffering）</h2><p>为了避免我们看到那些正在进行光栅化的图元，GPU对场景的渲染是在幕后发生的，即在 <strong>后置缓冲 (Back Buffer)</strong> 中。 一旦场景已经被渲染到了后置缓冲中，GPU 就会交换后置缓冲区和 <strong>前置缓冲 (Front Buffer)</strong> 中的内容， 而前置缓冲区是之前显示在屏幕上的图像。</p><h1 id="6-各阶段可控性"><a href="#6-各阶段可控性" class="headerlink" title="6 各阶段可控性"></a>6 各阶段可控性</h1><table><thead><tr><th><img src="/article_img/2023-07-06-16-56-37.png"></th><th><img src="/article_img/2023-07-07-15-16-56.png"></th></tr></thead></table><p>GPU流水线不是完全可控的，但是GPU向我们开放了很多控制权，<strong>绿色表示完全可编程完全可控，黄色表示不可编程但可以配置，蓝色表示完全不可编程。</strong></p>]]></content>
    
    
    <categories>
      
      <category>-[TA]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>百人计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++Review-How C++ Works</title>
    <link href="/2023/04/17/C++Review_How/"/>
    <url>/2023/04/17/C++Review_How/</url>
    
    <content type="html"><![CDATA[<p>复习C++</p><span id="more"></span><p>主要参考 <a href="https://www.bilibili.com/video/BV1qh411p7Sa?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20">Cherno’s C++ 教程</a></p><h1 id="C-从文本到程序"><a href="#C-从文本到程序" class="headerlink" title="C++从文本到程序"></a>C++从文本到程序</h1><p>我们编写的代码本质就是文本（text），要让这个文本变成机器可以执行的应用（binary），需要有两个主要的操作：编译（compiling）和链接（linking）。</p><p>当我们按下编译键（ctrl+F7）时只会进行编译，按下build键时会先编译后链接。</p><h1 id="C-编译器（Compiling）"><a href="#C-编译器（Compiling）" class="headerlink" title="C++编译器（Compiling）"></a>C++编译器（Compiling）</h1><p>C++编译器的工作是将<strong>文本</strong>（.cpp文件或者.h文件）转换为<strong>obj</strong>文件，也就是机器语言。</p><p>说到底就是编译器把代码转化为constant data或者instructions</p><p><strong>编译的基本步骤</strong></p><ol><li>需要<strong>预处理（pre-process）</strong> 代码，处理所有的预处理语句（preprocessor）</li><li>编辑<strong>解释（tokenizing）</strong>和<strong>解析（parsing）</strong>，将c++文件里的这些文本翻译成编译器可以理解和处理的语句<br>结果就是创建<strong>抽象语法树（abstract syntax tree）</strong></li><li>根据这颗抽象语法树产生cpu真正执行的机器码</li></ol><h2 id="编译单元（translation-unit）和文件的关系"><a href="#编译单元（translation-unit）和文件的关系" class="headerlink" title="编译单元（translation unit）和文件的关系"></a>编译单元（translation unit）和文件的关系</h2><p>C++不关心文件（file），是什么文件对编译器来说并没有硬性要求，编译器会默认cpp文件是C++文件，h文件是header文件，但是这只是默认，完全可以自定义另一种文件.cherno文件是C++文件，编译器就会将cherno文件当作C++文件处理。</p><p>一个<strong>编译单元（translation unit）</strong> 对应一个<strong>obj文件</strong>，一般都是每个文件是一个编译单元，但是如果使用了#include，将别的文件包含在当前的文件中（本质就是创建了一个大的cpp文件，里面有很多cpp文件），且只编译当前这个文件，那么这个文件和他include的文件组成一个编译单元，也就只会得到一个obj文件。</p><h2 id="预处理（pre-process）"><a href="#预处理（pre-process）" class="headerlink" title="预处理（pre-process）"></a>预处理（pre-process）</h2><p><strong>#include</strong>的工作原理就是找到你include的文件，之后<strong>复制</strong>其全部内容到当前的文件。</p><p><strong>#define</strong>的工作原理就是用anything替换INTEGER</p><p><img src="/article_img/2023-04-19-12-13-27.png"></p><p>Math.i是生成的预处理文件，可以在项目属性里设置生成预处理文件，但是这样VS就不会生成obj文件了。</p><h2 id="obj文件"><a href="#obj文件" class="headerlink" title="obj文件"></a>obj文件</h2><p>obj文件就已经是机器码了：<br><img src="/article_img/2023-04-19-12-51-20.png"></p><p>如果选择了<strong>优化</strong>，在编译阶段就会对代码进行优化，比如删掉未使用的代码，计算所有的常量，删掉多余的寄存器等等。而为了使Debug方便，VS在Debug模式下默认禁止代码优化，就导致其运行起来较慢。</p><h1 id="C-链接器（Linking）"><a href="#C-链接器（Linking）" class="headerlink" title="C++链接器（Linking）"></a>C++链接器（Linking）</h1><p>当我们将每个编译单元编译成一个Obj文件之后，这些文件是独立的，并不能进行交流，而我们经常将不同的代码写在不同的文件中，因此我们需要<strong>链接（Linking）</strong>，将这些独立的Obj文件联系起来。就算我们将所有的代码都写在一个文件中，我们也需要告知程序的入口（main函数）在哪，也需要链接操作。</p><h2 id="常见的链接错误"><a href="#常见的链接错误" class="headerlink" title="常见的链接错误"></a>常见的链接错误</h2><ol><li>unresolved external symbol（未解决的外部符号）：链接器找不到他需要的东西</li><li>one or more multiply defined symbols found（重复定义）：链接器不知道选择哪个<br>常见于include头文件时，可以使用static，inline或者移动函数定义的方式（关键点就是理解include实际上就是复制粘贴！）</li></ol><h1 id="VS设置"><a href="#VS设置" class="headerlink" title="VS设置"></a>VS设置</h1><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出目录：$(SolutionDir)bin$(Platform)$(Configuration)\</p><p>中间目录：$(SolutionDir)bin\intermediates$(Platform)$(Configuration)\  </p><p><img src="/article_img/2023-04-19-16-20-25.png"></p><p>可以使结构清晰，方便查找。</p><h1 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h1><h2 id="在类或结构体外"><a href="#在类或结构体外" class="headerlink" title="在类或结构体外"></a>在类或结构体外</h2><p>类外的static修饰的符号在link阶段是<strong>局部</strong>的，也就是说它只对定义它的 <strong>编译单元（.obj）</strong> 可见。</p><p>当链接器（Linker）工作时，他不会找static修饰的变量，如果不是static修饰的全局变量，在link阶段就会随着链接而变成一个“<strong>整个项目的全局变量</strong>”，因为每一个使用到这个全局变量的编译单元都会去其他编译单元中寻找这个全局变量，如果不同的编译单元中定义了命名相同的全局变量，就会在链接阶段报重复定义的错。</p><p>假如在头文件中定义static变量，之后在不同的cpp文件中#include这个头文件，那么其实这些不同文件中的变量是相互独立的（因为#include就是复制，相当于分别在不同的文件中定义了static变量）</p><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>extern表示其修饰的变量或函数需要在其他编译单元中寻找。</p><p>因此：<strong>尽量让所有的全局变量和全局函数都被static修饰</strong></p><h2 id="在类或结构体内"><a href="#在类或结构体内" class="headerlink" title="在类或结构体内"></a>在类或结构体内</h2><p>类内的static修饰的符号表示这部分内存是这个类的<strong>所有实例共享的</strong>，静态方法（static method）不能访问任何非静态的变量或方法（<strong>因为类内的static只会被实例化一次，也可以理解为静态方法没有类实例，它并不能得到当前被实例化对象的信息</strong>），类中的非静态方法之所以可以访问类中的变量是因为有个隐含的参数：<strong>this指针</strong>，而静态方法没有this指针，就当然不能访问非静态的成员了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>   <span class="hljs-type">int</span> a,b;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>      std::cout&lt;&lt; a &lt;&lt; , &lt;&lt; b &lt;&lt;std::endl;<br>   &#125;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   这个函数在编译阶段就会变成下面这样</span><br><span class="hljs-comment">   void print(this)&#123;</span><br><span class="hljs-comment">      std::cout&lt;&lt; this.a &lt;&lt; , &lt;&lt; this.b &lt;&lt;std::endl;</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Sprint</span><span class="hljs-params">()</span></span>&#123;<br>      std::cout&lt;&lt; a &lt;&lt; , &lt;&lt; b &lt;&lt;std::endl;  <span class="hljs-comment">// 编译无法通过，静态方法不能访问非静态变量</span><br>   &#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">   这个函数在编译阶段就会变成下面这样，根本不知道a，b是什么</span><br><span class="hljs-comment">   void print()&#123;</span><br><span class="hljs-comment">      std::cout&lt;&lt; a &lt;&lt; , &lt;&lt; b &lt;&lt;std::endl;</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">   */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="static关键字使用场景"><a href="#static关键字使用场景" class="headerlink" title="static关键字使用场景"></a>static关键字使用场景</h2><ol><li>作用域是局部作用域，生命周期是整个程序的生命周期<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-type">static</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>   i++;<br>   std::cout&lt;&lt; i &lt;&lt;std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>单例模式（只有一个实例）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">Get</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-type">static</span> Singleton instance;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   Singleton::<span class="hljs-built_in">Get</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><p>Cherno把const称为一个假的关键字，因为它并不会对产生的代码造成什么实质上的影响，它只是一种 <strong>承诺</strong> ，承诺这是一个不会被改变的常量，用来方便编程。</p><h2 id="const常见用法"><a href="#const常见用法" class="headerlink" title="const常见用法"></a>const常见用法</h2><ol><li>定义常量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SPEED = <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure></li><li>定义指针<strong>本身</strong>是常量还是指针<strong>指向的内容</strong>的常量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* aPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">/*-------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p0 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;  <span class="hljs-comment">// p0指针指向的内存存的是不可改变的常量，等价于：int const* p0 = new int;</span><br>*p0 = <span class="hljs-number">2</span>; <span class="hljs-comment">// 报错</span><br>p0 = aPtr; <span class="hljs-comment">// 正确 </span><br><span class="hljs-comment">/*-------------------------------------*/</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;  <span class="hljs-comment">// p1指针指向的内存地址是不可改变的</span><br>*p1 = <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br>p1 = aPtr; <span class="hljs-comment">// 报错</span><br><span class="hljs-comment">/*-------------------------------------*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;  <span class="hljs-comment">// p2指针指向的内存地址不可改变，内存地址中的量也不可改变</span><br>*p2 = <span class="hljs-number">2</span>; <span class="hljs-comment">// 报错</span><br>p2 = aPtr; <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure></li><li>定义类中的方法，承诺这个方法不会修改变量（const只能修饰类中的方法）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-type">int</span> m_X, m_Y;<br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>      <span class="hljs-keyword">return</span> m_X;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetX</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>      m_X = x;<br>   &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="/article_img/2023-04-21-13-49-02.png"><br>const如果只是一个承诺那它是不是没什么实际的用处呢？当然不是！按照下图，GetX()<strong>必须</strong>用const修饰，因为函数<strong>Print(const Entity&amp; e)</strong> 的参数是一个<strong>常引用</strong>（类比上面的const int* p），意味着其引用的对象（也就是自身，因为引用只是一个别名）是一个常量，那就要确保在函数中不能对自己这个常量进行修改，就只能调用被const修饰的函数。<table><thead><tr><th><img src="/article_img/2023-04-21-13-52-38.png"></th><th><img src="/article_img/2023-04-21-14-03-00.png"></th></tr></thead></table><strong>因此，如果没有修改类或者不应该修改类时，总是把这个方法标记为const！</strong></li></ol><p><strong>尽量总是使用 “const引用” 作为函数参数！</strong>，否则会默认复制一个变量，造成性能浪费。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">const</span> Entity&amp; e)</span></span>&#123;<br>   <span class="hljs-comment">// 只要函数中不需要更改e</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><p>相当于把内联函数里的内容写在调用函数处；</p><p><strong>相比于宏，多了类型检查，真正具有函数特性</strong></p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><strong>枚举类型本质就是整型</strong>，下面的LevelError，LevelWarning，LevelInfo值就是0，1，2；因此枚举也可以直接进行整型的大小比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Level</span>&#123;<br>   LevelError, LevelWarning, LevelInfo<br>&#125;；<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   Level l = LevelError;<br>   <span class="hljs-keyword">if</span>(l &gt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">//Do something</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><strong>总是使用构造函数初始化列表！</strong>，不使用函数初始化列表会导致一些变量（比如下面的m_A）被初始化多次，造成性能浪费。</p><table><thead><tr><th><img src="/article_img/2023-04-21-14-35-19.png"></th><th><img src="/article_img/2023-04-21-14-36-18.png"></th></tr></thead></table><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承的基本写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-type">float</span> X, Y;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Move</span><span class="hljs-params">(<span class="hljs-type">float</span> xa, <span class="hljs-type">float</span> ya)</span></span>&#123;<br>      X += xa;<br>      Y += ya;<br>   &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-type">const</span> <span class="hljs-type">char</span>* Name;<br><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintName</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">// print name </span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Player类<strong>不仅</strong>是Player类，它<strong>同样</strong>是一个Entity类。我们可以在任何想要使用Entity的地方使用Player（<strong>多态</strong>）</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数一般通过 <strong>虚函数表（vtable）</strong> 来实现编译，在编译阶段通过查询虚函数表确定该函数的定义。</p><p>在c++11中允许用 <strong>override</strong> 标注被重写的虚函数，增加代码可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-type">float</span> X, Y;<br>   <span class="hljs-type">const</span> <span class="hljs-type">char</span>* Name;<br>   <span class="hljs-built_in">Entity</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)&#123; Name = name; &#125; <span class="hljs-comment">// 构造函数</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Move</span><span class="hljs-params">(<span class="hljs-type">float</span> xa, <span class="hljs-type">float</span> ya)</span></span>&#123;<br>      <span class="hljs-comment">// move</span><br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PrintName</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">// 虚函数基本用法</span><br>      <span class="hljs-comment">// print entity&#x27;s name </span><br>   &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintName</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>      <span class="hljs-comment">// print player&#x27;s name </span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="纯虚函数（接口）"><a href="#纯虚函数（接口）" class="headerlink" title="纯虚函数（接口）"></a>纯虚函数（接口）</h2><p>纯虚函数的本质和其他语言中的接口相同，它是一种特殊的虚函数，在父类中不需要实现，而在子类中<strong>必须</strong>实现。</p><p>包含纯虚函数的类不能被实例化，因为纯虚函数没有被定义。<strong>只能实例化一个实现了所有纯虚函数的类。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Printable</span>&#123;  <br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">GetClassName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span> : <span class="hljs-keyword">public</span> Printable&#123;  <span class="hljs-comment">// 继承自Printable</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetClassName</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Entity&quot;</span> &lt;&lt; std::endl; &#125; <br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity&#123;   <span class="hljs-comment">// 继承自Entity</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetClassName</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Player&quot;</span> &lt;&lt; std::endl; &#125;   <span class="hljs-comment">// 还需要再次定义，否则就会调用Entity中的GetClassName()</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(Printable* obj)</span></span>&#123;<br>   std::cout &lt;&lt; obj-&gt;GetClassName &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   Entity* e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>();<br>   Player* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Player</span>();<br>   <span class="hljs-built_in">Print</span>(e);<br>   <span class="hljs-built_in">Print</span>(p);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Entity</span><br><span class="hljs-comment">Player</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="操作符和操作符重载"><a href="#操作符和操作符重载" class="headerlink" title="操作符和操作符重载"></a>操作符和操作符重载</h1><p>操作符本质就是函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector2</span> &#123;<br>    <span class="hljs-type">float</span> x, y;<br>    <span class="hljs-built_in">Vector2</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) :<span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-function">Vector2 <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x + other.x, y + other.y);<br>    &#125;<br>    Vector2 <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(other);<br>    &#125;<br><br>    <span class="hljs-function">Vector2 <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x * other.x, y * other.y);<br>    &#125;<br>    Vector2 <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Multiply</span>(other);<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> x == other.x &amp;&amp; y == other.y;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span>==other);<br>    &#125;<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> Vector2&amp; other) &#123;<br>    stream &lt;&lt; other.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; other.y;<br>    <span class="hljs-keyword">return</span> stream;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆（heap）和栈（stack）"><a href="#堆（heap）和栈（stack）" class="headerlink" title="堆（heap）和栈（stack）"></a>堆（heap）和栈（stack）</h1><p>C++中的堆和栈都指的是内存，在栈上的变量占据的内存会被<strong>自动回收</strong>（当变量生存周期结束时），在堆上的变量占据的内存<strong>不会被自动回收</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopedPtr</span>&#123;<br><span class="hljs-keyword">private</span>:<br>   Entity* m_Ptr;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">ScopedPtr</span>(Entity* ptr) : <span class="hljs-built_in">m_Ptr</span>(ptr) &#123;&#125;<br>   ~<span class="hljs-built_in">ScopedPtr</span>()&#123;<br>      <span class="hljs-keyword">delete</span> m_Ptr;<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   &#123;<br>      ScopedPtr e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>();  <span class="hljs-comment">// 等价于ScopedPtr e(new Entity()); 这里进行了一次隐形转换</span><br>   &#125;  <span class="hljs-comment">// 到这里在栈上分配的ScopedPtr生存周期结束，会调用析构函数把在堆上分配的内存回收。</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="智能指针（smart-pointer）"><a href="#智能指针（smart-pointer）" class="headerlink" title="智能指针（smart pointer）"></a>智能指针（smart pointer）</h1><p>当定义一个智能指针时，它会调用new分配内存，之后根据用的是哪个智能指针决定什么时候自动释放内存。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr是一个作用域指针，之所以叫unique_ptr是因为它是唯一的，<strong>不允许复制一个unique_ptr</strong>，因为当你复制之后就会出现两个指针指向同一片内存的情况，当一个unique_ptr死亡时它就会释放这片内存导致另一个unique_ptr指向一片被释放的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Entity</span>() &#123;<br><span class="hljs-built_in">Print</span>(<span class="hljs-string">&quot;Create Entity!&quot;</span>);<br>&#125;<br>~<span class="hljs-built_in">Entity</span>() &#123;<br><span class="hljs-built_in">Print</span>(<span class="hljs-string">&quot;Destroy Entity!&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>&#123;<br><span class="hljs-comment">// std::unique_ptr&lt;Entity&gt; e(new Entity()); </span><br>      std::unique_ptr&lt;Entity&gt; e = std::<span class="hljs-built_in">make_unique</span>&lt;Entity&gt;(); <span class="hljs-comment">// 等价于上面的写法，更加推荐！</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-04-24-13-01-12.png"></p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr和unique_ptr的区别就在于它<strong>允许复制</strong>，这是借助 <strong>引用计数（reference count）</strong> 实现的。当shared_ptr被复制之后，引用计数也会加一，当引用计数为0时，才释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>&#123;<br>std::shared_ptr&lt;Entity&gt; e0;<br>&#123;<br>std::shared_ptr&lt;Entity&gt; e = std::<span class="hljs-built_in">make_shared</span>&lt;Entity&gt;();<br>e0 = e;   <span class="hljs-comment">// 可以复制</span><br>&#125; <span class="hljs-comment">// 当e死亡时，不会释放Entity的内存</span><br>&#125; <span class="hljs-comment">// 当e0也死亡时，才会释放Entity内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2023-04-24-12-58-45.png"></p><h1 id="C-的复制和拷贝构造函数"><a href="#C-的复制和拷贝构造函数" class="headerlink" title="C++的复制和拷贝构造函数"></a>C++的复制和拷贝构造函数</h1><p><strong>尽量总是使用 “const引用” 作为函数参数！</strong>，否则会默认复制一个变量，造成性能浪费。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">const</span> Entity&amp; e)</span></span>&#123;<br>   <span class="hljs-comment">// 只要函数中不需要更改e</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p><strong>只会复制 “表面” 的内容</strong>，例如下面的代码，默认的拷贝构造函数只会复制这个类的成员（m_buffer和m_Size）而不会去复制m_buffer指向的内存。就会导致复制后的类实例中的m_buffer指针仍然指向原来m_buffer指向的内存，当析构函数调用时就会将同一片内存释放两次，程序崩溃；或者当要修改复制后的内容时连带原来的内容一起修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span>&#123;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">char</span>* m_buffer;<br>   <span class="hljs-type">int</span> m_Size;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   其他定义</span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-comment">// 默认拷贝构造函数</span><br>   <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; other) : <span class="hljs-built_in">m_buffer</span>(other.m_buffer), <span class="hljs-built_in">m_Size</span>(other.m_Size) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>与浅拷贝相对，在我们自己定义的类中需要<strong>重新写拷贝构造函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span>&#123;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">char</span>* m_buffer;<br>   <span class="hljs-type">int</span> m_Size;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   其他定义</span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-comment">// 默认拷贝构造函数</span><br>   <span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> String&amp; other) : <span class="hljs-built_in">m_Size</span>(other.m_Size) &#123;<br>      m_buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_Size + <span class="hljs-number">1</span>];<br>      <span class="hljs-built_in">memcopy</span>( m_buffer, other.m_buffer, m_Size + <span class="hljs-number">1</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>TCP和UDP</li><li>内存管理</li><li>进程线程（锁）</li><li>设计模式</li><li>右值</li><li>红黑树</li><li>渲染管线</li><li>渲染方程</li><li>tcp三次握手四次挥手</li><li>tcp和udp</li></ol>]]></content>
    
    
    <categories>
      
      <category>-[C++]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百人计划-动画TA-动作理论基础</title>
    <link href="/2023/03/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E5%8A%A8%E7%94%BBTA-%E5%8A%A8%E4%BD%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/29/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92-%E5%8A%A8%E7%94%BBTA-%E5%8A%A8%E4%BD%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Bh411t7AF?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20">百人计划-动画TA-动作理论基础</a></p><span id="more"></span><h1 id="动画基础知识"><a href="#动画基础知识" class="headerlink" title="动画基础知识"></a>动画基础知识</h1><h2 id="什么是运动"><a href="#什么是运动" class="headerlink" title="什么是运动"></a>什么是运动</h2><p>运动（translation）包括平移（position），旋转（rotation）和缩放（scale）（缩放一般用于夸张的卡通动画效果）。计算机角色动画的基础是骨骼动画，骨骼动画就是用某种方式驱动顶点的移动。</p><p><img src="/article_img/2023-03-29-13-40-25.png"></p><h2 id="蒙皮（Skining）"><a href="#蒙皮（Skining）" class="headerlink" title="蒙皮（Skining）"></a>蒙皮（Skining）</h2><p>蒙皮字面意思理解就是给骨骼蒙上一层皮肤，蒙皮系统以某种方式驱动哪些顶点去到哪里。</p><p><img src="/article_img/2023-03-29-13-43-09.png"></p><p>常见的蒙皮算法：</p><ol><li><strong>LBS(Linear Blending Skining)线性混合蒙皮</strong>，大步幅蒙皮都是这种方式，但是会有挤压重叠（可以添加辅助骨骼保持关节形状）</li><li><strong>DQS(Dual Quaternion Skining)双四元数蒙皮</strong>，游戏引擎不支持，如DAZ的模型</li><li><strong>JCM(Joint Controlled Morphs)骨骼驱动变形</strong>，等于PSD（Pose space deformations），用骨骼驱动morphs变形，如Metahuman</li><li><strong>RBF(Radial Basis Function)辅助骨骼驱动</strong>，除了关节还可以做一些肌肉的驱动</li><li><strong>RTSS(Real-time Skeletal Skining)基于优化旋转中心的实时骨骼蒙皮</strong>，比较新的概念</li></ol><h2 id="动画类型"><a href="#动画类型" class="headerlink" title="动画类型"></a>动画类型</h2><ol><li><strong>逐帧动画</strong>：sprite（精灵）动画</li><li><strong>骨骼动画</strong>：3D动画，spine动画（2D骨骼）</li><li><strong>顶点动画</strong>：物理模拟后的动画数据，用于不便于用骨骼驱动的布料，流体和破碎等等；<br>VAT(vertex animation texture)将每帧顶点数据记录到贴图上，贴图尺寸：帧数*顶点数<br>shader顶点动画，在vertex shader中控制顶点按照一定规律和公式做偏移动画，常用于草地摆动，海浪等<br>离线定点动画，离线渲染完成后导出abc文件到引擎</li></ol><h2 id="FK和IK"><a href="#FK和IK" class="headerlink" title="FK和IK"></a>FK和IK</h2><p>正向运动学和反向运动学，在DCC中的绑定用到了IK，在引擎中可以实时计算IK实现脚部对地面倾斜度的适配，牵手适配不同身高</p><h1 id="动画质量和流畅度"><a href="#动画质量和流畅度" class="headerlink" title="动画质量和流畅度"></a>动画质量和流畅度</h1><p>好的动画符合运动规律，运动轨迹是弧线</p><h2 id="如何营造打击感"><a href="#如何营造打击感" class="headerlink" title="如何营造打击感"></a>如何营造打击感</h2><p>首先打击感是结合视觉、听觉、特效等方面的综合表现营造的</p><ol><li><strong>合理的打击反馈</strong>，被大机房在受到攻击时一般会做出相应的受击反馈</li><li><strong>打击抽帧和顿帧</strong><br>击打后停顿的是抽帧，击打后震动的是顿帧<br>攻击的前摇后摇</li><li><strong>攻击节奏和按键反馈</strong></li><li><strong>硬直和打断</strong></li></ol><h2 id="夸张的魅力"><a href="#夸张的魅力" class="headerlink" title="夸张的魅力"></a>夸张的魅力</h2><ol><li><strong>挤压和拉伸</strong><br>挤压程度最大，表现出物体越Q弹；3D中起跳的先下蹲再伸展也是挤压和拉伸</li><li><strong>拖尾和变形</strong><br>二次元中是视觉残留，3D中就是运动模糊</li><li><strong>不正确的透视</strong></li><li><strong>时间操控</strong></li></ol><h1 id="动画表现提升点"><a href="#动画表现提升点" class="headerlink" title="动画表现提升点"></a>动画表现提升点</h1><h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><ol><li>写实：基本是动捕</li><li>美式卡通：挤压拉伸</li><li>日式卡通：保证五官形状</li></ol><h2 id="交互体验"><a href="#交互体验" class="headerlink" title="交互体验"></a>交互体验</h2><h2 id="动作状态融合"><a href="#动作状态融合" class="headerlink" title="动作状态融合"></a>动作状态融合</h2><p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/advanced-locomotion-system-v1">ALS</a></p><p><img src="/article_img/2023-03-29-14-23-17.png"></p><h1 id="吉比特训练营心得"><a href="#吉比特训练营心得" class="headerlink" title="吉比特训练营心得"></a>吉比特训练营心得</h1><h2 id="动作设计技巧"><a href="#动作设计技巧" class="headerlink" title="动作设计技巧"></a>动作设计技巧</h2><p><strong>武器是肢体动作的延申，特效是武器运动曲线的延申，敌人受击是特效的延申</strong>。但是不是说特效要完全贴合武器运动，而是尽力去描绘出连续的运动轨迹。</p><p>后摇时间要比较长，体现力量感；出招要快，一般会使用抽帧（最挤压和最拉伸之间抽帧）；动作要完整，和现实世界打击不同，构成完整的曲线或者运动轨迹（一般需要借助特效描绘运动轨迹和曲线）；</p><p>动作游戏中的受击方的受击动画可以瞬切，增加打击感。</p><h2 id="攻击部分程序实现"><a href="#攻击部分程序实现" class="headerlink" title="攻击部分程序实现"></a>攻击部分程序实现</h2><p><img src="/article_img/2023-08-16-19-28-58.png"></p><p>动作跳转：一般相同类型的动作不会打断前摇，只会打断后摇并形成连招；闪避等等其他动作可以打断后摇，如果玩家没有在前后摇之间进行闪避，通过指令缓存暂存等到前后摇再进行动作跳转。</p><h1 id="参考资料（下饭）"><a href="#参考资料（下饭）" class="headerlink" title="参考资料（下饭）"></a>参考资料（下饭）</h1><p><a href="https://www.bilibili.com/video/BV1Qt411v7ih/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20">动画十二法则</a><br><a href="https://www.bilibili.com/video/BV1Mt4y1X7oB/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20">动画师生存手册</a><br>游戏设计的236个技巧——大野功二</p>]]></content>
    
    
    <categories>
      
      <category>-[TA]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>百人计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MotionMactching基础</title>
    <link href="/2023/03/26/MotionMactching%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/26/MotionMactching%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>MotionMactching基础</p><span id="more"></span><table><thead><tr><th><img src="/article_img/mm_1.gif"></th><th><img src="/article_img/LMM_M.gif"></th><th><img src="/article_img/LMM_L.gif"></th></tr></thead></table><h1 id="Motion-Matching简介"><a href="#Motion-Matching简介" class="headerlink" title="Motion Matching简介"></a>Motion Matching简介</h1><p>Motion Matching是由育碧在GDC2016上提出的一项技术，可以使角色动作更加流畅和真实。与其他方法相比，它不需要在动作图中构造动画片段的结构，不需要仔细地切分或同步它们，也不需要在状态之间显式地创建新的转换。现如今已经被广泛应用在3A游戏中，如《荣耀战魂》，《刺客信条：奥德赛》以及最近的《黑神话：悟空》团队也表明他们也会使用Motion Matching技术。</p><h1 id="为什么要用Motion-Matching"><a href="#为什么要用Motion-Matching" class="headerlink" title="为什么要用Motion Matching"></a>为什么要用Motion Matching</h1><p>如果把游戏的动画系统想象成一个黑盒，我们希望用户输入指令，动画系统这个黑盒输出相应的动画。<br>动画状态机就是目前动画系统这个黑盒最常用的实现方式。<br><img src="/article_img/2023-03-26-13-35-34.png"></p><p>动画状态机需要设置不同的状态（例如走路，跑步），这些不同的状态分别对应不同的动画片段（Animation Clip），除了这些状态外还需要设置状态之间的切换条件，当满足这个条件时进行状态的切换也就是切换播放的动画片段。</p><p>动画状态机虽然很直观，但是其也有很多问题：</p><ol><li>复杂度高：动画状态机需要设计和编写，对于复杂的游戏角色，需要设计更多的状态和转换，使得状态机的复杂度变得很高，需要耗费更多的时间和精力。<br><img src="/article_img/2023-03-26-13-34-47.png"></li><li>难以处理动画过渡：动画状态机中的动画过渡需要手动设置，需要设计人员具有一定的动画技能和经验，否则可能会导致角色动画的不自然和不流畅。<br>**Is there a way to deal with loops and transitions in a uniform way?**——<a href="https://archive.org/details/GDC2016Clavet/page/n23/mode/2up">Simon Clavet - “Motion Matching and The Road to Next-Gen Animation”</a></li><li>难以适应变化：如果游戏需要进行修改或扩展，动画状态机可能需要进行重构或重写，这需要耗费更多的时间和精力。</li><li>有一些动作难以写入状态机<br><img src="/article_img/2023-03-26-15-28-33.png"></li></ol><p>为了解决这些问题，育碧提出了Motion Matching。</p><h1 id="Motion-Matching的发展史"><a href="#Motion-Matching的发展史" class="headerlink" title="Motion Matching的发展史"></a>Motion Matching的发展史</h1><h2 id="Motion-Graphs"><a href="#Motion-Graphs" class="headerlink" title="Motion Graphs"></a>Motion Graphs</h2><p><img src="/article_img/2023-03-26-14-43-26.png"></p><p>Motion Graphs是2002年的工作，他主要是对动画片段中的每一帧进行对比，得到最相似的两帧（可以是速度，位置，pose等等），就设置这两帧为可过渡点。</p><p><img src="/article_img/2023-03-26-15-03-35.png"></p><p>但是这篇工作中的过渡点是预先设定好的，导致动作反馈的及时性比较差，但是找到相似的动画作为下一帧动画的这个思想留给了后人。</p><h2 id="Motion-Fields"><a href="#Motion-Fields" class="headerlink" title="Motion Fields"></a>Motion Fields</h2><p><img src="/article_img/2023-03-26-14-42-38.png"></p><p>这个技术也是一个划时代的技术，其实现效果已经很接近motion matching了，但是其实现方式过于复杂。</p><p><img src="/article_img/2023-03-26-15-17-25.png"></p><p>具体就不讲了，可以参考<a href="https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20">games105-lecture06</a>，这篇工作虽然实现方式很复杂，但是其提供了一个重要的思想：我们可以转换到任何一个我们想要的动画帧。</p><p>motion matching就是在motion fields的基础上进行简化得来的。</p><h1 id="Motion-Matching的实现"><a href="#Motion-Matching的实现" class="headerlink" title="Motion Matching的实现"></a>Motion Matching的实现</h1><p><img src="/article_img/2023-03-26-15-19-55.png"></p><p>可以看出Motion Matching中最重要的就是<strong>如何找到动画数据库中满足用户输入的条件下与当前帧最相近的动画数据。</strong> 用其创始人Simon的话说，这是一个十分暴力的动画搜索方法。</p><p><img src="/article_img/2023-03-26-15-36-18.png"></p><h2 id="动画数据库（实现Motion-Matching的第一步）"><a href="#动画数据库（实现Motion-Matching的第一步）" class="headerlink" title="动画数据库（实现Motion Matching的第一步）"></a>动画数据库（实现Motion Matching的第一步）</h2><p><img src="/article_img/2023-03-26-15-38-16.png"></p><table><thead><tr><th><img src="/article_img/2023-03-26-15-38-26.png"></th><th><img src="/article_img/2023-03-26-15-38-35.png"></th><th><img src="/article_img/2023-03-26-15-38-40.png"></th></tr></thead></table><p>Motion Matching使用的动画数据大多来自动作捕捉，为了尽量高效的得到足够多的动作数据，育碧研究人员提出了一个概念叫Dance Card，动捕演员只需要按照Dance Card上的路径进行完成指定动作即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="/article_img/2023-03-26-15-42-58.png"><br><img src="/article_img/2023-03-26-15-43-07.png"><br><img src="/article_img/2023-03-26-15-48-40.png"></p><p>这就是育碧在GDC上给出的代码实现，也是Motion Matching的思路，十分简洁明了。可以看出关键点就是我们上文提出的如何选择下一个要过渡的动画帧，即<strong>ComputeCost</strong>这个函数。</p><p>源码把Cost分为了两部分（situation和trajectory）,我们把计算Cost更直观的分为三部分：</p><ol><li>姿态的Cost，表示候选动画帧姿态和当前姿态的匹配程度；</li><li>速度的Cost，表示候选动画帧的速度，加速度，角速度等信息与当前动画帧的匹配程度；</li><li>轨迹的Cost，表示候选动画帧轨迹和当前用户输入轨迹的匹配程度；</li></ol><p>当然各个Cost要加权平均得到最终的Cost！</p><h3 id="姿态Cost"><a href="#姿态Cost" class="headerlink" title="姿态Cost"></a>姿态Cost</h3><p>角色动画数据本质就是定义了每个关节的旋转和位置，以及一些运动速度等信息。</p><p>在姿势匹配阶段，我们不需要匹配每一个关节的旋转和位置，只需要选取几个重要的关节即可，因为这些关节已经可以很好的代表一个姿势了，一般是左右脚和尾椎骨，也可以根据需要添加，如荣耀战魂中还添加了武器的骨骼。</p><p><img src="/article_img/2023-03-26-16-07-46.png"><br><img src="/article_img/2023-03-26-16-08-09.png"></p><h3 id="速度Cost"><a href="#速度Cost" class="headerlink" title="速度Cost"></a>速度Cost</h3><p>和姿态Cost计算基本一样，直接对比动画数据即可。</p><h3 id="轨迹Cost"><a href="#轨迹Cost" class="headerlink" title="轨迹Cost"></a>轨迹Cost</h3><p><img src="/article_img/2023-03-26-16-10-17.png"></p><p>轨迹计算部分，育碧的源码考虑了未来几帧和过去几帧的位置和朝向，考虑未来的轨迹很好理解，为什么还要考虑过去的轨迹呢？如下图，有可能两个动作片段未来的行为一样，但是其过去不同，这时为了能更好的分辨出哪个动作片段更好，就需要引入过去的行为。</p><table><thead><tr><th><img src="/article_img/2023-03-26-16-13-26.png"></th><th><img src="/article_img/2023-03-26-16-13-32.png"></th></tr></thead></table><p>我们将计算的这些位置和朝向信息的Cost相加就是最终的Cost</p><table><thead><tr><th><img src="/article_img/2023-03-26-16-15-31.png"></th><th><img src="/article_img/2023-03-26-16-15-40.png"></th></tr></thead></table><h2 id="Motion-Matching的优化问题"><a href="#Motion-Matching的优化问题" class="headerlink" title="Motion Matching的优化问题"></a>Motion Matching的优化问题</h2><ol><li>提前计算特征</li><li>惯性化过渡</li><li>镜像数据表</li><li>LOD</li><li>KD-Tree</li><li>无需每帧都去寻找最优动画<br>因为如果用户没有改变输入，角色一直向前走，只需要从当前动画帧继续向后播放即可。</li></ol><p>可以发现，由于Motion Matching算法本身就是一个搜索算法，不论如何加速，都需要将数据库中的数据放入内存，而Motion Matching实现动画过渡真实自然的基础就是很大的动作数据库，因此Motion Matching对内存的占用很大，这也是限制其在移动端大量应用的原因。</p><h1 id="Learned-Motion-Matching"><a href="#Learned-Motion-Matching" class="headerlink" title="Learned Motion Matching"></a>Learned Motion Matching</h1><p><img src="/article_img/2023-03-26-18-32-27.png"></p><p>为了减小内存占用就要在Motion Matching实现过程中去除对动画数据库的依赖。Learned Motion Matching基于传统Motion Matching，用神经网络代替动画数据库，在实现了很好的动作效果的同时，大大降低了内存占用。</p><table><thead><tr><th><img src="/article_img/LMM_M.gif"></th><th><img src="/article_img/LMM_L.gif"></th></tr></thead></table><h2 id="传统Motion-Matching"><a href="#传统Motion-Matching" class="headerlink" title="传统Motion Matching"></a>传统Motion Matching</h2><p>首先我们先回顾一下Motion Matching：</p><p><img src="/article_img/2023-03-26-18-08-33.png"></p><p>动画片段是由一系列的姿势（full poses）组成的，每个姿势有一个帧序号（frame index）指出这个姿势在动画数据库中的位置，向后播放动画意味着每帧增加frame index并且从动画数据库中找到对应的姿势，每隔几帧做一次利用特征序列（当前姿态信息和由输入估计的轨迹）和特征数据库（提前计算好的动作特征）做对比实现的动作匹配搜索（Motion Matching Search），得到的最匹配的动画帧替换当前帧，作为下一帧继续播放。</p><h2 id="代替动作数据库"><a href="#代替动作数据库" class="headerlink" title="代替动作数据库"></a>代替动作数据库</h2><p><img src="/article_img/2023-03-26-18-26-36.png"></p><p>首先尝试去除对每帧进行的访问动作数据库的依赖，将直接去动作数据库中寻找动作替换成去特征数据库中寻找特征，找到的特征作为一个叫做Decompressor（可以理解为将动作特征解压成完整的动作）的神经网络的输入，由这个神经网络得到完整的姿势（这里是可行的，作者Daniel Holden的另一些工作PFNN就是尝试生成动作）</p><p><img src="/article_img/CompDecomp.gif"></p><p>图中灰色的是直接访问动作数据库生成的，橙色的是Decompressor生成的，可以看到动画效果几乎没有区别，但是仔细观察骨骼的手部，发现还是有差异，这是由于特征不足引起的，我们可以添加更多的特征，但是我们可以用另一个神经网络自动找到这些额外的特征：</p><p><img src="/article_img/2023-03-26-18-48-25.png"></p><p>添加了这个网络之后，动作质量更高了。</p><p><img src="/article_img/CompDecompWithExtraFeatures.gif"></p><p>当去掉了对动作数据库的依赖之后，内存减少了很多：<br><img src="/article_img/2023-03-26-18-50-00.png"></p><p>经过以上优化之后，整个过程如下图，但这时这两个特征数据库实际上还是随动作数据库的增大而增大，如果我们的动作数据库足够大，这两个特征数据库也会占用很大的内存。</p><p><img src="/article_img/2023-03-26-18-56-23.png"></p><p>下一步尝试在每一帧摆脱对特征数据库（Combined Features Database）的依赖。</p><h2 id="代替特征数据库"><a href="#代替特征数据库" class="headerlink" title="代替特征数据库"></a>代替特征数据库</h2><p>首先代替每一帧中的Feature Lookup，如果可以将每一帧的输入换成特征数据（当前动作的特征），可以训练一个神经网络叫做Stepper输出下一帧的动作特征，由于我们每隔几帧就会进行Motion Matching Search，因此这个Stepper网络只需要预测出之后很短一段时间动作特征的变化。此时整个逻辑如下：</p><p><img src="/article_img/2023-03-26-19-14-54.png"><br><img src="/article_img/2023-03-26-19-14-59.png"></p><p>最后我们再训练一个神经网络Projector，用来直接预测与当前输入特征最匹配的特征：</p><p><img src="/article_img/2023-03-26-19-17-06.png"></p><p>最终的整个Learned Motion Matching过程如下：<br><img src="/article_img/2023-03-26-19-17-26.png"></p><p>现在的内存比较：<br><img src="/article_img/2023-03-26-19-18-48.png"><br><img src="/article_img/2023-03-26-19-22-16.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://archive.org/details/GDC2016Clavet/mode/2up">GDC2016-Motion Matching</a><br><a href="https://montreal.ubisoft.com/en/introducing-learned-motion-matching/">introducing-learned-motion-matching</a> 中文翻译：<a href="https://zhuanlan.zhihu.com/p/611573006">Motion Matching的发展回顾</a><br><a href="https://zhuanlan.zhihu.com/p/378189446">简单聊聊Motion Matching</a><br><a href="https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20">Games105-计算机角色动画-06</a><br><a href="https://www.youtube.com/watch?v=o-QLSjSSyVk&t=254s">2018GDC-Character Control with Neural Networks and Machine Learning</a></p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnedMotionMactching复现</title>
    <link href="/2023/03/25/LearnedMotionMatching%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/03/25/LearnedMotionMatching%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>LearnedMotionMactching复现</p><span id="more"></span><p>在尝试跑LearnedMotionMatching代码的时候出现了很多问题，也是自己平时对编译源码不熟悉导致的，折腾了几天终于把代码跑起来了，记录一下遇到的问题和解决方法。<br><img src="/article_img/2023-03-25-14-47-55.png"></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://github.com/orangeduck/Motion-Matching">github: Learned Motion-Matching</a><br><a href="https://theorangeduck.com/page/code-vs-data-driven-displacement">article: Code vs Data Driven Displacement</a><br><a href="https://theorangeduck.com/page/learned-motion-matching">paper(siggraph2020): Learned Motion Matching</a></p><h1 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h1><p>这个演示Demo是基于raylib和raygui的（在国内很小众，是两个C++库用来开发一些小游戏），需要提前安装这两个库，建议都用github最新源码自行编译，否则会出现一些版本问题。</p><p><a href="https://github.com/raysan5/raylib">raylib</a><br><a href="https://github.com/raysan5/raygui">raygui</a></p><h2 id="raylib安装"><a href="#raylib安装" class="headerlink" title="raylib安装"></a>raylib安装</h2><p>下载好源码之后，创建一个raylib_build文件夹存放用CMake构建出的结果，之后在raylib_build中找到raylib.sln（vs项目文件），点击打开，生成解决方案，生成完毕之后会在&#x2F;raylib_build&#x2F;raylib&#x2F;路径下生成一个Debug文件夹，其中存放raylib.lib文件。这时raylib就已经安装完成了，但是我们还需要在vs2022中配置raylib库。</p><p><img src="/article_img/2023-03-25-15-11-00.png"></p><p>可以新建两个文件夹用来管理第三方库，Include文件夹存放.h文件，Libs文件夹存放.lib文件，这样之后就不需要去费力的寻找这些库文件了。</p><h2 id="raygui安装"><a href="#raygui安装" class="headerlink" title="raygui安装"></a>raygui安装</h2><p>raygui就简单多了，只需要从github下载源码即可，不需要自己编译，可以在src文件夹中找到raygui.h文件，将其放入上面我们建好的Include文件夹中即可。</p><h2 id="vs2022配置第三方库"><a href="#vs2022配置第三方库" class="headerlink" title="vs2022配置第三方库"></a>vs2022配置第三方库</h2><p><img src="/article_img/2023-03-25-15-16-38.png"></p><p>这里的包含目录直接填我们新建的Include文件夹，库目录填Libs文件夹即可。</p><p>感谢ChatGPT！</p><h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><h2 id="作者提供的方式"><a href="#作者提供的方式" class="headerlink" title="作者提供的方式"></a>作者提供的方式</h2><p>按照github上的<a href="https://github.com/orangeduck/Motion-Matching/issues/2">Issue</a>，其实这种方法理论上不需要编译raylib源码，直接去raylib官网下载Installer即可一键安装：</p><p><img src="/article_img/2023-03-25-15-20-53.png"></p><p>但是我在实际运行时出现了下图这样的错误，提示说UpdateCamera()缺少一个参数。</p><p><img src="/article_img/2023-03-25-15-24-46.png"></p><p><img src="/article_img/2023-03-25-15-26-06.png"></p><p>按照ChatGPT的回答，可以确定应该还是依赖库的版本问题，我这里就直接改了源码，将第二个参数设置为了CAMERA_CUSTOM，即可正常编译，生成controller.exe文件。</p><h2 id="VS2022编译方式"><a href="#VS2022编译方式" class="headerlink" title="VS2022编译方式"></a>VS2022编译方式</h2><p>考虑到之后可能会对源码进行修改，就尝试在VS里编译源码，我首先在VS中配置好了raylib和raygui，之后将源码中的文件全部添加到VS项目中，这是发现我的编译器似乎并不能识别部分源码的写法，如下：</p><p><img src="/article_img/2023-03-25-15-32-24.png"></p><p>这里将括号去掉就正常了。</p><p><img src="/article_img/2023-03-25-15-33-19.png"></p><p>这里写成下面的__restrict就可以识别了。</p><p><img src="/article_img/2023-03-25-15-36-39.png"></p><p>这里和上述一样随便加了一个参数。</p><p>这些写法问题解决之后，还不要忘了把源码中的resouce文件夹放到VS项目文件夹里，这样才能加载模型和数据库等等资源。</p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【边学边做】DreamGuard（New Input System的使用方法）</title>
    <link href="/2023/03/22/%5B%E8%BE%B9%E5%AD%A6%E8%BE%B9%E5%81%9A%5DDreamGuard/"/>
    <url>/2023/03/22/%5B%E8%BE%B9%E5%AD%A6%E8%BE%B9%E5%81%9A%5DDreamGuard/</url>
    
    <content type="html"><![CDATA[<p>记录学习unity开发中的各种问题和常见解决方法</p><span id="more"></span><h1 id="第三人称角色控制器"><a href="#第三人称角色控制器" class="headerlink" title="第三人称角色控制器"></a>第三人称角色控制器</h1><p>在开发DreamGuard的时候，原本打算使用unity自带的第三人称模板，但是发现其实现是基于New Input System，阅读代码出现困难，就想着自己实现一下。</p><h2 id="New-Input-System"><a href="#New-Input-System" class="headerlink" title="New Input System"></a>New Input System</h2><p><a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/index.html">官方文档</a></p><p><a href="https://www.bilibili.com/video/BV1tg411j7ni/?spm_id_from=333.880.top_right_bar_window_custom_collection.content.click&vd_source=93b215eab72b2548f75d0772e28f8b20">视频教程1</a></p><p><a href="https://www.bilibili.com/video/BV17h4y1W7Z2/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20">视频教程2</a></p><p>我对New Input System的理解是unity希望规范开发者对用户输入的处理。New Input System除了实现老版本输入系统的功能外，主要还方便了用户输入设备的切换（如从键盘切换到手柄）以及方便对不同输入模式的切换（如在游戏中空格代表跳跃，在ui界面中空格代表确定）</p><h3 id="新输入系统的几种用法"><a href="#新输入系统的几种用法" class="headerlink" title="新输入系统的几种用法"></a>新输入系统的几种用法</h3><p><img src="/article_img/2023-03-22-12-13-16.png"></p><p>按照官网的介绍，新输入系统有四种用法，第一种是和老版本输入系统类似的写法；后面三种都需要借助Actions Asset，可以在Project窗口右键创建，可以将其理解为配置输入的界面，通过Actions Asset就可以可视化的将输入分类，实现输入设备的切换和输入模式的切换。同时在配置Actions Asset时可以选择生成一个C#类来方便在代码中直接使用Actions Asset。</p><p><img src="/article_img/2023-08-12-12-34-07.png"></p><p>Action Maps方便区分输入场景，比如游戏中的输入和UI界面的输入；<br>Move，Look等等就是接收具体的输入了，input system可以方便的设置不同的输入设备并在其中切换。</p><h3 id="Using-an-Actions-Asset-and-a-PlayerInput-component"><a href="#Using-an-Actions-Asset-and-a-PlayerInput-component" class="headerlink" title="Using an Actions Asset and a PlayerInput component"></a>Using an Actions Asset and a PlayerInput component</h3><p>unity自带的第三人称模板使用的是第四种，这是一种我认为较为直观的使用方法，借助PlayerInput组件，可以选择要使用的Actions Asset以及输入时的行为，下图中的Behavior。</p><p><img src="/article_img/2023-03-22-12-25-07.png"></p><p>第三人称模板使用的Behavior是<a href="https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html">Send Messages</a>，这个方法是最简单的物体间的通信方法，他会将信息传递给该物体上附加的所有脚本；<a href="https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html">Broadcast Messages</a>会将信息传递给附加到该游戏对象及其所有子对象的每个脚本；<a href="https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html">Invoke Unity Events</a>对每个单独的消息类型使用单独的 UnityEvent；Invoke C Sharp Events和Invoke Unity Events类似，只是会触发一个C#事件。</p><p>由于Send Messages效率较低（？还不太懂为啥），所以我自己实现的第三人称控制器使用Invoke Unity Events方法。</p><p>这种方法需要配置Events，只需要为每个输入消息配置一个函数，就可以实现当有输入时，直接调用这个函数，使用起来十分方便。</p><p><img src="/article_img/2023-03-22-12-49-01.png"></p><h3 id="Using-an-Actions-Asset"><a href="#Using-an-Actions-Asset" class="headerlink" title="Using an Actions Asset"></a>Using an Actions Asset</h3><p>这种方法就对代码更加友好，其实和上述的第四种用法一样，需要勾选生成C#类选项：<br><img src="/article_img/2023-08-11-20-23-58.png"><br>之后在需要使用输入系统的脚本中就可以使用这个类了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>   <span class="hljs-keyword">public</span> PlayerInputControl inputControl; <span class="hljs-comment">// 声明生成的Actions Asset类</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span>&#123;<br>      inputControl = <span class="hljs-keyword">new</span> PlayerInputControl();<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>&#123;<br>      <span class="hljs-comment">// Gameplay是设定的Action Maps，Move是设置的监听移动的Actions</span><br>      inputDirection = inputControl.Gameplay.Move.ReadValue&lt;Vector2&gt;();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h2><p>第三人称控制器需要相机根据玩家鼠标的移动来回旋转，角色的移动是相对与玩家视角的移动（当玩家看向哪，前进方向就是哪），角色的旋转则永远指向角色的移动方向（不会随相机视角的旋转而旋转）。</p><h3 id="相机旋转"><a href="#相机旋转" class="headerlink" title="相机旋转"></a>相机旋转</h3><p>这里的相机使用了Cinemachine系统中的virtual camera，其可以实现跟随角色以及看向角色。</p><p><img src="/article_img/2023-03-22-12-56-23.png"></p><p>由于其会一直看向Look At设置的对象，因此要旋转相机只需要旋转相机看向的这个对象。在角色对象上添加一个空的子物体cameraLookAt，作为相机看向的方向。</p><p><img src="/article_img/2023-03-22-13-00-16.png"></p><p>在Actions Asset中设置输入，获取玩家鼠标的与上一帧的相对移动，由于是相对移动，直接将这个值不断累加并且映射到角度值，就可以得到cameraLookAt这个子物体的旋转值。注意只有在用户有输入时才改变旋转值，否则会导致用户没有输入时旋转值也为0，由旋转回默认方向。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CameraRotate</span>()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (lookDirection.sqrMagnitude &gt; <span class="hljs-number">0.1f</span>)<br>    &#123;<br>        cameraPitch += lookDirection.y;<br>        cameraYaw += lookDirection.x;<br>    &#125;<br>    cameraPitch = ClampAngle(cameraPitch, <span class="hljs-number">-70f</span>, <span class="hljs-number">70f</span>);<br>    cameraYaw = ClampAngle(cameraYaw, <span class="hljs-built_in">float</span>.MinValue, <span class="hljs-built_in">float</span>.MaxValue);<br><br>    cameraLookAt.transform.rotation = Quaternion.Euler(cameraPitch, cameraYaw, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="角色移动和旋转"><a href="#角色移动和旋转" class="headerlink" title="角色移动和旋转"></a>角色移动和旋转</h3><p>角色移动依靠Character Controller实现。</p><p>根据需要，角色需要是相对相机视角的移动，因此不能直接使用输入系统获取的相对与世界坐标系的方向，要将该方向变换到相机坐标系中。由于角色只在XZ平面移动，因此这种变换可以用欧拉角旋转实现。</p><p>先计算输入应该使角色旋转多少°（即相对与相机的旋转角度），再将这个值和相机旋转相加，得到世界坐标中应该旋转的值（因为Character Controller中的Move方法是相对与世界坐标系定义的）。这里的mainCamera就是现在游戏中正在起作用的相机!</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Csharp">targetRotation = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg + mainCamera.transform.rotation.eulerAngles.y;<br><span class="hljs-comment">// mainCamera = GameObject.FindGameObjectWithTag(&quot;MainCamera&quot;);在awake中得到</span><br></code></pre></td></tr></table></figure><p>有了最关键的移动方向，角色旋转和移动就很好实现了。</p><h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><p>在一开始的实现中，我将角色移动和旋转和相机旋转都放进了Update中，产生了奇怪的bug，发现原因是角色的旋转会带动其子物体cameraLookAt的旋转，导致角色旋转会带动玩家视角旋转，天旋地转。因此相机的旋转应该不受角色旋转的影响，只受玩家鼠标移动的控制。但是unity中子物体必然跟随父物体旋转，一个思路就是在角色旋转后，将相机再旋转回去，由于我们的旋转都是相对与世界坐标系的旋转，因此可以相机旋转放在LateUpdate中，在角色旋转后，再对相机进行旋转（这里容易产生误解，因为旋转是一个变换，其实在实现一个旋转时，每一帧都是从初始位置开始旋转的，只是旋转的角度不断增加产生旋转的效果，<strong>角色旋转后再对相机旋转，不需要向反方向旋转，因为相机还是从初始位置开始旋转，旋转的角度完全由鼠标移动控制</strong>）</p><h3 id="角色跳跃"><a href="#角色跳跃" class="headerlink" title="角色跳跃"></a>角色跳跃</h3><p>角色跳跃基于Character Controller组件的isGrounded，当角色在地面时才能跳跃，给予角色一个向上的速度即可，这个速度通过 <strong>v^2 &#x3D; 2gh</strong> 计算，这样可以方便控制角色跳跃的高度。</p><p>Character Controller并没有实现角色重力，要自己实现，只需要检测当角色不在地面时，给角色一个向下的速度，这个速度由 <strong>v&#x3D;gt</strong> 累加计算得来。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-keyword">if</span>(characterController.isGrounded)&#123;<br>   <span class="hljs-keyword">if</span>(verticalSpeed &lt; <span class="hljs-number">-1</span>) verticalSpeed = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 当角色落地后将竖直速度置零</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>   verticalSpeed += gravity * Time.deltaTime;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="地面检测"><a href="#地面检测" class="headerlink" title="地面检测"></a>地面检测</h3><p>地面检测可以使用函数 <strong>Physics2D</strong> 进行检测：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">physicsCheck</span> ： <span class="hljs-title">MonoBehaviour</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> isGround;<br><br>   <span class="hljs-keyword">public</span> LayerMask groundLayer; <span class="hljs-comment">// 指定对哪一些layer检测</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> checkRaduis;<br>   <span class="hljs-keyword">public</span> Vector2 bottomOffset;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>&#123;<br>      Check();<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Check</span>()</span>&#123;<br>      isGround = Physics2D.OverlapCircle((Vector)transform.position + bottomOffset, checkRadius, groundLayer);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmoSelected</span>()</span>&#123;<br>      Gizmos.DrawWireSphere((Vector2)transform.postion + bottomOffset, checkRaduis);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过改变Offset可以进行任何检测，比如检测角色是否碰到了墙。</p>]]></content>
    
    
    <categories>
      
      <category>-游戏Demo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>【边学边做】</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games105-1-数学基础</title>
    <link href="/2023/03/18/Games105-1-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/18/Games105-1-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Games105-1-数学基础</p><span id="more"></span><h1 id="线代基础"><a href="#线代基础" class="headerlink" title="线代基础"></a>线代基础</h1><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><p>点乘（Dot Product）的结果是点积，又称数量积或标量积（Scalar Product）</p><p><img src="/article_img/2023-03-18-18-56-04.png"></p><h3 id="点乘的几何意义"><a href="#点乘的几何意义" class="headerlink" title="点乘的几何意义"></a>点乘的几何意义</h3><p>点乘表示了a向量在b向量方向上的投影与b向量模的乘积，<strong>反映了两个向量在方向上的相似度</strong>。</p><p><img src="/article_img/2022-07-21-14-00-29.png"></p><h3 id="用来求向量夹角"><a href="#用来求向量夹角" class="headerlink" title="用来求向量夹角"></a>用来求向量夹角</h3><p><img src="/article_img/2023-03-18-19-00-23.png"></p><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><p>叉乘（Cross Product）又称向量积（Vector Product）</p><p><img src="/article_img/2023-03-18-18-56-36.png"></p><h3 id="叉乘的几何意义"><a href="#叉乘的几何意义" class="headerlink" title="叉乘的几何意义"></a>叉乘的几何意义</h3><p><img src="/article_img/2023-03-18-19-01-01.png"></p><p>叉乘的结果是一个垂直于a向量和b向量的向量，叉乘结果的模等于a向量和b向量围成的平行四边形的面积。</p><h3 id="叉乘的应用"><a href="#叉乘的应用" class="headerlink" title="叉乘的应用"></a>叉乘的应用</h3><ol><li><p>得到最小旋转，通过叉乘得到旋转轴，通过点乘得到旋转角度<br> <img src="/article_img/2023-03-18-19-05-21.png"></p></li><li><p>罗德里格斯旋转公式<br> <strong>将a向量绕着某个轴u旋转θ得到b向量，求b向量</strong><br> <img src="/article_img/2023-03-18-19-08-12.png"></p><p> 公式推导：<br> <img src="/article_img/2023-03-18-19-24-34.png"><br> <img src="/article_img/2023-03-29-13-26-38.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>-[Games105笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games105</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万向节死锁问题（Gimbal Lock）</title>
    <link href="/2023/03/17/%E4%B8%87%E5%90%91%E8%8A%82%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/17/%E4%B8%87%E5%90%91%E8%8A%82%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在Game104的动画章节中，讲解了欧拉角存在的问题，其中最难理解的就是欧拉角的万向节死锁问题，特此记录一下对这个问题的理解。</p><span id="more"></span><p>参考资料：<br><a href="https://www.bilibili.com/video/BV1Nr4y1j7kn/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20">bilibili_无伤理解欧拉角中的“万向死锁”现象</a></p><h1 id="欧拉角（Euler-Angle）"><a href="#欧拉角（Euler-Angle）" class="headerlink" title="欧拉角（Euler Angle）"></a>欧拉角（Euler Angle）</h1><p><img src="/article_img/2023-03-17-15-28-09.png"></p><p><img src="/article_img/2023-03-17-15-21-58.png"></p><p>欧拉证明了三维空间内的任意旋转，可以由围绕三个正交轴旋转组合而来。如上图所示，旋转用旋转矩阵表示，将围绕三个轴的旋转矩阵相乘即可得到实现任意旋转的旋转矩阵。</p><h1 id="万向节死锁（Gimbal-Lock）"><a href="#万向节死锁（Gimbal-Lock）" class="headerlink" title="万向节死锁（Gimbal Lock）"></a>万向节死锁（Gimbal Lock）</h1><div align=center><img src="/article_img/Gimbal_Lock.gif"/></div><p>一般用上图中的平衡环解释什么是万向节死锁。在平衡环案例中可以轻易看出万向节死锁发生的原理，两个环重叠在同一个平面，导致最外圈的大环旋转和最内圈的小环旋转的结果完全一样，都是绕竖直方向旋转。</p><p>产生这个现象有一个前提条件，即外圈环的旋转会带动内圈环的旋转，而内圈环的旋转不能带动外圈环的旋转。用坐标系来理解：我们规定一个旋转变换的顺序，按照绕X轴Y轴Z轴的顺序将三个旋转矩阵相乘得到最终旋转矩阵，绕X轴的旋转会带动Y轴和Z轴的旋转，Y轴的旋转只能带动Z轴的旋转，这就导致如果我们绕Y轴旋转90°，Y轴会带动Z轴也旋转90°而不会带动X轴旋转，此时Z轴就会和X轴重合，导致绕X、Z轴旋转的结果完全一样。</p><p>平衡环有这个前提条件是由于其机械结构，而我们在实现欧拉角变换的时候，为什么也要遵守这个规则呢？</p><p>首先明确一点：</p><p><img src="/article_img/2023-03-17-15-39-57.png"></p><p>这一点其实就是反直觉的，我们经常下意识地将欧拉角变换理解成，先绕X轴转动一定角度，再绕Y轴，Z轴旋转一定角度，物体的旋转会带动其局部坐标系一同旋转，绕Y轴旋转90°，Y轴会带动Z轴也旋转90°并且带动X轴旋转90°。而真实的欧拉角变换是，通过一个由矩阵相乘计算出的最终旋转矩阵直接对物体进行一个变换，也就是说<strong>欧拉角旋转是一步完成的一个变换</strong>。</p><p>当我们一旦规定绕三个正交轴旋转的先后循序，我们就确定了构成最终旋转矩阵的矩阵相乘顺序，而在矩阵乘法中没有交换律。</p><p>我们规定了三个矩阵的相乘顺序是XYZ，即为：<strong>X(0°) * Y(90°) * Z(0°)<strong>，由线性代数知识可知，</strong>左侧矩阵的变换会被应用到其右侧的所有矩阵</strong>，这也就是平衡环中大环会带动小环，而小环不能带动大环的数学解释，也是为什么众多解释万向死锁的文章都用平衡环演示的原因。</p><p><img src="/article_img/2023-03-17-16-13-42.png"></p><p>因此这个数学解释也就十分合理了。</p><h1 id="万向死锁造成的问题"><a href="#万向死锁造成的问题" class="headerlink" title="万向死锁造成的问题"></a>万向死锁造成的问题</h1><p>其实万向死锁之后，并不是这个物体就再也不能随心所欲的旋转了，而是如果想要旋转，就需要同时对三个轴都旋转，这就会导致其旋转的移动轨迹不在正交平面上，就会导致我们不期望的转动轨迹。</p><p>同过欧拉角实现的旋转动画，其每次只是应用一个变换，只是这个变换比上一帧应用的变换更近一步，产生了物体在转动的效果，也就是说，<strong>欧拉角旋转每次都是被作用在物体的初始状态上</strong>，这也可以进一步解释为什么上述案例中X轴会和Z轴重合，而不会随着物体转动而转动了，换个说法也就是在我们的直观理解中的<strong>新的X轴</strong>从来就不存在。</p><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>由我们上述的分析可知万向节死锁不可避免，不论怎样安排绕三个正交轴的旋转顺序，其中间的轴一旦旋转90°或-90°，均会产生万向节死锁。</p><p>在实际运用中，一般会根据旋转的具体场景，将最不可能旋转到90°的轴安排在中间，比如在unity中，物体在Scene视图中的移动就是欧拉角移动，unity将x轴安排在中间，因为绕X轴的旋转即Pitch一般不会到达90°。</p><p>在Unity中使用<a href="https://docs.unity3d.com/ScriptReference/Transform.Rotate.html">Transform.Rotate</a>实现欧拉的旋转。</p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机角色动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity快捷键总结</title>
    <link href="/2023/03/05/Unity%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2023/03/05/Unity%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>Unity快捷键总结</p><span id="more"></span><p><strong>Shift+鼠标点击左上角坐标系中间方块</strong>： 转换到透视试图<br><strong>q+左键</strong>： 拖拽<br><strong>alt+左键</strong>： 旋转<br><strong>点层级菜单中的物体+f&#x2F;双击物体</strong>： 聚焦到该物体</p>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender快捷键总结</title>
    <link href="/2023/02/24/Blender%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2023/02/24/Blender%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>Blender快捷键总结</p><span id="more"></span><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><ol><li><strong>鼠标中键</strong>： 旋转视角</li><li><strong>鼠标中键+shift</strong>： 平移视角</li><li><strong>tab</strong>： 进入编辑模式</li><li><strong>选中+1&#x2F;2&#x2F;3</strong>： 分别对物体的点&#x2F;线&#x2F;面进行操作</li><li>*<em>alt+z</em>： 透视模式选择</li><li>**~**： 切换视图（顶视图&#x2F;左视图等等） </li><li><strong>shift+s</strong>： 游标菜单（移动物体轴心的方法：先移动游标，再退出编辑模式右键物体，将轴心移动到游标）</li><li><strong>shift+a</strong>： 添加物体</li><li><strong>shift+b</strong>： 复制物体</li><li><strong>g+z&#x2F;x&#x2F;y</strong>： 沿x&#x2F;y&#x2F;z轴移动（按住ctrl标准距离移动）</li><li><strong>r+z&#x2F;x&#x2F;y</strong>： 绕z&#x2F;x&#x2F;y&#x2F;轴旋转</li><li><strong>ctrl+b</strong>： 倒角（使用滚轮细化倒角）</li><li><strong>ctrl+r</strong>： 添加环线</li><li><strong>alt+鼠标点击面&#x2F;线</strong>： 选择一圈所有的面&#x2F;线</li><li><strong>选中+s</strong>： 缩放</li><li><strong>选中面+i</strong>： InsertFace插入面</li><li><strong>选中一圈边+f</strong>： 填充面</li><li><strong>选中点+j</strong>： 连线</li><li><strong>ctrl+a</strong>： 应用菜单（如应用缩放）</li><li><strong>alt+s</strong>： 法线缩放（做尾巴用）</li><li><strong>alt+p</strong>：父级（建立父级，断开父级）</li><li><strong>ctrl+F2</strong>： 批量重命名</li><li><strong>ctrl+shift+c</strong>： 姿态模式下添加骨骼约束，将先选中的骨骼添加给后选中的骨骼</li><li><strong>ctrl+shift+v</strong>： 姿态模式下，镜像设置姿态</li></ol>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非真实感渲染入门</title>
    <link href="/2023/01/29/%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/"/>
    <url>/2023/01/29/%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>非真实感渲染入门</p><span id="more"></span><p><img src="/article_img/2023-01-29-20-58-10.png"></p><p>图形学渲染风格主要分为真实感渲染(Photorealistic rendering)和非真实感渲染(Non-photorealistic rendering，NPR)两大类。不同于真实感渲染是为了渲染出照片级别的画面，非真实感渲染主要在于模拟艺术化的绘制风格，呈现出手绘的效果。常见的非真实渲染技术包括卡通渲染、油画渲染、像素感渲染、铅笔画、素描画、蜡笔画和水墨画等类型。</p><h1 id="卡通渲染（Cel-Shading-Toon-Shading）"><a href="#卡通渲染（Cel-Shading-Toon-Shading）" class="headerlink" title="卡通渲染（Cel Shading&#x2F;Toon Shading）"></a>卡通渲染（Cel Shading&#x2F;Toon Shading）</h1><p>卡通渲染是NPR领域应用最广的渲染技术，在影视和游戏领域十分常见。如《你的名字》，塞尔达传说：荒野之息，Okami和原神等作品。</p><p><img src="/article_img/2023-01-29-17-48-34.png"><br><img src="/article_img/2023-01-29-17-48-09.png"></p><p>卡通渲染在游戏领域主要分为美式卡通风格和日式卡通风格两种。其中美式卡通色彩上比较连续，不会出现明显的色块分界线，如堡垒之夜；而日式卡通在着色方面会有明显的色块，色块的分界线清晰，如崩坏3。</p><p><img src="/article_img/2023-01-29-17-49-24.png"><br><img src="/article_img/2023-01-29-17-47-19.png"></p><h2 id="描边（Outline-Rendering）"><a href="#描边（Outline-Rendering）" class="headerlink" title="描边（Outline Rendering）"></a>描边（Outline Rendering）</h2><p>在Real-Time Rendering一书中将描边技术分为了以下五大类：基于法线和视角的描边( Shading Normal Contour Edges)、过程式的几何描边( Procedural Geometry Silhouetting)、基于图片处理的描边( Edge Detection by Image Processing)、基于轮廓线检测的描边( Geometric Contour Edge Detection)和混合以上几种描边方法(Hybrid Silhouetting)。</p><h3 id="基于法线和视角的描边"><a href="#基于法线和视角的描边" class="headerlink" title="基于法线和视角的描边"></a>基于法线和视角的描边</h3><p>通过观察，位于边缘的法线与视线方向的夹角接近90°，因此可以使用视线方向和法线方向的点积结果来获取轮廓线的信息。</p><p><img src="/article_img/2023-01-29-17-59-12.png"></p><p>但这种方法会导致描边的粗细不均匀。</p><p><img src="/article_img/2023-01-29-17-57-41.png"></p><h3 id="过程式几何描边"><a href="#过程式几何描边" class="headerlink" title="过程式几何描边"></a>过程式几何描边</h3><p>基本思路是通过两次绘制，第一次绘制角色，第二次绘制描边。绘制描边的时候，在顶点着色器将顶点沿着法线方向位移一段距离，使得模型轮廓放大，渲染作为描边。</p><p><img src="/article_img/2023-01-29-18-13-30.png"></p><p><img src="/article_img/2023-01-29-18-15-41.png"></p><h3 id="基于图像处理的方法"><a href="#基于图像处理的方法" class="headerlink" title="基于图像处理的方法"></a>基于图像处理的方法</h3><p>基于图像的算法是通过图像处理的方法来进行边缘检测，一般用于屏幕空间的检测。我们通常使用深度、法线、亮度和颜色等属性作为边缘判断的依据。</p><p><img src="/article_img/2023-01-29-18-19-47.png"></p><p><img src="/article_img/2023-01-29-18-24-21.png"></p><p>左上角是法线图，中上是深度图，左下是法线图得到的边缘，中下是深度图得到的边缘，右上是经过加粗（取周围一定范围内的最深的像素的颜色为自身的颜色）的边缘图，右下是最后的结果。</p><h2 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h2><p>在卡通渲染中，尤其是日式的卡通渲染中，色阶较少且着色一般不是连续的，存在非常明显的颜色分界线。</p><p><img src="/article_img/2023-01-29-19-14-03.png"></p><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p><img src="/article_img/2023-01-29-17-59-12.png"></p><p><img src="/article_img/2023-01-29-19-58-58.png"></p><p>漫反射亮度采用Lambert模型，再进行阈值化。一般会根据NdotL &#x3D; dot(normal，lightDir)的结果与阈值比较来指定不同的颜色值，从而模拟卡通色块的着色效果；除了这种方法之外，更常见的处理方式是利用NdotL的结果从一维渐变纹理RampTexture中进行采样</p><table><thead><tr><th><img src="/article_img/2023-01-29-19-24-00.png"></th><th><img src="/article_img/2023-01-30-13-26-02.png"></th></tr></thead></table><p>有些时候也会使用平滑阶跃函数柔化明暗边界，这样比较容易使角色与场景融合也起到一定的抗锯齿效果。</p><p><img src="/article_img/2023-01-29-19-37-56.png"></p><h3 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h3><p><img src="/article_img/2023-01-29-19-28-42.png"></p><p>根据法线和半向量的点积，与高光阈值比较，控制高光的范围。</p><p>Stylized highlights for cartoon rendering and animation<br><a href="https://blog.csdn.net/candycat1992/article/details/50167285">风格化高光</a><br><img src="/article_img/2023-01-30-13-46-43.png"></p><h3 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h3><p>物体的边缘会有一圈边缘光，实现比轮廓线更好的边界区分效果。这里的实现和基于法线和视角的描边一样。</p><p><img src="/article_img/2023-01-30-13-57-25.png"></p><h2 id="NPR与PBR的结合"><a href="#NPR与PBR的结合" class="headerlink" title="NPR与PBR的结合"></a>NPR与PBR的结合</h2><p><img src="/article_img/2023-01-30-15-47-25.png"> </p><table><thead><tr><th><img src="/article_img/2023-01-30-20-10-34.png"></th><th><img src="/article_img/2023-01-30-20-12-26.png"></th><th><img src="/article_img/2023-01-30-20-14-01.png"></th><th><img src="/article_img/2023-01-30-20-18-46.png"></th></tr></thead></table>]]></content>
    
    
    <categories>
      
      <category>-[笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NPR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learnopengl-5-摄像机</title>
    <link href="/2022/11/12/learnopengl-5-%E6%91%84%E5%83%8F%E6%9C%BA/"/>
    <url>/2022/11/12/learnopengl-5-%E6%91%84%E5%83%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>learnopengl-5-摄像机</p><span id="more"></span><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/">摄像机-LearnOpenGL CN</a></p><p>OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。所以其实是根据view矩阵移动场景中的顶点。</p><h1 id="摄像机-观察空间"><a href="#摄像机-观察空间" class="headerlink" title="摄像机&#x2F;观察空间"></a>摄像机&#x2F;观察空间</h1><p>观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标，定义一个摄像机需要在世界空间中的位置，摄像机看向的方向，一个指向右侧的向量和一个指向上方的向量。</p><p><img src="/article_img/2022-11-12-14-23-16.png"></p><h2 id="摄像机位置"><a href="#摄像机位置" class="headerlink" title="摄像机位置"></a>摄像机位置</h2><p>摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">glm::vec3 cameraPos = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-number">3.0f</span>);<br></code></pre></td></tr></table></figure><h2 id="摄像机方向"><a href="#摄像机方向" class="headerlink" title="摄像机方向"></a>摄像机方向</h2><p>相机位置减看向的点，得到摄像机看向方向的<strong>反方向</strong>，看上面的图，相机z轴的正方向与实际观察方向相反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">glm::vec3 cameraTarget = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<br>glm::vec3 cameraDirection = glm::<span class="hljs-built_in">normalize</span>(cameraPos - cameraTarget);<br></code></pre></td></tr></table></figure><h2 id="右轴"><a href="#右轴" class="headerlink" title="右轴"></a>右轴</h2><p>先定义一个向上向量，之后将这个向量与上一步的摄像机方向向量做叉乘，得到向右向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">glm::vec3 up = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>); <br>glm::vec3 cameraRight = glm::<span class="hljs-built_in">normalize</span>(glm::<span class="hljs-built_in">cross</span>(up, cameraDirection));<br></code></pre></td></tr></table></figure><h2 id="上轴"><a href="#上轴" class="headerlink" title="上轴"></a>上轴</h2><p>将向右向量与相机方向向量做叉乘得到向上方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">glm::vec3 cameraUp = glm::<span class="hljs-built_in">cross</span>(cameraDirection, cameraRight);<br></code></pre></td></tr></table></figure><h1 id="Look-At"><a href="#Look-At" class="headerlink" title="Look At"></a>Look At</h1><p><img src="/article_img/2022-11-12-14-39-20.png"></p><p>三个不线性相关的向量，可以构建一个向量空间，LookAt矩阵的含义就是先将场景中的点相对于相机位置移动（右侧矩阵），再将点从世界坐标转换到摄像机空间坐标（左侧矩阵）</p><p>使用GLM的lookAt函数可以方便的定义lookAt矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">glm::mat4 view;<br>view = glm::<span class="hljs-built_in">lookAt</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">3.0f</span>), <br>           glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), <br>           glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>));<br></code></pre></td></tr></table></figure><h1 id="自由移动"><a href="#自由移动" class="headerlink" title="自由移动"></a>自由移动</h1><p>之前GLFW的键盘输入已经定义过一个processInput函数了，添加对WASD的检测即可，之后当对应的按键按下时，向对应方向移动（让相机位置加上对应方向的向量）即可。</p><p>为了在不同的设备上的相机移动速度相同，需要跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。</p><h1 id="视角移动"><a href="#视角移动" class="headerlink" title="视角移动"></a>视角移动</h1><h2 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h2><ol><li>Pitch(俯仰角)</li><li>Yaw(偏航角)</li><li>Row(滚转角)</li></ol><p><img src="/article_img/2022-11-12-14-57-30.png"></p><p>在一般的摄像机系统中，不考虑Row的影响。</p><p>视角移动就是通过pitch和yaw直接得出摄像机方向。</p><p><img src="/article_img/2022-11-12-15-18-18.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">direction.x = <span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(pitch)) * <span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(yaw)); <span class="hljs-comment">// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span><br>direction.y = <span class="hljs-built_in">sin</span>(glm::<span class="hljs-built_in">radians</span>(pitch));<br>direction.z = <span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(pitch)) * <span class="hljs-built_in">sin</span>(glm::<span class="hljs-built_in">radians</span>(yaw));<br></code></pre></td></tr></table></figure><h2 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mouse_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">double</span> xpos, <span class="hljs-type">double</span> ypos)</span></span>;<br><br><span class="hljs-comment">// 在main函数中启用</span><br><span class="hljs-built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);<br></code></pre></td></tr></table></figure><p>xpos和ypos记录了鼠标的位置，用GLFW注册了回调函数之后，鼠标一移动就会调用mouse_callback函数，并且得到鼠标位置。</p><p>得到鼠标位置之后，需要和上一帧的鼠标位置对比，如果鼠标上下移动就是要调整pitch，左右移动就是调整yaw</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">float</span> xoffset = xpos - lastX;<br><span class="hljs-type">float</span> yoffset = lastY - ypos; <span class="hljs-comment">// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的</span><br>lastX = xpos;<br>lastY = ypos;<br><br><span class="hljs-type">float</span> sensitivity = <span class="hljs-number">0.05f</span>;<br>xoffset *= sensitivity;<br>yoffset *= sensitivity;<br><br>yaw   += xoffset;<br>pitch += yoffset;<br><br><span class="hljs-comment">// 保证用户能看到的最大范围</span><br><span class="hljs-keyword">if</span>(pitch &gt; <span class="hljs-number">89.0f</span>)<br>  pitch =  <span class="hljs-number">89.0f</span>;<br><span class="hljs-keyword">if</span>(pitch &lt; <span class="hljs-number">-89.0f</span>)<br>  pitch = <span class="hljs-number">-89.0f</span>;<br></code></pre></td></tr></table></figure><p>这里需要给xoffset和yoffset乘一个灵敏度（应为0到1之间），否者相当于直接将偏移值当作了角度变化值，就会导致视角移动过大。</p><h1 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h1><p>缩放依靠fov的变化即可，fov越小，看到的图像就越大，就产生了放大的感觉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scroll_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">double</span> xoffset, <span class="hljs-type">double</span> yoffset)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(fov &gt;= <span class="hljs-number">1.0f</span> &amp;&amp; fov &lt;= <span class="hljs-number">45.0f</span>)<br>    fov -= yoffset;<br>  <span class="hljs-keyword">if</span>(fov &lt;= <span class="hljs-number">1.0f</span>)<br>    fov = <span class="hljs-number">1.0f</span>;<br>  <span class="hljs-keyword">if</span>(fov &gt;= <span class="hljs-number">45.0f</span>)<br>    fov = <span class="hljs-number">45.0f</span>;<br>&#125;<br><br><span class="hljs-comment">// 注册回调函数</span><br><span class="hljs-built_in">glfwSetScrollCallback</span>(window, scroll_callback);<br><br><span class="hljs-comment">// 在main函数中将投影矩阵的fov也相应改变</span><br>projection = glm::<span class="hljs-built_in">perspective</span>(glm::<span class="hljs-built_in">radians</span>(fov), <span class="hljs-number">800.0f</span> / <span class="hljs-number">600.0f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li>看看你是否能够修改摄像机类，使得其能够变成一个真正的FPS摄像机（也就是说不能够随意飞行）；你只能够呆在xz平面上：<br>只需要设定相机只能朝前或后移动，不能朝相机看向方向移动。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">glm::vec3 WorldFront = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>);<br><span class="hljs-type">float</span> velocity = MovementSpeed * deltaTime;<br><span class="hljs-keyword">if</span> (direction == FORWARD)<br>   Position += WorldFront * velocity;<br><span class="hljs-keyword">if</span> (direction == BACKWARD)<br>   Position -= WorldFront * velocity;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>-[OpenGL笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learnopengl-4-变换和坐标系</title>
    <link href="/2022/11/02/learnopengl-4-%E5%8F%98%E6%8D%A2%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
    <url>/2022/11/02/learnopengl-4-%E5%8F%98%E6%8D%A2%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>learnopengl-4-变换和坐标系</p><span id="more"></span><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">坐标系统-LearnOpenGL CN</a></p><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">变换-LearnOpenGL CN</a></p><h1 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h1><p>这一部分设计线性代数的知识，以及在<a href="Games101-2-%E5%8F%98%E6%8D%A2.md">games101</a>中有过详细介绍，因此这一部分主要记录在OpenGL中的实践，原理不过多解释（如果之后看了<a href="https://www.bilibili.com/video/BV1ys411472E/?spm_id_from=333.999.0.0">线性代数的本质</a>再进行补充）</p><h2 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h2><p>GLM是OpenGL Mathematics的缩写，它是一个只有头文件的库,把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/glm.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span><br></code></pre></td></tr></table></figure><p>这个库使用方法有些独特，定义变换矩阵十分方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">glm::mat4 trans; <span class="hljs-comment">// 定义单位矩阵</span><br>trans = glm::<span class="hljs-built_in">translate</span>(trans, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>));  <span class="hljs-comment">// 定义位移矩阵调用tranlate函数，参数是位移向量</span><br>trans = glm::<span class="hljs-built_in">rotation</span>(trans, glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">90.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)); <span class="hljs-comment">// 定义旋转矩阵调用rotation函数，参数是旋转角度和旋转轴</span><br>trans = glm::<span class="hljs-built_in">scale</span>(trans, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)); <span class="hljs-comment">// 定义缩放矩阵调用scale函数，参数是x,y,z方向上的缩放值</span><br></code></pre></td></tr></table></figure><p>这些矩阵都是在trans的基础上生成的，相当于和trans右乘，按上面的代码就是先做缩放变换，之后旋转变换，最后位移变换。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>只需要在顶点着色器中定义一个uniform，将变换矩阵传递进shader，和原来的顶点坐标相乘:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">0</span>) in vec3 aPos;<br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">1</span>) in vec2 aTexCoord;<br><br>out vec2 TexCoord;<br><br>uniform mat4 transform;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    gl_Position = transform * <span class="hljs-built_in">vec4</span>(aPos, <span class="hljs-number">1.0f</span>);<br>    TexCoord = <span class="hljs-built_in">vec2</span>(aTexCoord.x, <span class="hljs-number">1.0</span> - aTexCoord.y);<br>&#125;<br></code></pre></td></tr></table></figure><p>在程序中将变换矩阵传递给uniform:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> transformLoc = <span class="hljs-built_in">glGetUniformLocation</span>(ourShader.ID, <span class="hljs-string">&quot;transform&quot;</span>);<br><span class="hljs-built_in">glUniformMatrix4fv</span>(transformLoc, <span class="hljs-number">1</span>, GL_FALSE, glm::<span class="hljs-built_in">value_ptr</span>(trans));<br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>使用应用在箱子上的最后一个变换，尝试将其改变为先旋转，后位移。看看发生了什么，试着想想为什么会发生这样的事情：<br><img src="/article_img/2022-11-02-15-31-22.png"><br>会绕着原点旋转，这里是因为旋转操作都是默认绕原点的，代码中的先旋转后位移在实际变换时是先位移后旋转；<br>如果希望绕任意一点旋转，需要再加一个位移矩阵。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">glm::mat4 trans; <br>trans = glm::<span class="hljs-built_in">translate</span>(trans, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>));<br>trans = glm::<span class="hljs-built_in">rotate</span>(trans, (<span class="hljs-type">float</span>)<span class="hljs-built_in">glfwGetTime</span>(), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>));<br>trans = glm::<span class="hljs-built_in">translate</span>(trans, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>));<br></code></pre></td></tr></table></figure><img src="/article_img/2022-11-02-15-34-54.png"></li><li>尝试再次调用glDrawElements画出第二个箱子，只使用变换将其摆放在不同的位置。让这个箱子被摆放在窗口的左上角，并且会不断的缩放（而不是旋转）。（sin函数在这里会很有用，不过注意使用sin函数时应用负值会导致物体被翻转）<br><img src="/article_img/2022-11-02-15-36-15.png"><br>这里注意调用glDrawElements画出第二个箱子时不需要再绑定别的VAO，但是在画之前要重置变换矩阵，否则就是在同一个位置画了两次，完全看不出。</li></ol><h1 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h1><p><img src="/article_img/2022-11-10-16-13-36.png"></p><p>“我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。”</p><h2 id="局部空间（Local-Space）"><a href="#局部空间（Local-Space）" class="headerlink" title="局部空间（Local Space）"></a>局部空间（Local Space）</h2><p>就像在Blender中创建了一个立方体，原点有可能位于(0, 0, 0)</p><h2 id="世界空间（World-Space）"><a href="#世界空间（World-Space）" class="headerlink" title="世界空间（World Space）"></a>世界空间（World Space）</h2><p>世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。就是将不同的模型摆放在世界的不同位置，该变换由模型矩阵（Model Matrix）实现。</p><p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。</p><h2 id="观察空间（View-Space）"><a href="#观察空间（View-Space）" class="headerlink" title="观察空间（View Space）"></a>观察空间（View Space）</h2><p>观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)），由视图矩阵（View Matrix）实现。</p><h2 id="裁剪空间（Clip-Space）"><a href="#裁剪空间（Clip-Space）" class="headerlink" title="裁剪空间（Clip Space）"></a>裁剪空间（Clip Space）</h2><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。</p><p>投影矩阵分为透视投影（Perspective Projection Matrix）和正交投影（Orthographic Projection Matrix）</p><p>正交投影视锥（Frustum）<br><img src="/article_img/2022-11-10-16-26-15.png"><br>透视投影视锥（Frustum）<br><img src="/article_img/2022-11-10-16-25-36.png"></p><p>两种投影方法的对比：<br><img src="/article_img/2022-11-10-16-24-26.png"></p><p>在OpenGL中的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 正交投影</span><br>glm::<span class="hljs-built_in">ortho</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">800.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">600.0f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br><span class="hljs-comment">// 透视投影</span><br>glm::mat4 proj = glm::<span class="hljs-built_in">perspective</span>(glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">45.0f</span>), (<span class="hljs-type">float</span>)width/(<span class="hljs-type">float</span>)height, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure><h2 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h2><p><img src="/article_img/2022-11-10-16-28-11.png"></p><p>经过Model-View-Projection变换，物体坐标就被变换到了裁剪坐标，之后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标，最后进行视口变换，将坐标映射到屏幕上的每一个像素。</p><h2 id="Z缓冲（Z-Buffer）"><a href="#Z缓冲（Z-Buffer）" class="headerlink" title="Z缓冲（Z-Buffer）"></a>Z缓冲（Z-Buffer）</h2><p>OpenGL自动进行深度测试，判断物体的遮挡关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">glEnable</span>(GL_DEPTH_TEST);<br><br><span class="hljs-comment">// 清理深度缓冲</span><br><span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br></code></pre></td></tr></table></figure><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ol><li>使用模型矩阵只让是3倍数的箱子旋转（以及第1个箱子），而让剩下的箱子保持静止<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>   glm::mat4 model;<br>   model = glm::<span class="hljs-built_in">translate</span>(model, cubePositions[i]);<br>   <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>         model = glm::<span class="hljs-built_in">rotate</span>(model, (<span class="hljs-type">float</span>)<span class="hljs-built_in">glfwGetTime</span>() * glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">50.0f</span>), cubePositions[i] + glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.5f</span>));<br>   &#125;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> modelLoc = <span class="hljs-built_in">glGetUniformLocation</span>(ourShader.ID, <span class="hljs-string">&quot;model&quot;</span>);<br>   <span class="hljs-built_in">glUniformMatrix4fv</span>(modelLoc, <span class="hljs-number">1</span>, GL_FALSE, glm::<span class="hljs-built_in">value_ptr</span>(model));<br><br>   <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article_img/2022-11-10-16-34-14.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>-[OpenGL笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learnopengl-3-纹理</title>
    <link href="/2022/11/01/learnopengl-3-%E7%BA%B9%E7%90%86/"/>
    <url>/2022/11/01/learnopengl-3-%E7%BA%B9%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>learnopengl-3-纹理</p><span id="more"></span><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/">纹理-LearnOpenGL CN</a></p><p>纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。</p><h1 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h1><p>用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。</p><p><img src="/article_img/2022-11-01-16-58-12.png"></p><p>纹理坐标格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> texCoords[] = &#123;<br>    <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下角</span><br>    <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下角</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span> <span class="hljs-comment">// 上中</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h1><table><thead><tr><th align="center">环绕方式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">GL_REPEAT</td><td align="center">对纹理的默认行为。重复纹理图像。</td></tr><tr><td align="center">GL_MIRRORED_REPEAT</td><td align="center">和GL_REPEAT一样，但每次重复图片是镜像放置的。</td></tr><tr><td align="center">GL_CLAMP_TO_EDGE</td><td align="center">纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td></tr><tr><td align="center">GL_CLAMP_TO_BORDER</td><td align="center">超出的坐标为用户指定的边缘颜色</td></tr></tbody></table><p><img src="/article_img/2022-11-01-17-15-23.png"></p><p>用法：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);<br></code></pre></td></tr></table></figure><p>可以单独对坐标轴设置纹理环绕方式。</p><p>GL_CLAMP_TO_BORDER 方式由于是用户指定的边缘颜色，因此要再指定一个边缘的颜色，同时也不需要再指定坐标轴了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">float</span> borderColor[] = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>&#125;;<br><span class="hljs-built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);<br></code></pre></td></tr></table></figure><h1 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h1><h2 id="纹理像素（Texture-Pixel）"><a href="#纹理像素（Texture-Pixel）" class="headerlink" title="纹理像素（Texture Pixel）"></a>纹理像素（Texture Pixel）</h2><p>Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素，其实就是<strong>纹理的分辨率</strong>。</p><p>如果要将一个分辨率较低的纹理加在一个很大的物体上，看上去物体的分辨率就很低，为了减轻这种现象，需要纹理过滤。</p><h2 id="纹理过滤-1"><a href="#纹理过滤-1" class="headerlink" title="纹理过滤"></a>纹理过滤</h2><p>这一部分在<a href="Games101-4-%E7%9D%80%E8%89%B2.md">Games101-着色</a>中有过详细介绍</p><ol><li>邻近过滤（GL_NEAREST）<br><img src="/article_img/2022-11-01-17-16-23.png"></li><li>线性过滤（GL_LINEAR）<br><img src="/article_img/2022-11-01-17-16-55.png"><br>使用的算法就是双线性插值，由周围几个像素的颜色算出最终应该采用的颜色。<br><img src="/article_img/2022-08-29-18-33-20.png"></li></ol><p>下图是两种过滤方法的效果对比<br><img src="/article_img/2022-11-01-17-17-08.png"></p><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER， GL_NEAREST);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER， GL_LINEAR);<br></code></pre></td></tr></table></figure><h1 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h1><p>这一部分也在<a href="Games101-4-%E7%9D%80%E8%89%B2.md">Games101-着色</a>中有过详细介绍</p><p>当物体很小，而纹理分辨率很大的时候难以决定最终真正显示的像素的颜色，因为最终可见的像素很可能覆盖了纹理贴图上的很大一部分，同时还会产生很多浪费。</p><p>OpenGL中使用Mipmap解决这个问题。</p><p><img src="/article_img/2022-08-29-18-41-41.png"></p><p>可以使用glGenerateMipmaps函数来自动生成Mipmap</p><p><img src="/article_img/2022-11-01-17-30-18.png"></p><p>在切换Mipmap时，在两个层之间会产生生硬的边界，因此在切换时也需要过滤。</p><table><thead><tr><th align="center">过滤方式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">GL_NEAREST_MIPMAP_NEAREST</td><td align="center">使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td></tr><tr><td align="center">GL_LINEAR_MIPMAP_NEAREST</td><td align="center">使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td></tr><tr><td align="center">GL_NEAREST_MIPMAP_LINEAR</td><td align="center">在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td></tr><tr><td align="center">GL_LINEAR_MIPMAP_LINEAR</td><td align="center">在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td></tr></tbody></table><p><img src="/article_img/2022-08-29-18-52-05.png"></p><p>这里看这个三线性插值（GL_LINEAR_MIPMAP_LINEAR）的原理图就很容易理解，GL_<strong>A</strong>_MIPMAP_<strong>B</strong> 中<strong>A</strong>是指不同层级之间的切换方式，<strong>B</strong>指每个层级内部的选择方式。</p><p>使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br></code></pre></td></tr></table></figure><p>注意：<br>函数的第二个参数，是分别设置纹理缩小时过滤和纹理放大时过滤的参数。<strong>Mipmap只在纹理被缩小时有效。</strong></p><h1 id="加载与创建纹理"><a href="#加载与创建纹理" class="headerlink" title="加载与创建纹理"></a>加载与创建纹理</h1><h2 id="stb-image-h"><a href="#stb-image-h" class="headerlink" title="stb_image.h"></a>stb_image.h</h2><p>加载纹理使用stb_image.h头文件，这个头文件中就包含了函数的实现，因此只需要将其添加到工程中，再创建一个C++文件输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stb_image.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>即可调用<strong>stbi_load</strong>函数进行图片的加载。</p><h2 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h2><p>生成一个纹理的过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> texture;<br><span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;texture);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);<br><span class="hljs-comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span><br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   <br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><span class="hljs-comment">// 加载并生成纹理</span><br><span class="hljs-type">int</span> width, height, nrChannels;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *data = <span class="hljs-built_in">stbi_load</span>(<span class="hljs-string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (data)<br>&#123;   <br>    <span class="hljs-comment">// 生成纹理</span><br>    <span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);<br>    <span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">stbi_image_free</span>(data);<br></code></pre></td></tr></table></figure><h1 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h1><h2 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h2><p>纹理的应用需要相应的改变着色器代码，在顶点着色器中设定一个输出向量将纹理坐标传给片段着色器，在片段着色器中定义一个类型是sampler2D的uniform用来接收纹理图片，最后调用GLSL中的texture函数来采样纹理的颜色。</p><p>sampler2D是一个GLSL的数据类型，叫做采样器，还有sampler1D, sampler3D, 用来把纹理对象传给片段着色器。</p><p>顶点着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">0</span>) in vec3 aPos;<br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">1</span>) in vec3 aColor;<br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">2</span>) in vec2 aTexCoord;<br><br>out vec3 ourColor;<br>out vec2 TexCoord;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    gl_Position = <span class="hljs-built_in">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    ourColor = aColor;<br>    TexCoord = aTexCoord;<br>&#125;<br></code></pre></td></tr></table></figure><p>片段着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec3 ourColor;<br>in vec2 TexCoord;<br><br>uniform sampler2D ourTexture;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FragColor = <span class="hljs-built_in">texture</span>(ourTexture, TexCoord);<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);<br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h2><p><img src="/article_img/2022-11-02-15-10-07.png"></p><p>纹理单元的目的是为了让我们可以使用多个纹理，通过把纹理单元<strong>赋值</strong>给采样器，我们可以一次绑定多个纹理，只要我们首先<strong>激活</strong>对应的纹理单元；</p><p>OpenGL保证有16个纹理单元供使用，且GL_TEXTRUE0默认被激活，所以只用一个纹理时可以不激活纹理单元0。</p><p>使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><br><span class="hljs-comment">// 激活纹理单元并将纹理绑定到相应的纹理单元</span><br><span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);<br><span class="hljs-built_in">glTexImage2D</span>(..., data1);<br><span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br><span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE1);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);<br><span class="hljs-built_in">glTexImage2D</span>(..., data2);<br><span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D)<br><br><span class="hljs-comment">// 设置uniform的值</span><br>ourShader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">0</span>);<br>ourShader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture2&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><p>修改片段着色器，仅让笑脸图案朝另一个方向看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">FragColor = <span class="hljs-built_in">mix</span>(<span class="hljs-built_in">texture</span>(texture1, TexCoord), <span class="hljs-built_in">texture</span>(texture2, <span class="hljs-built_in">vec2</span>(<span class="hljs-number">1.0</span> - TexCoord.x, TexCoord.y)), <span class="hljs-number">0.2</span>);<br></code></pre></td></tr></table></figure></li><li><p>尝试用不同的纹理环绕方式，设定一个从0.0f到2.0f范围内的（而不是原来的0.0f到1.0f）纹理坐标。试试看能不能在箱子的角落放置4个笑脸。记得一定要试试其它的环绕方式。</p><p> 环绕方式和过滤方式需要对不同的纹理分别设置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> texture1, texture2;<br><span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;texture1);<br><span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);<br><span class="hljs-comment">// 设置环绕，过滤方式</span><br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><br><span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data1);<br><span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br><span class="hljs-comment">// 释放图像内存</span><br><span class="hljs-built_in">stbi_image_free</span>(data1);<br><br><span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;texture2);<br><span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE2);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);<br><span class="hljs-comment">// 设置环绕，过滤方式</span><br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><br><span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGBA, width, height, <span class="hljs-number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data2);<br><span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-11-01-19-04-15.png"></p></li><li><p>尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">float</span> offset = <span class="hljs-number">0.03</span>;<br><br><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span><br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">0.5f</span> + offset, <span class="hljs-number">0.5f</span> + offset,   <span class="hljs-comment">// 右上</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">0.5f</span> + offset, <span class="hljs-number">0.5f</span> - offset,   <span class="hljs-comment">// 右下</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-number">0.5f</span> - offset, <span class="hljs-number">0.5f</span> - offset,   <span class="hljs-comment">// 左下</span><br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-number">0.5f</span> - offset, <span class="hljs-number">0.5f</span> + offset    <span class="hljs-comment">// 左上</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>将纹理放大后的效果：<br><img src="/article_img/2022-11-01-19-10-25.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br></code></pre></td></tr></table></figure><p>可以明显看出使用GL_LINEAR过滤方法锯齿感更弱<br><img src="/article_img/2022-11-01-19-12-45.png"></p></li><li><p>使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度<br><img src="/article_img/2022-11-01-19-40-30.png"><br><img src="/article_img/2022-11-01-19-40-57.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 输入函数，让所有输入代码保持整洁</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processInput</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">float</span> &amp;mix_ratio)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;<br>         std::cout &lt;&lt; <span class="hljs-string">&quot;ESCAPE PRESSED!&quot;</span> &lt;&lt; std::endl;<br>         <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>     &#125;<br>         <br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_UP) == GLFW_PRESS) &#123;<br>         mix_ratio += <span class="hljs-number">0.1f</span>;<br>         <span class="hljs-keyword">if</span> (mix_ratio &gt; <span class="hljs-number">1.0f</span>)<br>             mix_ratio = <span class="hljs-number">1.0f</span>;<br>         std::cout &lt;&lt; <span class="hljs-string">&quot;UP PRESSED!&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_DOWN) == GLFW_PRESS) &#123;<br>         mix_ratio -= <span class="hljs-number">0.1f</span>;<br>         <span class="hljs-keyword">if</span> (mix_ratio &lt; <span class="hljs-number">0.0f</span>)<br>             mix_ratio = <span class="hljs-number">0.0f</span>;<br>         std::cout &lt;&lt; <span class="hljs-string">&quot;DOWN PRESSED!&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// 渲染循环</span><br> ourShader.<span class="hljs-built_in">setFloat</span>(<span class="hljs-string">&quot;mix_ratio&quot;</span>, mix_ratio);<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>-[OpenGL笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-11-相机与透镜</title>
    <link href="/2022/10/29/Games101-11-%E7%9B%B8%E6%9C%BA%E4%B8%8E%E9%80%8F%E9%95%9C/"/>
    <url>/2022/10/29/Games101-11-%E7%9B%B8%E6%9C%BA%E4%B8%8E%E9%80%8F%E9%95%9C/</url>
    
    <content type="html"><![CDATA[<p>Games101-11-相机与透镜</p><span id="more"></span><p><img src="/article_img/2022-10-29-12-58-05.png"></p><h1 id="针孔-透镜在传感器上生成图像"><a href="#针孔-透镜在传感器上生成图像" class="headerlink" title="针孔&#x2F;透镜在传感器上生成图像"></a>针孔&#x2F;透镜在传感器上生成图像</h1><p><img src="/article_img/2022-10-29-13-41-49.png"></p><p>传感器积累的是曝光时间中的Irradiance</p><h1 id="视场（Field-of-View）"><a href="#视场（Field-of-View）" class="headerlink" title="视场（Field of View）"></a>视场（Field of View）</h1><p><img src="/article_img/2022-10-29-13-44-18.png"></p><p>可以通过改变焦距来改变视场。</p><p><img src="/article_img/2022-10-29-13-44-32.png"></p><h1 id="曝光（Exposure）"><a href="#曝光（Exposure）" class="headerlink" title="曝光（Exposure）"></a>曝光（Exposure）</h1><p><img src="/article_img/2022-10-29-13-46-16.png"></p><p>曝光量 &#x3D; 曝光时间 * Irradiance</p><p>其中曝光时间由快门控制，Irradiance（Power per unit area）由透镜的光圈大小和焦距（焦距决定视场，视场越大自然irradiance越大）决定。</p><p>光圈大小：由f-stop描述，f-stop值越大光圈越小，照片越暗，也越锐利；</p><p>f-stop(f-number)的定义：焦距&#x2F;光圈直径</p><p><img src="/article_img/2022-10-29-14-50-09.png"></p><p><img src="/article_img/2022-10-29-13-50-48.png"></p><p>快门时间：快门时间越长，照片越模糊（动态模糊-motion blur）</p><p><img src="/article_img/2022-10-29-13-50-58.png"></p><p>高速摄影和延时摄影：高速摄影利用极短的快门时间，同时要求大光圈以及高ISO（确保照片足够亮）；延时摄影则利用很长的快门时间，同时要求小光圈（确保不会过亮）。</p><p><img src="/article_img/2022-10-29-13-55-20.png"></p><p><img src="/article_img/2022-10-29-13-55-07.png"></p><h1 id="薄透镜方程"><a href="#薄透镜方程" class="headerlink" title="薄透镜方程"></a>薄透镜方程</h1><p>真实的相机的镜头都是一个透镜组，经过透镜组的复杂操作实现改变镜头焦距，所以在图形学中，我们定义的虚拟相机中的透镜焦距可以任意改变。</p><p><img src="/article_img/2022-10-29-13-58-15.png"></p><p>这里就不推这个公式了。</p><h1 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h1><h2 id="Defocus-Blur"><a href="#Defocus-Blur" class="headerlink" title="Defocus Blur"></a>Defocus Blur</h2><p><img src="/article_img/2022-10-29-14-44-06.png"></p><p>物体本来应该成像在Image点，但是由于感光平面不在Image点，而光线在相交于Image点后会仍然沿直线继续传播，就会形成一个模糊的区域 C（Circle of Confusion）；由相似三角形可以看出 C 与 A 有关，即COC（Circle of Confusion）与光圈大小有关。</p><p><img src="/article_img/2022-10-29-14-51-40.png"></p><p>光圈（A &#x3D; f&#x2F;N 即 f-stop越小，A越大）越大，CoC越大，照片越模糊。</p><h2 id="景深-1"><a href="#景深-1" class="headerlink" title="景深"></a>景深</h2><p><img src="/article_img/2022-10-29-15-01-54.png"></p><p><img src="/article_img/2022-10-29-15-02-48.png"></p><p>认为一段区域内的CoC是足够小的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=19&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_19.pdf">GAMES101_Lecture_19.pdf</a>  </p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learnopengl-2-着色器</title>
    <link href="/2022/10/28/learnopengl-2-%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    <url>/2022/10/28/learnopengl-2-%E7%9D%80%E8%89%B2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>learnopengl-2-着色器</p><span id="more"></span><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/">着色器-LearnOpenGL CN</a></p><h1 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h1><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p><p>Shader的典型结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#version version_number</span><br>in type in_variable_name;<br>in type in_variable_name;<br><br>out type out_variable_name;<br><br>uniform type uniform_name;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 处理输入并进行一些图形操作</span><br>  ...<br>  <span class="hljs-comment">// 输出处理过的结果到输出变量</span><br>  out_variable_name = weird_stuff_we_processed;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>GLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。</p><p>还有两种容器类型，分别是向量（Vector）和矩阵（Matrix）</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><table><thead><tr><th align="center">类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">vecn</td><td align="center">包含n个float分量的默认向量</td></tr><tr><td align="center">bvecn</td><td align="center">包含n个bool分量的向量</td></tr><tr><td align="center">ivecn</td><td align="center">包含n个int分量的默认向量</td></tr><tr><td align="center">uvecn</td><td align="center">包含n个unsigned int分量的向量</td></tr><tr><td align="center">dvecn</td><td align="center">包含n个double分量的默认向量</td></tr></tbody></table><p>向量的使用十分灵活，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">vec2 someVec;<br>vec4 differentVec = someVec.xyxx;<br>vec3 anotherVec = differentVec.zyw;<br>vec4 otherVec = someVec.xxxx + anotherVec.yxzy;<br><br>vec2 vect = <span class="hljs-built_in">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>);<br>vec4 result = <span class="hljs-built_in">vec4</span>(vect, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br>vec4 otherResult = <span class="hljs-built_in">vec4</span>(result.xyz, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><p>GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但有两个特例：顶点着色器和片段着色器。</p><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>顶点着色器需要一种特殊的输入，从顶点数据中直接接收输入。使用<strong>location</strong>这一元数据指定输入变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">0</span>) in vec3 aPos; <span class="hljs-comment">// 位置变量的属性位置值为0</span><br><br>out vec4 vertexColor; <span class="hljs-comment">// 为片段着色器指定一个颜色输出</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    gl_Position = <span class="hljs-built_in">vec4</span>(aPos, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span><br>    vertexColor = <span class="hljs-built_in">vec4</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 把输出变量设置为暗红色</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>片段着色器需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec4 vertexColor; <span class="hljs-comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FragColor = vertexColor;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h1><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式, 具体使用时就是在shader（GPU）中定义uniform变量，该变量可以在main函数（CPU）中被赋值和改变。</p><p>uniform是全局的(Global)，必须在每个着色器中都是独一无二的。</p><p>在程序中改变uniform的值需要先找到着色器中uniform属性的位置，用<strong>glGetUniformLocation</strong>函数查询，使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> vertexColorLocation = <span class="hljs-built_in">glGetUniformLocation</span>(shader_name, <span class="hljs-string">&quot;uniform_name&quot;</span>);<br></code></pre></td></tr></table></figure><p>之后使用<strong>glUniform</strong>函数改变uniform的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">glUniform4f</span>(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-10-28-17-09-17.png"></p><h1 id="自己的着色器类"><a href="#自己的着色器类" class="headerlink" title="自己的着色器类"></a>自己的着色器类</h1><p>定义一个着色器类实现从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测。</p><h2 id="从文件读取shader"><a href="#从文件读取shader" class="headerlink" title="从文件读取shader"></a>从文件读取shader</h2><p>之前我们都使用硬编码shader代码的方式使用shader，在这里尝试从外部文件中读取shader代码。</p><p><img src="/article_img/2022-10-29-12-19-29.png"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li>修改顶点着色器让三角形上下颠倒： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">0</span>) in vec3 aPos;<br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">1</span>) in vec3 aColor;<br><br>out vec3 ourColor;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    gl_Position = <span class="hljs-built_in">vec4</span>(aPos.x, -aPos.y, aPos.z, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 将y坐标取反即可</span><br>    ourColor = ourColor;<br>&#125;<br></code></pre></td></tr></table></figure> <img src="/article_img/2022-10-28-19-52-39.png"></li><li>使用uniform定义一个水平偏移量，在顶点着色器中使用这个偏移量把三角形移动到屏幕右侧： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">0</span>) in vec3 aPos;<br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">1</span>) in vec3 aColor;<br><br>out vec3 ourColor;<br>uniform <span class="hljs-type">float</span> hori_offset; <span class="hljs-comment">// 在程序中修改即可</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    gl_Position = <span class="hljs-built_in">vec4</span>(aPos.x-hori_offset, aPos.y, aPos.z, <span class="hljs-number">1.0</span>);<br>    ourColor = ourColor;<br>&#125;<br></code></pre></td></tr></table></figure> <img src="/article_img/2022-10-28-19-53-14.png"></li><li>使用out关键字把顶点位置输出到片段着色器，并将片段的颜色设置为与顶点位置相等（来看看连顶点位置值都在三角形中被插值的结果）。做完这些后，尝试回答下面的问题：为什么在三角形的左下角是黑的?： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">0</span>) in vec3 aPos;<br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">1</span>) in vec3 aColor;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    gl_Position = <span class="hljs-built_in">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="hljs-number">1.0</span>);<br>    ourColor = aPos;<br>&#125;<br></code></pre></td></tr></table></figure> <img src="/article_img/2022-10-28-19-11-33.png"><br> 左下角是黑色是因为左下角的坐标是（-0.5f, -0.5f, 0.0f）是负值，而负值在颜色计算时会转换成0，并且插值后的结果也仍然是负值，故直到三角形中心才开始有颜色的渐变。</li></ol>]]></content>
    
    
    <categories>
      
      <category>-[OpenGL笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learnopengl-1-你好三角形</title>
    <link href="/2022/10/27/learnopengl-1-%E4%BD%A0%E5%A5%BD%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <url>/2022/10/27/learnopengl-1-%E4%BD%A0%E5%A5%BD%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p>learnopengl-1-你好三角形</p><span id="more"></span><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_7">你好，三角形-LearnOpenGL CN</a></p><p><a href="https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20">傅老師&#x2F;OpenGL教學 第一章</a></p><p>环境的搭建和窗口的生成有时间之后补上。</p><p>本篇笔记先按照网站的顺序梳理一边基本概念，之后结合傅老师的讲解，<strong>串联</strong>所有概念和步骤。</p><h1 id="OpenGL的图形渲染管线（Graphics-Pipline）"><a href="#OpenGL的图形渲染管线（Graphics-Pipline）" class="headerlink" title="OpenGL的图形渲染管线（Graphics Pipline）"></a>OpenGL的图形渲染管线（Graphics Pipline）</h1><p><img src="/article_img/2022-10-24-14-28-44.png"></p><p>图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p><ol><li>顶点着色器（Vertex Shader）：顶点着色器主要的目的是把3D坐标转为另一种3D坐标；</li><li>图元装配（Primitive Assembly）：将顶点着色器输出的所有顶点装配成指定图元的形状；</li><li>几何着色器（Geometry Shader）：几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状；</li><li>光栅化（Rasterization Stage）：把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)；</li><li>片段着色器（Fragment Shader）：计算一个像素的最终颜色；</li><li>测试和混合（Test and Blending）：检测深度决定哪些片段被舍弃，以及检查alpha值对物体进行混合；</li></ol><h1 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h1><p><img src="/article_img/2022-10-24-14-47-45.png"></p><p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。</p><h2 id="VBO（顶点缓冲对象）"><a href="#VBO（顶点缓冲对象）" class="headerlink" title="VBO（顶点缓冲对象）"></a>VBO（顶点缓冲对象）</h2><p>VBO用来储存输入的一大堆顶点数据，可以一次性将一大批数据发送到显卡上。</p><p>以下代码就是VBO的基本定义和使用方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO); <span class="hljs-comment">// 生成</span><br><span class="hljs-built_in">glBindBudder</span>(GL_ARRAY_BUFFER, VBO);  <span class="hljs-comment">// 绑定到状态机</span><br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);  <span class="hljs-comment">// 加数据</span><br></code></pre></td></tr></table></figure><h2 id="EBO（元素缓冲对象）"><a href="#EBO（元素缓冲对象）" class="headerlink" title="EBO（元素缓冲对象）"></a>EBO（元素缓冲对象）</h2><p>这个本来是在教程最后讲解的，但是EBO也是对输入的顶点数据进行处理的对象。</p><p>EBO简单来说就是用来解决顶点重复定义的问题。</p><p>假如现在要通过绘制两个三角形的方法绘制一个矩形，如果没有EBO，需要定义如下顶点集合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-comment">// 第一个三角形</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右上角</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 左上角</span><br>    <span class="hljs-comment">// 第二个三角形</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// 左上角</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到有一些相同的顶点被重复定义了，而EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右上角</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// 左上角</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123;<br>    <span class="hljs-comment">// 注意索引从0开始! </span><br>    <span class="hljs-comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span><br>    <span class="hljs-comment">// 这样可以由下标代表顶点组合成矩形</span><br><br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-comment">// 第一个三角形</span><br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>  <span class="hljs-comment">// 第二个三角形</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>之后EBO的使用也和VBO类似，之后在渲染循环中，将glDrawArrays()替换成glDrawElements()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO); <span class="hljs-comment">// 生成</span><br><span class="hljs-built_in">glBindBudder</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);  <span class="hljs-comment">// 绑定到状态机</span><br><span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);  <span class="hljs-comment">// 加数据</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 渲染循环中</span><br><span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h1 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h1><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>shader语法和编写在下一节具体展开，这里只简单介绍shader如何配置。</p><p>和之前的VBO和EBO类似，也需要先定义一个shader编号，之后生成shader，告诉生成的shader源码是哪些，最后编译shader</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertexShader;<br>vertexShader = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br><br><span class="hljs-built_in">glShaderSource</span>(vertexShader, <span class="hljs-number">1</span>, &amp;vertexShaderSource, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">glCompileShader</span>(vertexShader);<br></code></pre></td></tr></table></figure><h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>和顶点着色器完全一样的用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragmentShader;<br>fragmentShader = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br><br><span class="hljs-built_in">glShaderSource</span>(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">glCompileShader</span>(fragmentShader);<br></code></pre></td></tr></table></figure><h2 id="着色器程序对象"><a href="#着色器程序对象" class="headerlink" title="着色器程序对象"></a>着色器程序对象</h2><p>之前编译好的两个着色器并不能直接使用，需要将其合并（代码上体现出来就是将之前两个shader附加到着色器程序上），之后链接成一个着色器程序对象，在渲染时激活这个着色器程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shaderProgram;<br>shaderProgram = <span class="hljs-built_in">glCreateProgram</span>(); <span class="hljs-comment">// 经典创建对象</span><br><br><span class="hljs-comment">// 附加（合并）shader到shaderProgram上</span><br><span class="hljs-built_in">glAttachShader</span>(shaderProgram, vertexShader);<br><span class="hljs-built_in">glAttachShader</span>(shaderProgram, fragmentShader);<br><span class="hljs-built_in">glLinkProgram</span>(shaderProgram); <span class="hljs-comment">// 链接shader</span><br><br><span class="hljs-comment">// 渲染循环中</span><br><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br></code></pre></td></tr></table></figure><p>在把着色器对象链接到程序对象之后，就可以删除着色器对象了</p><h1 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h1><p>这部分在第一次读的时候较难理解，之后结合<a href="https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20">傅老師&#x2F;OpenGL教學 第一章</a>才理解。</p><p>我们之前定义了VBO来将一堆顶点数据输入GPU，但是GPU其实并不知道这些顶点数据的含义，glVertexAttribPointer函数就是为了告知GPU如何正确理解这些“杂乱”的顶点信息的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h1 id="顶点数组对象-VAO"><a href="#顶点数组对象-VAO" class="headerlink" title="顶点数组对象(VAO)"></a>顶点数组对象(VAO)</h1><p>VAO使得当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。</p><p><img src="/article_img/2022-10-27-14-16-43.png"></p><p><img src="/article_img/2022-10-27-14-21-46.png"></p><p>由以上图可以看出VAO包含很多attribute pointer和一个EBO，且可以看出真正储存顶点信息的是一个个的VBO，VAO中存储着如何去解释VBO中数据的顶点属性指针和EBO。</p><h2 id="深入理解VAO和VBO"><a href="#深入理解VAO和VBO" class="headerlink" title="深入理解VAO和VBO"></a>深入理解VAO和VBO</h2><p><a href="https://www.zhihu.com/question/30095978/answer/2362612406">如何正确理解OpenGL的VAO?</a></p><p>可以使用一个VAO绑定多个VBO但是要<strong>注意</strong>：<br>多个VBO中的顶点信息不能重复，如VBO1中存储所有的顶点位置信息，VBO2中存储所有的颜色信息，不能VBO1和VBO2都存储位置信息。</p><p>如果混合存储，如下图，绑定VBO2的时候会覆盖掉之前绑定的VBO1；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> triangle[] = &#123; <span class="hljs-comment">// VBO1的data</span><br>   <span class="hljs-comment">// 位置              // 颜色</span><br>   <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右下</span><br>   <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 左下</span><br>   <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// 顶部</span><br>&#125;;<br><span class="hljs-type">float</span> triangle2[] = &#123; <span class="hljs-comment">// VBO2的data</span><br>   <span class="hljs-comment">// 位置              // 颜色</span><br>   <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <br>   <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <br>   <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>   <br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-10-28-19-32-16.png"></p><p>将顶点信息和颜色信息分别存入到VBO1和VBO2中，再将VBO1和VBO2绑定在VAO上就可以正常显示两个三角形；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> triangles[] = &#123;  <span class="hljs-comment">// VBO1的data</span><br>   <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span><br>&#125;;<br><span class="hljs-type">float</span> colors[] = &#123;   <span class="hljs-comment">// VBO2的data</span><br>   <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>   <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>   <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-10-28-19-37-42.png"></p><p>要先绑定VAO，再绑定EBO，否则会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br><span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br><span class="hljs-built_in">glBindVertexArray</span>(VAO);<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/article_img/2022-10-27-15-12-46.png"></p><p>首先要理解OpenGL采用状态机架构，所以绑定就意味着使用。</p><p><img src="/article_img/2022-10-27-14-53-13.png"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><p>添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形<br><img src="/article_img/2022-10-27-15-32-33.png"></p><p>关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> triangle[] = &#123;<br>   <span class="hljs-number">-1.0f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.0f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.0f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">1.0f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>   <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span><br>&#125;;<br><br><span class="hljs-comment">// 渲染循环</span><br><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure></li><li><p>创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO<br><img src="/article_img/2022-10-27-15-54-08.png"></p><p>关键代码：<br>这里要注意要分别为两个VAO设置顶点属性，两个VAO该怎样处理VBO中的数据都要分别告知。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO[<span class="hljs-number">2</span>], VBO[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">2</span>, VBO);<br><span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">2</span>, VAO);<br><br><span class="hljs-built_in">glBindVertexArray</span>(VAO[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(triangle1), triangle1, GL_STATIC_DRAW);<br><span class="hljs-comment">// 为VAO[0]设置顶点属性</span><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><br><br><span class="hljs-built_in">glBindVertexArray</span>(VAO[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(triangle2), triangle2, GL_STATIC_DRAW);<br><span class="hljs-comment">// 为VAO[1]设置顶点属性</span><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 渲染循环</span><br><span class="hljs-built_in">glBindVertexArray</span>(VAO[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">glBindVertexArray</span>(VAO[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li><li><p>创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色<br><img src="/article_img/2022-10-27-16-10-17.png"><br>关键代码：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 渲染循环</span><br><span class="hljs-built_in">glUseProgram</span>(shaderProgram1);<br><span class="hljs-built_in">glBindVertexArray</span>(VAO[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">glUseProgram</span>(shaderProgram2);<br><span class="hljs-built_in">glBindVertexArray</span>(VAO[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>-[OpenGL笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-10-渲染中的高级话题</title>
    <link href="/2022/10/22/Games101-10-%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"/>
    <url>/2022/10/22/Games101-10-%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Games101-10-渲染中的高级话题</p><span id="more"></span><h1 id="高级光线传播"><a href="#高级光线传播" class="headerlink" title="高级光线传播"></a>高级光线传播</h1><ol><li>无偏的光线传播方法<br>双向路径追踪（BDPT）<br>Metropolis光线传播（MLT）</li><li>有偏的光线传播方法<br>Photon mapping（光子映射）<br>Vertex connection and merging（VCM）</li><li>Instant radiosity（VPL &#x2F; many light methods）</li></ol><p>无偏和有偏的区别：<br>无偏方法没有任何系统错误；无论采样数是多少，无偏方法的期望永远是正确的值。<br>有偏方法只有在采样数趋于无穷时，期望才收敛于真实值。</p><h2 id="Bidirectional-Path-Tracing-BDPT"><a href="#Bidirectional-Path-Tracing-BDPT" class="headerlink" title="Bidirectional Path Tracing(BDPT)"></a>Bidirectional Path Tracing(BDPT)</h2><p><img src="/article_img/2022-10-22-14-07-59.png"></p><p><img src="/article_img/2022-10-22-14-08-44.png"></p><p>适用于光线传输很复杂的场景，如上图所示，直接光照只在左上角，而整个场景基本都是由间接光照照亮的。和之前在<a href="Games101-8-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA.md">路径追踪</a>中要采取<strong>重要性采样</strong>的原因类似：从相机发出的路径难以到达光源，导致大量的路径浪费，产生严重的噪声。</p><h2 id="Metropolis-Light-Transport-MLT"><a href="#Metropolis-Light-Transport-MLT" class="headerlink" title="Metropolis Light Transport(MLT)"></a>Metropolis Light Transport(MLT)</h2><p>Metropolis是个人名<br>MLT是马尔可夫链蒙特卡罗（Markov Chain Monte Carlo &#x2F; MCMC）的应用：根据当前采样找到下一次采样</p><p><img src="/article_img/2022-10-22-14-17-30.png"></p><p>非常适用于在局部探索复杂的光路，一旦找到一条光路，就会生成一堆光路，从而相当于没有浪费采样。</p><p><img src="/article_img/2022-10-22-14-19-42.png"></p><p><img src="/article_img/2022-10-22-14-20-18.png"></p><p>缺点：<br>难以估计收敛速率，可能计算了一天还没有明显进步。每个像素的收敛速率不同从而导致生成的图片有些“脏”，从而也不能渲染动画，因为每一帧的噪声都不同。</p><h2 id="Photon-Mapping（光子映射）"><a href="#Photon-Mapping（光子映射）" class="headerlink" title="Photon Mapping（光子映射）"></a>Photon Mapping（光子映射）</h2><p>一种有偏的两步方法，非常适合计算Specular-Diffuse-Specular (SDS) 路径以及生成焦散（caustics）现象。</p><p><img src="/article_img/2022-10-22-14-25-50.png"></p><p><img src="/article_img/2022-10-22-14-27-03.png"></p><p><img src="/article_img/2022-10-22-14-27-38.png"></p><p><strong>光子映射步骤</strong>：  </p><ol><li>从光源发射光子，光子在场景中不断弹射直到碰到漫反射物体，之后将哪里有光子记录下来；</li><li>从相机发射sub-paths，同样在场景中弹射直到碰到漫反射物体，统计sub-paths到达的每个着色点周围的 N 个光子，计算这 N 个光子覆盖的区域面积。</li></ol><p>显然，单位面积内光子越多，这个着色点就应该越亮。</p><p><img src="/article_img/2022-10-22-14-35-10.png"></p><p>只有面积无限小的时候，才能收敛于真实值，因此光子映射是有偏但一致的方法。</p><p><img src="/article_img/2022-10-22-14-36-55.png"></p><p>为什么不确定一个面积统计光子数量，而要确定N个光子，计算覆盖面积？</p><p>因为如果确定面积统计光子，这个面积不会随着光源发出光子的数量增加而减小，也就不会有一个趋向于无穷小的过程。</p><h2 id="Vertex-Connection-and-Merging"><a href="#Vertex-Connection-and-Merging" class="headerlink" title="Vertex Connection and Merging"></a>Vertex Connection and Merging</h2><p>一种BDPT和光子映射的组合。</p><p><img src="/article_img/2022-10-22-14-40-09.png"></p><h2 id="Instant-Radiosity（IR）"><a href="#Instant-Radiosity（IR）" class="headerlink" title="Instant Radiosity（IR）"></a>Instant Radiosity（IR）</h2><p>有时也叫做多光源方法（Many-light approaches）</p><p><img src="/article_img/2022-10-22-14-41-23.png"></p><p><img src="/article_img/2022-10-22-14-42-29.png"></p><h1 id="高级外观建模"><a href="#高级外观建模" class="headerlink" title="高级外观建模"></a>高级外观建模</h1><ol><li>非表面模型<br>Participating media（雾，云）<br>头发&#x2F;皮毛&#x2F;纤维（BCSFDF）<br>Granular material（颗粒材质）</li><li>表面模型<br>Translucent material（BSSRDF）半透明材质<br>布<br>Detailed material</li><li>程序化外观</li></ol><h2 id="Participating-Media（雾）"><a href="#Participating-Media（雾）" class="headerlink" title="Participating Media（雾）"></a>Participating Media（雾）</h2><p><img src="/article_img/2022-10-22-14-51-07.png"></p><p><img src="/article_img/2022-10-22-14-50-09.png"></p><p><img src="/article_img/2022-10-22-14-50-17.png"></p><p><img src="/article_img/2022-10-22-14-50-26.png"></p><h2 id="头发-皮毛-纤维"><a href="#头发-皮毛-纤维" class="headerlink" title="头发&#x2F;皮毛&#x2F;纤维"></a>头发&#x2F;皮毛&#x2F;纤维</h2><p>Kajiya-Kay Model</p><p><img src="/article_img/2022-10-22-14-55-15.png"></p><p>Marschner Model</p><p>将头发看作一根玻璃柱，有三种类型的光线：直接反射光（R），两次折射（TT），折射反射再折射（TRT）</p><p><img src="/article_img/2022-10-22-14-55-32.png"></p><p><img src="/article_img/2022-10-22-14-55-42.png"></p><p><img src="/article_img/2022-10-22-14-57-34.png"></p><p>Marschner模型已经能取得很不错的效果。</p><p>但是将人类头发的模型（Marschner模型）应用于动物皮毛不能得到很好的效果</p><p><img src="/article_img/2022-10-22-14-59-42.png"></p><p>因为动物的毛发中有很粗的Medulla对光线进行散射</p><p><img src="/article_img/2022-10-22-14-58-49.png"></p><p>为了模拟真实的毛发结构，提出了双层玻璃柱模型（就是闫大神提出的），增加了medulla造成的散射。</p><p><img src="/article_img/2022-10-22-15-01-06.png"></p><p><img src="/article_img/2022-10-22-15-03-00.png"></p><p><img src="/article_img/2022-10-22-15-03-45.png"></p><h2 id="Granular-Material（颗粒材质）"><a href="#Granular-Material（颗粒材质）" class="headerlink" title="Granular Material（颗粒材质）"></a>Granular Material（颗粒材质）</h2><p><img src="/article_img/2022-10-22-15-05-34.png"></p><p><img src="/article_img/2022-10-22-15-06-05.png"></p><h2 id="半透明材质"><a href="#半透明材质" class="headerlink" title="半透明材质"></a>半透明材质</h2><p><img src="/article_img/2022-10-22-15-06-25.png"></p><p>次表面散射：<br>光线射入半透明物体后有可能会从任意方向射出。</p><p><img src="/article_img/2022-10-22-15-17-26.png"></p><p><img src="/article_img/2022-10-22-15-20-05.png"></p><p><img src="/article_img/2022-10-22-15-22-02.png"></p><p><img src="/article_img/2022-10-22-15-22-42.png"></p><p>BSSRDF还适用于模拟人类皮肤</p><p><img src="/article_img/2022-10-22-15-23-45.png"></p><h2 id="布料"><a href="#布料" class="headerlink" title="布料"></a>布料</h2><p><img src="/article_img/2022-10-22-15-26-34.png"></p><h2 id="表面细节"><a href="#表面细节" class="headerlink" title="表面细节"></a>表面细节</h2><p>真实的物体表面不会像渲染结果一样完美</p><p><img src="/article_img/2022-10-22-15-27-38.png"></p><p><img src="/article_img/2022-10-22-15-29-17.png"></p><p><img src="/article_img/2022-10-22-15-29-34.png"></p><p><img src="/article_img/2022-10-22-15-30-36.png"></p><h2 id="程序化外观"><a href="#程序化外观" class="headerlink" title="程序化外观"></a>程序化外观</h2><p>利用噪声函数，模拟物体材质效果，每次要渲染的时候再计算应该如何显示。</p><p><img src="/article_img/2022-10-22-15-32-53.png"></p><p>还可以定义3D噪声函数，来模拟物体内部的材质。</p><p><img src="/article_img/2022-10-22-15-32-59.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=18&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_18.pdf">GAMES101_Lecture_18.pdf</a>  </p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-9-外观和材质</title>
    <link href="/2022/10/18/Games101-9-%E5%A4%96%E8%A7%82%E5%92%8C%E6%9D%90%E8%B4%A8/"/>
    <url>/2022/10/18/Games101-9-%E5%A4%96%E8%A7%82%E5%92%8C%E6%9D%90%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<p>Games101-9-外观和材质</p><span id="more"></span><p><img src="/article_img/2022-10-19-14-13-14.png"></p><h1 id="什么是材质"><a href="#什么是材质" class="headerlink" title="什么是材质"></a>什么是材质</h1><p><strong>材质&#x3D;&#x3D;BRDF</strong></p><h2 id="漫反射材质"><a href="#漫反射材质" class="headerlink" title="漫反射材质"></a>漫反射材质</h2><p><img src="/article_img/2022-10-19-14-26-47.png"></p><p><img src="/article_img/2022-10-19-14-21-28.png"></p><p>漫反射认为是能量均匀的向四面发射，根据能量守恒：<strong>Lo &#x3D;&#x3D; Li</strong>，因此漫反射的BRDF为 1&#x2F;pi，考虑到能量吸收，则乘以ρ（albedo颜色衰减率），就会反射出不同的颜色。</p><h2 id="Glossy材质"><a href="#Glossy材质" class="headerlink" title="Glossy材质"></a>Glossy材质</h2><p><img src="/article_img/2022-10-19-14-27-00.png"></p><h2 id="理想反射-折射材质"><a href="#理想反射-折射材质" class="headerlink" title="理想反射&#x2F;折射材质"></a>理想反射&#x2F;折射材质</h2><p><img src="/article_img/2022-10-19-14-27-57.png"></p><p><strong>完美镜面反射</strong></p><p><img src="/article_img/2022-10-19-14-31-26.png"></p><h1 id="Snell’s-Law"><a href="#Snell’s-Law" class="headerlink" title="Snell’s Law"></a>Snell’s Law</h1><p><img src="/article_img/2022-10-19-14-33-18.png"></p><p><img src="/article_img/2022-10-19-14-33-45.png"></p><h1 id="Fresnel-Reflection-Term-菲涅尔项"><a href="#Fresnel-Reflection-Term-菲涅尔项" class="headerlink" title="Fresnel Reflection&#x2F;Term 菲涅尔项"></a>Fresnel Reflection&#x2F;Term 菲涅尔项</h1><p><img src="/article_img/2022-10-19-14-36-13.png"></p><p>绝缘体的菲涅尔项（玻璃）</p><p><img src="/article_img/2022-10-19-14-36-58.png"></p><p>导体的菲涅尔项（金属）</p><p><img src="/article_img/2022-10-19-14-37-36.png"></p><p>由此可以看出金属会大量反射光线，这也就是为什么古代人用铜镜而不用玻璃照镜子。</p><p><img src="/article_img/2022-10-19-14-38-56.png"></p><p>菲涅尔项的计算十分复杂，所以使用Schlick近似。</p><h1 id="微表面材质"><a href="#微表面材质" class="headerlink" title="微表面材质"></a>微表面材质</h1><p><img src="/article_img/2022-10-19-14-48-13.png"></p><p><img src="/article_img/2022-10-19-14-49-56.png"></p><p><img src="/article_img/2022-10-19-14-50-38.png"></p><p><img src="/article_img/2022-10-19-14-51-16.png"></p><p>D(h)表示法线分布<br>F(i,h)表示菲涅尔项<br>G(i,o,h)表示自遮挡</p><h1 id="各向同性-各向异性材质"><a href="#各向同性-各向异性材质" class="headerlink" title="各向同性&#x2F;各向异性材质"></a>各向同性&#x2F;各向异性材质</h1><p><img src="/article_img/2022-10-20-11-13-23.png"></p><p>区分方法：表面是否有方向性</p><p><img src="/article_img/2022-10-20-11-13-35.png"></p><h2 id="各向异性材质"><a href="#各向异性材质" class="headerlink" title="各向异性材质"></a>各向异性材质</h2><p><img src="/article_img/2022-10-20-11-16-05.png"></p><p>反射取决于观测的方位角</p><h1 id="BRDF的性质"><a href="#BRDF的性质" class="headerlink" title="BRDF的性质"></a>BRDF的性质</h1><ol><li>非负性<br><img src="/article_img/2022-10-20-11-18-34.png"></li><li>线性<br>可以线性相加，结果不变<br><img src="/article_img/2022-10-20-11-18-53.png"></li><li>满足反射定律<br><img src="/article_img/2022-10-20-11-19-22.png"></li><li>能量守恒<br>该式子表示能量不会增加，只会被反射点吸收或者完全反射<br><img src="/article_img/2022-10-20-11-20-06.png"></li><li>如果是各向同性材质，BRDF参数可以简化为3个<br><img src="/article_img/2022-10-20-11-23-56.png"></li></ol><h1 id="BRDF的测量"><a href="#BRDF的测量" class="headerlink" title="BRDF的测量"></a>BRDF的测量</h1><p>真实材质的BRDF和理论上的有较大差异</p><p><img src="/article_img/2022-10-20-11-25-41.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=17&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_17.pdf">GAMES101_Lecture_17.pdf</a>  </p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-8-路径追踪</title>
    <link href="/2022/10/13/Games101-8-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"/>
    <url>/2022/10/13/Games101-8-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<p>Games101-8-路径追踪</p><span id="more"></span><p><img src="/article_img/2022-10-12-19-16-44.png"></p><h1 id="概率论知识"><a href="#概率论知识" class="headerlink" title="概率论知识"></a>概率论知识</h1><p><img src="/article_img/2022-10-12-19-17-41.png"></p><h1 id="Monte-Carlo-Integration"><a href="#Monte-Carlo-Integration" class="headerlink" title="Monte Carlo Integration"></a>Monte Carlo Integration</h1><p>一种数值方法计算定积分的值，不需要算出原函数。</p><p><img src="/article_img/2022-10-12-19-20-11.png"></p><p><img src="/article_img/2022-10-12-19-20-41.png"></p><p><img src="/article_img/2022-10-12-19-18-35.png"></p><h1 id="仅考虑直接光照"><a href="#仅考虑直接光照" class="headerlink" title="仅考虑直接光照"></a>仅考虑直接光照</h1><p><img src="/article_img/2022-10-13-14-37-13.png"></p><p>这里的wi是随机在半球上采样</p><h1 id="引入间接光照"><a href="#引入间接光照" class="headerlink" title="引入间接光照"></a>引入间接光照</h1><p><img src="/article_img/2022-10-13-14-40-09.png"></p><p>直接光照就按照光源来计算，间接光照递归计算</p><p>但是还没完：</p><ol><li><p>光线会爆炸<br><img src="/article_img/2022-10-13-14-41-58.png"></p><p>因此随机选择一条路径进行采样</p><p><img src="/article_img/2022-10-13-14-42-30.png"></p><p>在一个像素中增加采样点，最后平均，来降低噪声</p><p><img src="/article_img/2022-10-13-14-42-38.png"></p></li><li><p>没有递归出口</p><p><strong>俄罗斯轮盘赌</strong></p><p>这里就是利用了<strong>期望</strong>的概念：<br>事先假定一个概率p，有p的概率发生反射，并且计算的结果除以p，有（1-p）的概率不发生反射，得到0；这种方法得到的结果的期望仍然是Lo，即能量没有损失。</p><p><img src="/article_img/2022-10-13-14-45-56.png"></p><p><img src="/article_img/2022-10-13-14-50-16.png"></p></li></ol><h1 id="提高路径追踪效率"><a href="#提高路径追踪效率" class="headerlink" title="提高路径追踪效率"></a>提高路径追踪效率</h1><p><img src="/article_img/2022-10-13-14-51-20.png"></p><p>SPP（samples per pixel）</p><p><img src="/article_img/2022-10-13-15-58-06.png"></p><p>思考为什么low SPP效果不好会出现噪点？</p><p>因为我们的采样时在整个半球上随机采样的，而俄罗斯轮盘赌会终结一些光线，导致路径还没有打到光源就被终止，这条路径返回了空值，相当于这次路径追踪白做了（光线被浪费掉了），本质就是采样不足导致的。</p><p>因此我们要么加大采样量（增大路径到达光源的概率），要么尽量不要浪费光线，也就是进行重要性采样，对光源采样，就是先计算对该点颜色贡献最大的直接光照。</p><p>在对光源采样时，要把光源平面投影到半球面上，也可以理解为求<strong>有效光源</strong>(dA*costheta)的立体角。</p><p><img src="/article_img/2022-10-14-12-42-03.png"></p><p>之后就可以计算Lo</p><p><img src="/article_img/2022-10-14-12-45-56.png"></p><p>现在我们的策略是先计算直接光照（不使用俄罗斯轮盘赌），再计算间接光照（随机在半球中采样，使用俄罗斯轮盘赌）</p><p><img src="/article_img/2022-10-14-12-49-41.png"></p><p>再加上判断直接光照是否被遮挡</p><p>伪代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs applescript">shade(p,wo)<br>   <span class="hljs-comment"># 来自光源的贡献（直接光照）</span><br>   均匀对光源采样 x&#x27; (pdf_light = <span class="hljs-number">1</span>/A)<br>   Shoot a ray <span class="hljs-keyword">from</span> p <span class="hljs-keyword">to</span> x&#x27;<br>   <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> ray <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> blocked <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">middle</span><br>      L_dir = L_i * f_r * cos theta&#x27; / |x&#x27;-p|^<span class="hljs-number">2</span> / pdf_light<br><br>   <span class="hljs-comment"># 来自反射的贡献（间接光照）</span><br>   L_indir = <span class="hljs-number">0.0</span><br>   判断俄罗斯轮盘赌是否终止<br>   在半球上均匀采样 wi （pdf_hemi = <span class="hljs-number">1</span>/<span class="hljs-number">2</span><span class="hljs-literal">pi</span>）<br>   Trace a ray r(p, wi)<br>   <span class="hljs-keyword">if</span> ray r hit a non-emitting object <span class="hljs-keyword">at</span> q<br>      L_indir = shade(q, -wi) * f_r * cos theta / pdf_hemi / P_RR<br>   <br>   Return L_dir + L_indir<br><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=16&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf">GAMES101_Lecture_15.pdf</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_16.pdf">GAMES101_Lecture_16.pdf</a>  </p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-7-辐射度量学</title>
    <link href="/2022/10/12/Games101-7-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"/>
    <url>/2022/10/12/Games101-7-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>Games101-7-辐射度量学</p><span id="more"></span><h1 id="基础物理概念"><a href="#基础物理概念" class="headerlink" title="基础物理概念"></a>基础物理概念</h1><p><img src="/article_img/2022-10-12-12-03-15.png"></p><h2 id="Radiant-Energy-and-Flux-Power"><a href="#Radiant-Energy-and-Flux-Power" class="headerlink" title="Radiant Energy and Flux(Power)"></a>Radiant Energy and Flux(Power)</h2><p><img src="/article_img/2022-10-12-11-59-26.png"></p><p>Flux（Power） : energy per unit time（单位时间的能量）</p><p>可以理解为某一时刻的能量</p><p>Flux的单位Lumen（流明）</p><h2 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h2><p>某一个方向上的亮度（能量）</p><p><img src="/article_img/2022-10-12-12-04-58.png"></p><h3 id="立体角（Solid-Angles）"><a href="#立体角（Solid-Angles）" class="headerlink" title="立体角（Solid Angles）"></a>立体角（Solid Angles）</h3><p><img src="/article_img/2022-10-12-12-08-22.png"></p><p><img src="/article_img/2022-10-12-12-12-57.png"></p><h2 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h2><p><img src="/article_img/2022-10-12-12-28-37.png"></p><p>这个面积是要做投影，就是要计算垂直角度上的能量，类似于Lambert’s Cosine law：</p><p><img src="/article_img/2022-10-12-12-30-45.png"></p><p>正确理解Falloff</p><p><img src="/article_img/2022-10-12-12-34-50.png"></p><p>越远球壳面积越大，能量（Flux&#x2F;Power）总体不变，单位面积上的能量——Irradiance就越小。</p><h2 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h2><p><img src="/article_img/2022-10-12-12-38-07.png"></p><p>某一个面积向某一个方向辐射多少能量。</p><p><img src="/article_img/2022-10-12-12-40-29.png"></p><p>就是把Irradiance（单位面积上总共收到多少能量）分解到各个方向（从某一个方向收到了多少能量）。</p><p><img src="/article_img/2022-10-12-12-46-03.png"></p><h1 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h1><p>双向反射分布函数 (Bidirectional ReflectanceDistribution Function）</p><p><img src="/article_img/2022-10-12-12-51-23.png"></p><p>从某一方向发射来的radiance会转化为反射点的irradiance，之后这些能量（irradiance）再转化为从另一个方向射出的radiance.</p><p><img src="/article_img/2022-10-12-12-57-17.png"></p><p>BRDF就是定义<strong>向某个方向辐射的能量</strong>（radiance）与<strong>入射点能量</strong>（irradiance）的比例。</p><h1 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h1><p>任何一个方向入射的radiance到着色点，经过BRDF会得到向观测方向射出的radiance；将所有的入射radiance积分起来，就能得到最终看到着色点应该是什么样。</p><p><img src="/article_img/2022-10-12-13-03-11.png"></p><p>递归:</p><p><img src="/article_img/2022-10-12-13-10-52.png"></p><h1 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h1><p>渲染方程 &#x3D; 自发光 + 反射方程</p><p><img src="/article_img/2022-10-12-13-12-07.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=14&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf">GAMES101_Lecture_14.pdf</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf">GAMES101_Lecture_15.pdf</a>  </p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-6-光线追踪(Whitted-Style)</title>
    <link href="/2022/10/11/Games101-6-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA(Whitted-Style)/"/>
    <url>/2022/10/11/Games101-6-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA(Whitted-Style)/</url>
    
    <content type="html"><![CDATA[<p>Games101-6-光线追踪(Whitted-Style)</p><span id="more"></span><h1 id="为什么要用光线追踪"><a href="#为什么要用光线追踪" class="headerlink" title="为什么要用光线追踪"></a>为什么要用光线追踪</h1><p>光栅化无法生成效果好的环境光，如软阴影。</p><p>光栅化效果一般但是渲染速度很快，光线追踪效果很好但是渲染速度慢。</p><p><img src="/article_img/2022-10-11-17-42-00.png"></p><h1 id="Whitted-Style-的光线追踪"><a href="#Whitted-Style-的光线追踪" class="headerlink" title="Whitted-Style 的光线追踪"></a>Whitted-Style 的光线追踪</h1><p><img src="/article_img/2022-10-11-17-42-58.png"></p><h1 id="光线与表面求交"><a href="#光线与表面求交" class="headerlink" title="光线与表面求交"></a>光线与表面求交</h1><h2 id="光线方程"><a href="#光线方程" class="headerlink" title="光线方程"></a>光线方程</h2><p><img src="/article_img/2022-10-11-17-45-24.png"></p><h2 id="光线与球面求交"><a href="#光线与球面求交" class="headerlink" title="光线与球面求交"></a>光线与球面求交</h2><p><img src="/article_img/2022-10-11-17-46-35.png"></p><p>同理可以推广到光线与所有隐式表面的求交，因为隐式表面有定义其的方程，可以将光线方程带入转化为解方程。</p><h2 id="光线与三角形求交"><a href="#光线与三角形求交" class="headerlink" title="光线与三角形求交"></a>光线与三角形求交</h2><h3 id="方法一：先与平面求交"><a href="#方法一：先与平面求交" class="headerlink" title="方法一：先与平面求交"></a>方法一：先与平面求交</h3><p>三角形处于一个平面中，首先判断光线是否与该平面相交，再判断是否与三角形相交（交点是否在三角形内部：<strong>叉乘的应用</strong>）。</p><p><strong>平面方程</strong>： 由一个点和一个法相向量定义</p><p><img src="/article_img/2022-10-11-17-50-28.png"></p><p><img src="/article_img/2022-10-11-17-54-18.png"></p><h3 id="方法二：直接利用重心坐标求交"><a href="#方法二：直接利用重心坐标求交" class="headerlink" title="方法二：直接利用重心坐标求交"></a>方法二：直接利用重心坐标求交</h3><p><img src="/article_img/2022-10-11-17-57-15.png"></p><p>Recall：重心坐标由三个点定义，可以表示这三个点所在平面的任意点。当系数都为正的时候表示点在三角形内。</p><p><img src="/article_img/2022-08-29-16-22-31.png"></p><h1 id="加速结构"><a href="#加速结构" class="headerlink" title="加速结构"></a>加速结构</h1><h2 id="Bounding-Volumes-包围盒"><a href="#Bounding-Volumes-包围盒" class="headerlink" title="Bounding Volumes(包围盒)"></a>Bounding Volumes(包围盒)</h2><p>先判断光线是否与包围盒相交，如果不与包围盒相交那就不可能与物体相交。</p><p><img src="/article_img/2022-10-11-18-08-40.png"></p><h2 id="Axis-Aligned-Bounding-Box-AABB"><a href="#Axis-Aligned-Bounding-Box-AABB" class="headerlink" title="Axis-Aligned Bounding Box(AABB)"></a>Axis-Aligned Bounding Box(AABB)</h2><p>为了简化计算，包围盒都使用轴对齐包围盒。</p><p><img src="/article_img/2022-10-11-18-10-27.png"></p><h3 id="与轴对齐包围盒求交"><a href="#与轴对齐包围盒求交" class="headerlink" title="与轴对齐包围盒求交"></a>与轴对齐包围盒求交</h3><p><img src="/article_img/2022-10-11-18-12-37.png"></p><p>将包围盒想象成三对平面围成的，分别用光线与每对平面求交，得到光线进入这对平面的时间 tmin 和射出这对平面的时间 tmax（负值也可以，这里先将光线看作直线）。</p><p><strong>思考</strong>：<br>光线进入包围盒<strong>仅当</strong>光线进入所有三对平面<br>光线射出包围盒<strong>直到</strong>光线离开所有三对平面</p><p>因此，就是要求最大的 tmin 和最小的 tmax：</p><p><img src="/article_img/2022-10-11-18-18-49.png"></p><p><img src="/article_img/2022-10-11-18-19-43.png"></p><h2 id="包围盒划分"><a href="#包围盒划分" class="headerlink" title="包围盒划分"></a>包围盒划分</h2><h3 id="Uniform-Grids"><a href="#Uniform-Grids" class="headerlink" title="Uniform Grids"></a>Uniform Grids</h3><p><img src="/article_img/2022-10-11-18-30-32.png"></p><p><img src="/article_img/2022-10-11-18-30-38.png"></p><p><img src="/article_img/2022-10-11-18-32-03.png"></p><p>仅仅适用于有大量物体且其均匀分布在整个场景中的情况。</p><p>e.g. 当一个场景有大量留白只有中间有一个茶壶的情况，这种划分需要光线与大量不包括任何物体的盒子求交，因此效率很低。</p><h3 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h3><p><img src="/article_img/2022-10-11-18-35-53.png"></p><p><img src="/article_img/2022-10-11-18-36-23.png"></p><p>但是这种划分有个致命的缺点：难以求得哪些表面与划分出的包围盒相交，因此引出BVH。</p><h2 id="物体划分（Bounding-Volume-Hierarchy）"><a href="#物体划分（Bounding-Volume-Hierarchy）" class="headerlink" title="物体划分（Bounding Volume Hierarchy）"></a>物体划分（Bounding Volume Hierarchy）</h2><p>为了避免统计哪些表面与包围盒相交，直接对表面进行划分，再对划分后的表面求新的包围盒。</p><p><img src="/article_img/2022-10-11-18-40-01.png"></p><p><img src="/article_img/2022-10-11-18-40-53.png"></p><p><img src="/article_img/2022-10-11-18-41-58.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=13&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">课程网址</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_13.pdf">GAMES101_Lecture_13.pdf</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf">GAMES101_Lecture_14.pdf</a>  </p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ray tracing in one weekend笔记</title>
    <link href="/2022/10/09/Ray%20tracing%20in%20one%20weekend/"/>
    <url>/2022/10/09/Ray%20tracing%20in%20one%20weekend/</url>
    
    <content type="html"><![CDATA[<p>Ray tracing in one weekend笔记</p><span id="more"></span><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in one weekend</a></p><p><a href="https://zhuanlan.zhihu.com/p/128582904">中文翻译</a></p><h1 id="输出图像"><a href="#输出图像" class="headerlink" title="输出图像"></a>输出图像</h1><p>使用ppm格式</p><p><img src="/article_img/2022-09-26-14-26-50.png"></p><p>显示ppm格式的图像使用：<a href="https://link.zhihu.com/?target=http://openseeit.sourceforge.net/">OpenSeeIt</a>，生成图像需要在cmd切换到应用程序目录并执行命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Raytracing_in_one_weekend.exe &gt; image.ppm<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-09-26-14-28-48.png"></p><h1 id="vec3类"><a href="#vec3类" class="headerlink" title="vec3类"></a>vec3类</h1><p>这里就复习一下c++语法吧</p><h2 id="const关键字小结："><a href="#const关键字小结：" class="headerlink" title="const关键字小结："></a>const关键字小结：</h2><ol><li><p>const修饰普通类型的变量，表示是一个常量，不能重新赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> a = <span class="hljs-number">10</span>;<br>b = a; <span class="hljs-comment">//正确</span><br>a = <span class="hljs-number">7</span>; <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p>const 修饰指针变量，”左定值，右定向，const修饰不变量”，就是修饰谁谁就不能被改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// const修饰指针</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;a;<br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">//正确</span><br>p = &amp;b; <span class="hljs-comment">//错误</span><br><br><span class="hljs-comment">// const修饰指针内容</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = <span class="hljs-number">9</span>;<br><br><span class="hljs-comment">// const修饰指针和指针指向的内容, 指针p和*p都不能改变</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;a;<br></code></pre></td></tr></table></figure></li><li><p>const参数传递和函数返回值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// const修饰传递的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span></span>&#123;<br>   cout&lt;&lt;a;<br>   <span class="hljs-comment">// ++a;  是错误的，a 不能被改变</span><br>&#125;<br><span class="hljs-comment">// const修饰传递的指针,防止指针被意外篡改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> * <span class="hljs-type">const</span> p)</span></span>&#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> my_class&amp; a)</span></span>&#123;<br>   cout&lt;&lt;a.<span class="hljs-built_in">class_fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>const修饰类成员函数</p><p>const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。</p></li></ol><h2 id="构造函数和运算符重载"><a href="#构造函数和运算符重载" class="headerlink" title="构造函数和运算符重载"></a>构造函数和运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">vec3</span>(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> y,<span class="hljs-type">double</span> z):e&#123;x,y,z&#125;&#123;&#125;<br><span class="hljs-comment">//运算符重载</span><br>vec3 <span class="hljs-keyword">operator</span>*=(<span class="hljs-type">int</span> t)&#123;<br>   ...<br>&#125;<br><span class="hljs-keyword">inline</span> vec3 <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> vec3&amp; u, <span class="hljs-type">const</span> vec3&amp; v) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec3</span>(u.e[<span class="hljs-number">0</span>] * v.e[<span class="hljs-number">0</span>], u.e[<span class="hljs-number">1</span>] * v.e[<span class="hljs-number">1</span>], u.e[<span class="hljs-number">2</span>] * v.e[<span class="hljs-number">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h2><p>在 c&#x2F;c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。</p><p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p><p>在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p><p><strong>inline就是把函数内容替换到函数调用处。</strong></p><p><strong>注意：inline函数里不能有while和switch，不能是递归函数</strong></p><h2 id="C-中的别名定义"><a href="#C-中的别名定义" class="headerlink" title="C++中的别名定义"></a>C++中的别名定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用别名来区分点和颜色，只是用来区分，不会有警告</span><br><span class="hljs-keyword">using</span> point3 = vec3;<br><span class="hljs-keyword">using</span> color = vec3;<br></code></pre></td></tr></table></figure><h1 id="光线，简单摄像机和背景"><a href="#光线，简单摄像机和背景" class="headerlink" title="光线，简单摄像机和背景"></a>光线，简单摄像机和背景</h1><p><img src="/article_img/2022-09-26-21-08-46.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">color <span class="hljs-title">ray_color</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r)</span> </span>&#123;<br><span class="hljs-comment">// 线性插值颜色</span><br>vec3 unit_direction = <span class="hljs-built_in">unit_vector</span>(r.<span class="hljs-built_in">direction</span>());<br><span class="hljs-keyword">auto</span> t = <span class="hljs-number">0.5</span> * (unit_direction.<span class="hljs-built_in">y</span>() + <span class="hljs-number">1.0</span>);<br>   <span class="hljs-comment">// blendedValue=(1−t)⋅startValue+t⋅endValue</span><br><span class="hljs-keyword">return</span> (<span class="hljs-number">1.0</span> - t) * <span class="hljs-built_in">color</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>) + t * <span class="hljs-built_in">color</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-09-26-21-01-37.png"></p><h1 id="添加球面"><a href="#添加球面" class="headerlink" title="添加球面"></a>添加球面</h1><p>绘制一个球心在（0，0，-1）处，半径为0.5的球。</p><p>主要在于判断球面和光线是否相交，Games101中提到的光线与隐式表面的求交问题，将光线方程带入球面方程，求t。</p><p><img src="/article_img/2022-09-27-11-50-26.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit_sphere</span><span class="hljs-params">(<span class="hljs-type">const</span> point3&amp; center, <span class="hljs-type">double</span> radius, <span class="hljs-type">const</span> ray&amp; r)</span> </span>&#123;<br><br><span class="hljs-comment">//  t2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r2=0</span><br><br>vec3 oc = r.<span class="hljs-built_in">origin</span>() - center;<br><span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">dot</span>(r.<span class="hljs-built_in">direction</span>(), r.<span class="hljs-built_in">direction</span>());<br><span class="hljs-keyword">auto</span> b = <span class="hljs-number">2</span> * <span class="hljs-built_in">dot</span>(r.<span class="hljs-built_in">direction</span>(), oc);<br><span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">dot</span>(oc, oc) - radius * radius;<br><span class="hljs-keyword">auto</span> discriminant = b * b - <span class="hljs-number">4</span> * a * c;<br><span class="hljs-keyword">return</span> (discriminant &gt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-09-27-11-50-57.png"></p><p><strong>存在的问题</strong>：若将球心放置在（0，0，1）渲染的结果和此时一样。</p><h1 id="法线和多个物体"><a href="#法线和多个物体" class="headerlink" title="法线和多个物体"></a>法线和多个物体</h1><h2 id="法线可视化"><a href="#法线可视化" class="headerlink" title="法线可视化"></a>法线可视化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">0.0</span>) &#123; <span class="hljs-comment">// 如果与球面相交直接return颜色</span><br><span class="hljs-comment">// 求得法线</span><br>vec3 N = <span class="hljs-built_in">unit_vector</span>(r.<span class="hljs-built_in">at</span>(t) - <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>));<br>     <span class="hljs-comment">// 将值映射到（0，1），尽管已经是单位向量，但是由于法线坐标会有负值，仍需要做映射</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * <span class="hljs-built_in">color</span>(N.<span class="hljs-built_in">x</span>() + <span class="hljs-number">1</span>, N.<span class="hljs-built_in">y</span>() + <span class="hljs-number">1</span>, N.<span class="hljs-built_in">z</span>() + <span class="hljs-number">1</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-09-27-13-10-42.png"></p><h2 id="hit-record结构体"><a href="#hit-record结构体" class="headerlink" title="hit_record结构体"></a>hit_record结构体</h2><p>记录光线与物体交点的信息：交点坐标，交点处法线，光线方程中的t值</p><p>以及判断光线是从哪个方向射向平面，从而<strong>设定法线方向始终与光线入射方向相反</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hit_record</span> &#123; <span class="hljs-comment">// 记录了与物体交点的信息：交点坐标，交点处法线，光线方程中的t值</span><br>point3 p;<br>vec3 normal;<br><span class="hljs-type">double</span> t;<br><br><span class="hljs-comment">// 判断光线是从哪个方向射向平面</span><br><span class="hljs-type">bool</span> front_face;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">set_face_normal</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, <span class="hljs-type">const</span> vec3&amp; outward_normal)</span> </span>&#123;<br><span class="hljs-comment">// 保证法线始终与光线入射方向相反</span><br>front_face = <span class="hljs-built_in">dot</span>(r.<span class="hljs-built_in">direction</span>(), outward_normal) &lt; <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 设置normal</span><br>normal = front_face ? outward_normal : -outward_normal;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="hittable类"><a href="#hittable类" class="headerlink" title="hittable类"></a>hittable类</h2><p>定义了一个虚函数，本书中只解决了与球面判断相交的问题，就是将线段代入球面方程看是否有解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">hittable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, <span class="hljs-type">double</span> t_min, <span class="hljs-type">double</span> t_max, hit_record&amp; rec)</span><span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="sphere类"><a href="#sphere类" class="headerlink" title="sphere类"></a>sphere类</h2><p>sphere类继承自hittable类，实现了hit函数，有两个变量：球心坐标和半径</p><h2 id="hittable-list类（Some-New-C-Features）"><a href="#hittable-list类（Some-New-C-Features）" class="headerlink" title="hittable_list类（Some New C++ Features）"></a>hittable_list类（Some New C++ Features）</h2><h2 id="渲染结果"><a href="#渲染结果" class="headerlink" title="渲染结果"></a>渲染结果</h2><p>在main函数中创建hittable_list对象world，表示场景信息，其中有一个大球一个小球（渲染结果如下），地面（大球）是绿色是因为这里的法线都是向上，观察小球的顶部也是绿色。</p><p><img src="/article_img/2022-09-27-19-39-22.png"></p><h1 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h1><p>加大采样率，在每个像素中随机采样一百次，将结果平均作为该像素的颜色。</p><p><img src="/article_img/2022-09-28-16-15-11.png"></p><p><img src="/article_img/2022-09-29-15-43-18.png"><br>将相机部分的代码封装到了camera类。</p><h1 id="漫反射材质"><a href="#漫反射材质" class="headerlink" title="漫反射材质"></a>漫反射材质</h1><p><img src="/article_img/2022-09-29-15-45-06.png"></p><p><img src="/article_img/2022-09-29-15-45-22.png"></p><p><img src="/article_img/2022-09-29-15-45-33.png"></p><p>方法1： 单位圆中随机<br>方法2： 在单位圆上随机生成<br>方法3： 直接生成反射方向  </p><p>方法1比方法2要更加真实，因为前者能让更多光线向相机方向反射，而后者更多光线会靠近法线方法，导致反射次数增加（阴影很黑），使用方法2明显渲染速度变快很多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">color <span class="hljs-title">ray_color</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, <span class="hljs-type">const</span> hittable&amp; world, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>hit_record rec;<br><br><span class="hljs-keyword">if</span> (depth &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (world.<span class="hljs-built_in">hit</span>(r,<span class="hljs-number">0.001</span>,infinity,rec))&#123; <span class="hljs-comment">// 如果与球面相交直接return颜色</span><br><span class="hljs-comment">// 求得法线</span><br><span class="hljs-comment">//return 0.5 * (rec.normal + color(1,1,1));</span><br><br><span class="hljs-comment">/* 漫反射</span><br><span class="hljs-comment">      方法1：单位圆中随机</span><br><span class="hljs-comment">point3 target = rec.p + rec.normal + random_in_unit_vector(); </span><br><span class="hljs-comment">      方法3：直接生成反射方向</span><br><span class="hljs-comment">point3 target = rec.p + random_in_hemisphere(); </span><br><span class="hljs-comment">      方法2：在单位圆上随机生成</span><br><span class="hljs-comment">      */</span><br>point3 target = rec.p + rec.normal + <span class="hljs-built_in">random_unit_vector</span>(); <br><span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * <span class="hljs-built_in">ray_color</span>(<span class="hljs-built_in">ray</span>(rec.p, target - rec.p), world, depth - <span class="hljs-number">1</span>); <br>&#125;<br><span class="hljs-comment">// 线性插值颜色</span><br>vec3 unit_direction = <span class="hljs-built_in">unit_vector</span>(r.<span class="hljs-built_in">direction</span>());<br><span class="hljs-keyword">auto</span> t = <span class="hljs-number">0.5</span> * (unit_direction.<span class="hljs-built_in">y</span>() + <span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">1.0</span> - t) * <span class="hljs-built_in">color</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>) + t * <span class="hljs-built_in">color</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>color(1,1,1)表示白色，color(0,0,0)表示黑色，这里的0.5*ray_color(…)相当于每次光线衰减50%，就是变暗一半。</p><p><img src="/article_img/2022-09-29-15-52-40.png"></p><h1 id="金属材质"><a href="#金属材质" class="headerlink" title="金属材质"></a>金属材质</h1><h2 id="材质类"><a href="#材质类" class="headerlink" title="材质类"></a>材质类</h2><p>抽象类： material类<br>继承类： metal类，lambertian类</p><p><img src="/article_img/2022-09-30-14-48-32.png"></p><h2 id="左侧球呈现镜面效果的原因："><a href="#左侧球呈现镜面效果的原因：" class="headerlink" title="左侧球呈现镜面效果的原因："></a>左侧球呈现镜面效果的原因：</h2><p>光线从相机射出，与球面相交，调用交点材质的scatter函数计算反射光线以及得到衰减率，<strong>进入递归</strong>，发现反射光线不与物体相交，即进行线性插值颜色，<strong>递归结束</strong>，得到的线性插值颜色与衰减率相乘（<strong>这就是为什么左侧球与背景颜色相似但是稍暗一些的原因</strong>），得到最终的颜色。</p><h2 id="右侧球带有颜色的原因："><a href="#右侧球带有颜色的原因：" class="headerlink" title="右侧球带有颜色的原因："></a>右侧球带有颜色的原因：</h2><p>就是因为其衰减率的RGB三个值不相同，导致有的颜色衰减的更多，就看起来有了某种颜色，而不是简单的变暗。</p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">color <span class="hljs-title">ray_color</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, <span class="hljs-type">const</span> hittable&amp; world, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>hit_record rec;<br><br><span class="hljs-keyword">if</span> (depth &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (world.<span class="hljs-built_in">hit</span>(r,<span class="hljs-number">0.001</span>,infinity,rec))&#123; <span class="hljs-comment">// 与球面相交</span><br>ray scattered;<br>color attenuation;   <span class="hljs-comment">// 衰减率</span><br><br>      <span class="hljs-comment">// 调用材质的scatter函数，得到该反射点的材质的衰减率和反射光线。</span><br><span class="hljs-keyword">if</span> (rec.mat_ptr-&gt;<span class="hljs-built_in">scatter</span>(r, rec, attenuation, scattered))<br><span class="hljs-keyword">return</span> attenuation * <span class="hljs-built_in">ray_color</span>(scattered, world, depth - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 线性插值颜色</span><br>vec3 unit_direction = <span class="hljs-built_in">unit_vector</span>(r.<span class="hljs-built_in">direction</span>());<br><span class="hljs-keyword">auto</span> t = <span class="hljs-number">0.5</span> * (unit_direction.<span class="hljs-built_in">y</span>() + <span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">1.0</span> - t) * <span class="hljs-built_in">color</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>) + t * <span class="hljs-built_in">color</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模糊反射（磨砂镜面）"><a href="#模糊反射（磨砂镜面）" class="headerlink" title="模糊反射（磨砂镜面）"></a>模糊反射（磨砂镜面）</h1><p><img src="/article_img/2022-10-08-14-55-02.png"></p><p>反射光线加一个随机的向量（在单位圆中生成）</p><p>在金属材质类（metal）中加一个属性：磨砂系数（fuzz）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">scattered = <span class="hljs-built_in">ray</span>(rec.p, reflected + fuzz * <span class="hljs-built_in">random_in_unit_sphere</span>());<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-10-08-14-54-52.png"></p><h1 id="电解质（透明物体）"><a href="#电解质（透明物体）" class="headerlink" title="电解质（透明物体）"></a>电解质（透明物体）</h1><h2 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h2><p><img src="/article_img/2022-10-09-14-06-32.png"></p><p>一次折射会让场景颠倒</p><h2 id="Schlick近似"><a href="#Schlick近似" class="headerlink" title="Schlick近似"></a>Schlick近似</h2><p>现实世界中的玻璃, 发生折射的概率会随着入射角而改变——从一个很狭窄的角度去看玻璃窗, 它会变成一面镜子。</p><h2 id="中空球"><a href="#中空球" class="headerlink" title="中空球"></a>中空球</h2><p>将球的半径设置为负值，几何形状不会改变，但是法相全部反转到内部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">world.<span class="hljs-built_in">add</span>(<span class="hljs-built_in">make_shared</span>&lt;sphere&gt;(<span class="hljs-built_in">point3</span>(<span class="hljs-number">-1.0</span>,    <span class="hljs-number">0.0</span>, <span class="hljs-number">-1.0</span>),  <span class="hljs-number">-0.4</span>, material_left));<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-10-09-14-25-53.png"></p><h1 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h1><h2 id="相机可视角度（Field-of-View）"><a href="#相机可视角度（Field-of-View）" class="headerlink" title="相机可视角度（Field of View）"></a>相机可视角度（Field of View）</h2><p>这里的可视角度是竖直方向上的可视角度，实际水平也可以。有了 FOV 再根据宽高比就能求出视图的宽高值。</p><p><img src="/article_img/2022-10-09-14-28-04.png"></p><h2 id="相机的定位定向"><a href="#相机的定位定向" class="headerlink" title="相机的定位定向"></a>相机的定位定向</h2><p><img src="/article_img/2022-10-09-14-51-30.png"></p><p><img src="/article_img/2022-10-09-14-51-38.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> w = <span class="hljs-built_in">unit_vector</span>(lookfrom - lookat);<br><span class="hljs-keyword">auto</span> u = <span class="hljs-built_in">unit_vector</span>(<span class="hljs-built_in">cross</span>(vup, w));<br><span class="hljs-keyword">auto</span> v = <span class="hljs-built_in">cross</span>(w, u);<br></code></pre></td></tr></table></figure><p>这里就是要新建一个坐标系，经过以上代码的运算，得到一个新的坐标系：相机看向-w方向，相机的向上方向是v，还有一个水平的方向u。</p><p>改变camera类，可以设定相机的位置和相机看向的方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">camera <span class="hljs-title">cam</span><span class="hljs-params">(point3(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>), point3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>), vec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">90</span>, aspect_ratio)</span></span>;<br></code></pre></td></tr></table></figure><p><img src="/article_img/2022-10-09-14-52-21.png"></p><h1 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h1><p><img src="/article_img/2022-10-09-15-26-37.png"></p><h1 id="常看常新"><a href="#常看常新" class="headerlink" title="常看常新"></a>常看常新</h1><h2 id="成像平面"><a href="#成像平面" class="headerlink" title="成像平面"></a>成像平面</h2><p>之前在我的印象中光线追踪模型应该是下图这样的，摄像机和成像平面在整个场景之前，但其实成像平面在哪并没有什么关系，本例的成像平面就与物体在同一深度。</p><p><img src="/article_img/2022-10-29-18-15-59.png"></p><p>仔细一想，成像平面的意义在于确定从相机发出的路径，所以如下图所示，只要成像平面的面积与平面到相机的距离成比例变化，其实发出的路径都是一样的，都在图示的锥体中。</p><p><img src="/article_img/2022-10-29-18-20-06.png"></p><p>而FOV实际上也是在改变这个锥体，FOV越大，成像平面也就越大（平面到相机的垂直相同的情况下）。</p><p>关于FOV还有一个有趣的观察，在这个光线追踪例子中，FOV越小，最终得到的图像和真正将相机离物体很近拍出的图像一模一样。而在现实中（如下图）我们可以轻易的分辨出是从很近的地方拍照还是通过变焦从很远的地方拍照（会明显模糊），而在本例子中并不会产生模糊。原因在于现实中的相机焦距不是任意可调的，理论上来说，拍摄越远的物体，相机内部的成像平面也应该离透镜越远，而真实的相机大小是有限的，因此会产生模糊，在本文中的虚拟的透镜焦距确实是可以任意调整的，因此并不会模糊，就像在很近的距离拍摄的一样，物体又大又清晰。</p><p><img src="/article_img/2022-10-29-13-44-32.png"></p>]]></content>
    
    
    <categories>
      
      <category>-[Ray Tracing 笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-4-着色</title>
    <link href="/2022/08/25/Games101-4-%E7%9D%80%E8%89%B2/"/>
    <url>/2022/08/25/Games101-4-%E7%9D%80%E8%89%B2/</url>
    
    <content type="html"><![CDATA[<p>Games101-4-着色</p><span id="more"></span><h1 id="着色模型（Blinn-Phong-Reflectance-Model）"><a href="#着色模型（Blinn-Phong-Reflectance-Model）" class="headerlink" title="着色模型（Blinn-Phong Reflectance Model）"></a>着色模型（Blinn-Phong Reflectance Model）</h1><p>根据感性观察有：  </p><ol><li>Specular highlights (镜面反射高光)</li><li>Diffuse reflection (漫反射)</li><li>Ambient lighting (环境光)</li></ol><p><img src="/article_img/2022-08-29-15-14-39.png"></p><h2 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h2><p>认为漫反射是均匀的向各个方向反射的</p><p><img src="/article_img/2022-08-29-15-18-27.png"></p><p><img src="/article_img/2022-08-29-15-18-42.png"></p><p>由上图以及地球的季节变化可知，光线直射方向和平面的夹角决定接受光的能量的多少。</p><p><img src="/article_img/2022-08-29-15-20-23.png"></p><p>光的能量也与距离光源的距离有关，与距光源的距离的平方成反比。</p><p><img src="/article_img/2022-08-29-15-23-14.png"></p><p>法线n·入射光l &#x3D; cos夹角</p><p>kd 表示该shading point的颜色（之后texture贴图就是改变kd的值）</p><p><strong>漫反射的着色与观测角度无关</strong> 也就是说无论在哪个方向观测，同一个着色点的颜色总是相同。例如：月球表面</p><h2 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h2><p><img src="/article_img/2022-08-29-15-35-09.png"></p><p><strong>镜面反射与观测角度有关</strong> 纯镜面即完全按照镜面反射规律进行反射，若是光滑一些的物体如金属，是在镜面反射出射光线的一个角度范围内可见。</p><p><img src="/article_img/2022-08-29-15-38-15.png"></p><p>h是半程向量，这里的bisector是OpenGL中的函数(平行四边形法则)。指数p就是为了控制出射光线的可见角度范围，一般p为200左右（出射光线的左右5-6度）</p><p><img src="/article_img/2022-08-29-15-39-32.png"></p><h2 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h2><p>在Blinn-Phong这个经验模型中，环境光被认为与任何东西都无关，即是一个常量。</p><p>将三种光照相加即可得到最终的着色结果。</p><p><img src="/article_img/2022-08-29-15-42-40.png"></p><h1 id="着色频率（Shading-Frequencies）"><a href="#着色频率（Shading-Frequencies）" class="headerlink" title="着色频率（Shading Frequencies）"></a>着色频率（Shading Frequencies）</h1><p><img src="/article_img/2022-08-29-15-48-55.png"></p><h2 id="flat-shading"><a href="#flat-shading" class="headerlink" title="flat shading"></a>flat shading</h2><p>对每个<strong>三角形</strong>进行着色</p><p>每一个三角形有一条法线。</p><p><img src="/article_img/2022-08-29-15-49-44.png"></p><h2 id="Gouraud-shading"><a href="#Gouraud-shading" class="headerlink" title="Gouraud shading"></a>Gouraud shading</h2><p>对每个<strong>顶点</strong>进行着色</p><p>对三角形内部的点，根据三个顶点的颜色进行颜色插值，每一个顶点有一条法线。</p><p><img src="/article_img/2022-08-29-15-50-45.png"></p><h2 id="Phong-shading"><a href="#Phong-shading" class="headerlink" title="Phong shading"></a>Phong shading</h2><p>对每个<strong>像素</strong>进行着色</p><p>对三角形内部的点，根据三个顶点的法线进行法线插值，计算出每一个像素的法线。</p><p><img src="/article_img/2022-08-29-15-51-54.png"></p><h2 id="法线定义方法"><a href="#法线定义方法" class="headerlink" title="法线定义方法"></a>法线定义方法</h2><p><img src="/article_img/2022-08-29-16-17-54.png"></p><p><img src="/article_img/2022-08-29-16-18-04.png"></p><p>利用重心坐标插值</p><h1 id="重心坐标（Barycentric-Coordinates）"><a href="#重心坐标（Barycentric-Coordinates）" class="headerlink" title="重心坐标（Barycentric Coordinates）"></a>重心坐标（Barycentric Coordinates）</h1><p><img src="/article_img/2022-08-29-16-22-31.png"></p><p><img src="/article_img/2022-08-29-16-23-23.png"></p><p>系数均为1&#x2F;3时，就是三角形的重心。</p><p><img src="/article_img/2022-08-29-16-24-37.png"></p><p><img src="/article_img/2022-08-29-16-24-47.png"></p><p>插值可以对任何属性进行插值，例如颜色，纹理，法线，深度等等。</p><p>重心坐标在投影变换后无法保证依然正确，因此要在投影变换之前进行插值，也就是要用空间中的坐标进行计算。</p><h1 id="图形（实时渲染）管线"><a href="#图形（实时渲染）管线" class="headerlink" title="图形（实时渲染）管线"></a>图形（实时渲染）管线</h1><p><img src="/article_img/2022-08-29-16-29-49.png"></p><h1 id="Texture-Mapping-应用纹理"><a href="#Texture-Mapping-应用纹理" class="headerlink" title="Texture Mapping &amp; 应用纹理"></a>Texture Mapping &amp; 应用纹理</h1><p><img src="/article_img/2022-08-29-16-32-11.png"></p><p><img src="/article_img/2022-08-29-16-32-22.png"></p><p><img src="/article_img/2022-08-29-18-30-33.png"></p><h1 id="Texture-Magnification-纹理过大过小问题"><a href="#Texture-Magnification-纹理过大过小问题" class="headerlink" title="Texture Magnification (纹理过大过小问题)"></a>Texture Magnification (纹理过大过小问题)</h1><h2 id="纹理分辨率过小"><a href="#纹理分辨率过小" class="headerlink" title="纹理分辨率过小"></a>纹理分辨率过小</h2><p><img src="/article_img/2022-08-29-18-33-36.png"></p><p>Bilinear Interpolation (双线性插值)</p><p><img src="/article_img/2022-08-29-18-33-20.png"></p><h2 id="纹理分辨率过大"><a href="#纹理分辨率过大" class="headerlink" title="纹理分辨率过大"></a>纹理分辨率过大</h2><p><img src="/article_img/2022-08-29-18-35-15.png"></p><p><img src="/article_img/2022-08-29-18-35-24.png"></p><p>问题在于一个像素里包含了很大一片纹理，而仅用一个纹理上的采样点代表这一片纹理。<strong>超采样</strong>（Supersampling）当让可以解决这个问题，但是消耗太大。为了解决这种问题就引入了Mipmap。</p><h2 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h2><p><img src="/article_img/2022-08-29-18-41-41.png"></p><p><img src="/article_img/2022-08-29-18-41-51.png"></p><p>mipmap的思路是避免采样，直接得到一片区域的平均值，提前生成不同分辨率的图像，之后用这些生成的低分辨率图像代表这一片区域的平均，mipmap多消耗的存储空间是原来的三分之一。</p><p><img src="/article_img/2022-08-29-18-44-02.png"></p><p><img src="/article_img/2022-08-29-18-52-05.png"></p><p>之后进行trilinear插值，让mipmap的level可以平滑过渡。得到下图的可视化结果。</p><p><img src="/article_img/2022-08-29-18-53-37.png"></p><h2 id="Mipmap的局限"><a href="#Mipmap的局限" class="headerlink" title="Mipmap的局限"></a>Mipmap的局限</h2><p><img src="/article_img/2022-08-29-18-54-29.png"></p><p><img src="/article_img/2022-08-29-18-54-37.png"></p><p>由于Mipmap是用一个正方形区域近似真正被像素覆盖的区域，对上图这种长条形的区域就无法取得比较好的近似效果，就会产生过度模糊。</p><p>为了避免过度模糊，引入了各向异性过滤。</p><p><img src="/article_img/2022-08-29-18-56-35.png"></p><h1 id="环境贴图"><a href="#环境贴图" class="headerlink" title="环境贴图"></a>环境贴图</h1><p><img src="/article_img/2022-08-29-19-00-41.png"></p><p><img src="/article_img/2022-08-29-19-00-52.png"></p><h1 id="凹凸-法线贴图（Bump-normal-mapping）"><a href="#凹凸-法线贴图（Bump-normal-mapping）" class="headerlink" title="凹凸&#x2F;法线贴图（Bump&#x2F;normal mapping）"></a>凹凸&#x2F;法线贴图（Bump&#x2F;normal mapping）</h1><p><img src="/article_img/2022-08-29-19-04-50.png"></p><p><img src="/article_img/2022-08-29-19-06-16.png"></p><p>先求出p点的切线向量，之后旋转九十度就可得到新的法线向量。</p><p><img src="/article_img/2022-08-29-19-06-26.png"></p><p>3d坐标原理类似。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=9&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">课程网址</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf">GAMES101_Lecture_07.pdf</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_08.pdf">GAMES101_Lecture_08.pdf</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_09.pdf">GAMES101_Lecture_09.pdf</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_10.pdf">GAMES101_Lecture_10.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-3-光栅化</title>
    <link href="/2022/08/01/Games101-3-%E5%85%89%E6%A0%85%E5%8C%96/"/>
    <url>/2022/08/01/Games101-3-%E5%85%89%E6%A0%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Games101-3-光栅化</p><span id="more"></span><h1 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h1><p><img src="/article_img/2022-08-03-20-33-50.png"></p><h1 id="反走样（抗锯齿）"><a href="#反走样（抗锯齿）" class="headerlink" title="反走样（抗锯齿）"></a>反走样（抗锯齿）</h1><p>走样现象</p><p><img src="/article_img/2022-08-26-15-10-45.png"></p><p>锯齿的出现一般是由于采样率不足导致的。</p><p><img src="/article_img/2022-08-26-15-16-08.png"></p><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p><img src="/article_img/2022-08-26-15-12-11.png"></p><p>采样瑕疵的出现是由于信号变化过快而采样频率太慢导致。</p><h2 id="反走样方法——先模糊后采样"><a href="#反走样方法——先模糊后采样" class="headerlink" title="反走样方法——先模糊后采样"></a>反走样方法——先模糊后采样</h2><p><img src="/article_img/2022-08-26-15-13-22.png"></p><p>注意：先采样后模糊是错误的，不能达到反走样的效果。</p><p><img src="/article_img/2022-08-27-09-09-18.png"></p><p>模糊操作是通过卷积操作实现的，即取平均。</p><p>采样可以看作是频率的重复，走样现象是频率重叠导致，故可以先滤掉高频，再进行采样，也就是先模糊后采样。</p><p><img src="/article_img/2022-08-27-09-10-34.png"></p><p><img src="/article_img/2022-08-27-09-10-47.png"></p><h1 id="反走样的具体方法"><a href="#反走样的具体方法" class="headerlink" title="反走样的具体方法"></a>反走样的具体方法</h1><p><img src="/article_img/2022-08-27-09-14-04.png"></p><h2 id="MSAA"><a href="#MSAA" class="headerlink" title="MSAA"></a>MSAA</h2><p>MSAA就是加大采样率，从而达到抗锯齿的效果。</p><p><img src="/article_img/2022-08-27-09-15-15.png"></p><p>实际应用中，MSAA的采样点一般是不规则的，对一些采样点进行了复用，从而提高效率。</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p><img src="/article_img/2022-08-27-09-17-28.png"></p><h1 id="可见性-遮挡（Z-buffering）"><a href="#可见性-遮挡（Z-buffering）" class="headerlink" title="可见性&#x2F;遮挡（Z-buffering）"></a>可见性&#x2F;遮挡（Z-buffering）</h1><p><img src="/article_img/2022-08-27-09-21-07.png"></p><p><img src="/article_img/2022-08-27-09-21-26.png"></p><p><img src="/article_img/2022-08-27-09-21-42.png"></p><p>Z-buffering 时间复杂度为O(n)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">课程网址</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_05.pdf">GAMES101_Lecture_05.pdf</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_06.pdf">GAMES101_Lecture_06.pdf</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf">GAMES101_Lecture_07.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-2-变换</title>
    <link href="/2022/07/21/Games101-2-%E5%8F%98%E6%8D%A2/"/>
    <url>/2022/07/21/Games101-2-%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>Games101-2-变换， 对应Games101第三、四节课</p><span id="more"></span><h1 id="Games101现代计算机图形学入门-3"><a href="#Games101现代计算机图形学入门-3" class="headerlink" title="Games101现代计算机图形学入门-3"></a>Games101现代计算机图形学入门-3</h1><p><img src="/article_img/2022-10-15-15-38-04.png"></p><h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><h2 id="切变"><a href="#切变" class="headerlink" title="切变"></a>切变</h2><p><img src="/article_img/2022-08-01-18-08-53.png"></p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p><img src="/article_img/2022-08-01-18-15-35.png"></p><p>旋转-a角度的矩阵就是旋转a角度的转置矩阵，也是逆矩阵</p><h1 id="仿射变换（齐次坐标）"><a href="#仿射变换（齐次坐标）" class="headerlink" title="仿射变换（齐次坐标）"></a>仿射变换（齐次坐标）</h1><p>为了解决平移变换不能简单写成矩阵相乘 <strong>x’&#x3D; Mx</strong></p><p><img src="/article_img/2022-08-01-18-23-48.png"></p><p>向量具有<strong>平移不变性</strong>，因此向量最后是0</p><p><img src="/article_img/2022-08-01-18-27-54.png"></p><p>在齐次坐标下，点+点表示这两点的中点</p><p><img src="/article_img/2022-08-01-18-34-08.png"></p><p><strong>逆变换对应逆矩阵</strong></p><h1 id="变换的组合"><a href="#变换的组合" class="headerlink" title="变换的组合"></a>变换的组合</h1><p><img src="/article_img/2022-08-01-18-43-06.png"></p><h1 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h1><p><img src="/article_img/2022-08-01-18-50-39.png"></p><p><img src="/article_img/2022-08-01-18-53-06.png"></p><p><strong>对这种矩阵来说，是先线性变换后仿射变换</strong></p><h2 id="三维旋转"><a href="#三维旋转" class="headerlink" title="三维旋转"></a>三维旋转</h2><p><img src="/article_img/2022-08-01-20-43-53.png"></p><p>基于右手螺旋定则，y由z叉乘x得到，固正好相反</p><p><img src="/article_img/2022-08-03-10-12-36.png"></p><h3 id="罗格里德斯旋转公式"><a href="#罗格里德斯旋转公式" class="headerlink" title="罗格里德斯旋转公式"></a>罗格里德斯旋转公式</h3><p><img src="/article_img/2022-08-03-10-22-45.png"></p><h1 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h1><p>确定相机位置</p><p><img src="/article_img/2022-08-03-10-31-16.png"></p><p><img src="/article_img/2022-08-03-10-39-27.png"></p><p>将任意向量旋转到标准轴困难，故做逆操作，将标准轴转到任意向量，之后对旋转矩阵做逆变换，恰好旋转矩阵是<strong>正交矩阵</strong>，其逆矩阵就是转置矩阵。</p><h1 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h1><h2 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h2><p><img src="/article_img/2022-08-10-16-12-45.png"></p><h2 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h2><p><img src="/article_img/2022-08-03-17-35-43.png"></p><p>推导思路：先将Frustum挤压成一个长方体，之后再做一次正交投影</p><p>推导过程：</p><p><img src="/article_img/2022-10-27-14-53-37.png"></p><p>在unity等游戏引擎中，需要在做完投影矩阵变换之后再进行 <strong>透视除法</strong>，才能将顶点变换到 <strong>归一化设备坐标 NDC（Normalized Device Coordinates）</strong> 。而在数学中点（x, y, z, w）和（x&#x2F;w, y&#x2F;w, z&#x2F;w, 1）是完全一样的，我们也就认为进行完投影变换后，变换就结束了。</p><p>在实际计算中点（x, y, z, w）和（x&#x2F;w, y&#x2F;w, z&#x2F;w, 1）虽然只是写法不同，但是会影响后续计算，所以需要将所有的（x, y, z, w）进行归一化变为（x&#x2F;w, y&#x2F;w, z&#x2F;w, 1），这一步操作叫做 <strong>透视除法</strong>，在渲染流水线中在顶点着色器输出之后进行。<br><img src="/article_img/2023-07-07-15-30-15.png"></p><h2 id="视锥"><a href="#视锥" class="headerlink" title="视锥"></a>视锥</h2><p><img src="/article_img/2022-08-03-20-29-06.png"></p><ol><li>aspect ratio: 宽高比（观测角度）</li><li>Field of View(fovY): 可视角度</li></ol><p><img src="/article_img/2022-08-11-08-56-46.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/article_img/2023-07-08-17-19-44.png"></p><h1 id="homework0"><a href="#homework0" class="headerlink" title="homework0"></a>homework0</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45◦，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。</span><br><span class="hljs-comment">// 定义点P</span><br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">2.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>)</span></span>;<br><span class="hljs-comment">// 旋转矩阵</span><br>Eigen::Matrix3f rotation;<br>rotation &lt;&lt;<br>   std::<span class="hljs-built_in">cos</span>(<span class="hljs-number">45.0</span> / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>)), -std::<span class="hljs-built_in">sin</span>(<span class="hljs-number">45.0</span> / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>)), <span class="hljs-number">0</span>,<br>   std::<span class="hljs-built_in">sin</span>(<span class="hljs-number">45.0</span> / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>)), std::<span class="hljs-built_in">cos</span>(<span class="hljs-number">45.0</span> / <span class="hljs-number">180.0</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>)), <span class="hljs-number">0</span>,<br>   <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 平移矩阵</span><br>Eigen::Matrix3f trans;<br>trans &lt;&lt;<br>   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>   <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>   <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 变换</span><br>std::cout &lt;&lt; trans * rotation * p;<br></code></pre></td></tr></table></figure><p>重点关注点，向量和矩阵定义的方法</p><h1 id="homework1"><a href="#homework1" class="headerlink" title="homework1"></a>homework1</h1><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// get_model_matrix(float rotation_angle)</span><br><br>   Eigen::Matrix4f model = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br><br>   <span class="hljs-type">float</span> angle = rotation_angle / <span class="hljs-number">180.0f</span> * <span class="hljs-number">3.14</span>;<br>   <span class="hljs-type">float</span> c = <span class="hljs-built_in">cosf</span>(angle);<br>   <span class="hljs-type">float</span> s = <span class="hljs-built_in">sinf</span>(angle);<br>   Eigen::Matrix4f rotation;<br>   rotation &lt;&lt;<br>      c, -s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>      s, c, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br>   model = model * rotation;<br><br><br><span class="hljs-comment">// get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</span><br><br>   <span class="hljs-type">float</span> n, f, t, b, r, l;<br>   t = <span class="hljs-built_in">abs</span>(zNear) * <span class="hljs-built_in">tanf</span>((eye_fov * <span class="hljs-number">3.14</span> / <span class="hljs-number">180.0</span>) / <span class="hljs-number">2</span>);<br>   r = aspect_ratio * t;<br>   b = -t;<br>   l = -r;<br>   n = -zNear;<br>   f = -zFar;<br><br>   Eigen::Matrix4f projection = Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br><br>   Eigen::Matrix4f trans, scale, p2o, prep;<br>   trans &lt;&lt;<br>      <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -(r + l) / <span class="hljs-number">2</span>,<br>      <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -(t + b) / <span class="hljs-number">2</span>,<br>      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -(n + f) / <span class="hljs-number">2</span>,<br>      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br>   scale &lt;&lt;<br>      <span class="hljs-number">2</span> / (r - l), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>      <span class="hljs-number">0</span>, <span class="hljs-number">2</span> / (t - b), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> / (n - f), <span class="hljs-number">0</span>,<br>      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br>   p2o &lt;&lt;<br>      n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>      <span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n + f, -(n * f),<br>      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>;<br><br>   projection =  trans * scale * p2o * projection;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="/article_img/2022-08-11-11-15-21.png"><br>注意：</p><ol><li>角度要进行转换</li><li>一开始绘制的三角形是倒着的，是因为默认zNear和zFar是正值，但实际上其均为负值，故对其取负值。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">课程网址</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_03.pdf">GAMES101_Lecture_03.pdf</a><br><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_04.pdf">GAMES101_Lecture_04.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-1-线代基础</title>
    <link href="/2022/07/20/Games101-1-%E7%BA%BF%E4%BB%A3%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/20/Games101-1-%E7%BA%BF%E4%BB%A3%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Games101-1-线代基础</p><span id="more"></span><h1 id="Games101现代计算机图形学入门-2"><a href="#Games101现代计算机图形学入门-2" class="headerlink" title="Games101现代计算机图形学入门-2"></a>Games101现代计算机图形学入门-2</h1><h1 id="线性代数基础知识"><a href="#线性代数基础知识" class="headerlink" title="线性代数基础知识"></a>线性代数基础知识</h1><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><h3 id="点乘计算方法"><a href="#点乘计算方法" class="headerlink" title="点乘计算方法"></a>点乘计算方法</h3><p><img src="/article_img/2022-07-21-13-46-46.png"></p><p>点乘常用来计算两个向量间的<strong>夹角</strong></p><p><img src="/article_img/2022-07-21-13-53-30.png"></p><p>点乘常用来计算一个向量在另一个向量上的<strong>投影</strong>，借助这个可以将向量进行分解</p><p><img src="/article_img/2022-07-21-13-55-49.png"></p><p>判断<strong>前和后</strong>：点乘正值表示在前，点乘负值表示在后，点乘0表示垂直</p><p>判断两个向量的<strong>接近程度</strong>：越接近点乘值越接近1，越远离点乘值越接近-1（都是单位向量）</p><p><img src="/article_img/2022-07-21-14-00-29.png"></p><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><h3 id="右手定则"><a href="#右手定则" class="headerlink" title="右手定则"></a><strong>右手定则</strong></h3><p>用来判断结果向量的方向</p><p><img src="/article_img/2022-07-21-14-08-35.png"></p><h3 id="叉乘运算规律"><a href="#叉乘运算规律" class="headerlink" title="叉乘运算规律"></a>叉乘运算规律</h3><p><img src="/article_img/2022-07-21-14-10-55.png"></p><h3 id="叉乘在代数中的计算法则"><a href="#叉乘在代数中的计算法则" class="headerlink" title="叉乘在代数中的计算法则"></a>叉乘在代数中的计算法则</h3><p><img src="/article_img/2022-07-21-14-12-24.png"></p><h3 id="叉乘的作用"><a href="#叉乘的作用" class="headerlink" title="叉乘的作用"></a>叉乘的作用</h3><ol><li>判断左和右： 正左负右</li><li>判定内与外<br> <img src="/article_img/2022-07-21-14-15-24.png"></li></ol><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><ol><li>矩阵的乘法</li><li>矩阵的转置</li><li>单位矩阵和逆矩阵</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20">课程视频</a></p><p><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">课程网址</a></p>]]></content>
    
    
    <categories>
      
      <category>-[Games101笔记]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Games101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3DSlicer配置与编译</title>
    <link href="/2022/06/19/3DSlicer%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91/"/>
    <url>/2022/06/19/3DSlicer%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>3DSlicer配置与编译</p><span id="more"></span><h1 id="3DSlicer配置与编译"><a href="#3DSlicer配置与编译" class="headerlink" title="3DSlicer配置与编译"></a>3DSlicer配置与编译</h1><h2 id="1-安装编译所需工具"><a href="#1-安装编译所需工具" class="headerlink" title="1.安装编译所需工具"></a>1.安装编译所需工具</h2><p>参考<a href="https://slicer.readthedocs.io/en/latest/developer_guide/build_instructions/windows.html">官方文档</a>和<a href="https://blog.csdn.net/yaoxingdong/article/details/108051384">CSDN文档</a></p><p><img src="/article_img/2022-05-30-18-51-12.png"></p><h3 id="个人版本"><a href="#个人版本" class="headerlink" title="个人版本:"></a>个人版本:</h3><p>CMake 3.23.2<br>Git 2.26.2<br>VS 2022 (最好安装所有与V143和CMake相关的包，防止编译出错)<br>Qt 5.15.2 (Qt必须5.15以上版本，但Qt6取消了Qt Script，没有尝试是否有影响)<br>NSIS  </p><p>Qt 5.15开始官方取消离线安装包，需要用<br><a href="http://download.qt.io/official_releases/online_installers/">在线下载工具</a></p><p>第一次登录时注意选择个人用户，否则会自动下载商业版。</p><h2 id="2-按照官方文档开始编译"><a href="#2-按照官方文档开始编译" class="headerlink" title="2. 按照官方文档开始编译"></a>2. 按照官方文档开始编译</h2><p>可能会报错</p><p><img src="/article_img/2022-05-30-19-01-47.png"></p><p><img src="/article_img/2022-05-30-19-02-18.png"></p><p><img src="/article_img/2022-05-30-19-03-35.png"></p><p>将箭头所指处换成\git\Git\usr\bin\patch.exe  <strong>git安装位置因人而异</strong>， 之后继续点击<strong>Configure</strong>直到方框中红色项全部变为白色，之后后点击<strong>generate</strong>生成。</p><p>之后点击<strong>Open Project</strong>，将<strong>All_BUILD</strong>设为启动项目。再点击生成，之后可能要等待非常长的时间，生成的文件也会很大，大约50G。</p><p><img src="/article_img/2022-05-30-19-12-19.png"></p><p>很幸运没什么问题生成完成了，如果之后再次生成有什么问题可以参考开头的博客（<br><img src="/article_img/2022-05-31-14-18-58.png"></p><h2 id="3-打开文件"><a href="#3-打开文件" class="headerlink" title="3. 打开文件"></a>3. 打开文件</h2><p>编译全部成功之后，会在 \S4D\Slicer-build 目录下生成一个 Slicer.exe 的可执行文件，双击即可打开3D-slicer 程序。</p><p><img src="/article_img/2022-05-31-15-48-06.png"></p><p>这只是一个启动程序，用来配置环境变量之类的，看到下图等一会就会启动3DSlicer软件了。</p><p><img src="/article_img/2022-05-31-15-45-30.png"></p><p>3Dslicer启动之后这个窗口也不能关闭</p><p><img src="/article_img/2022-05-31-15-48-55.png"></p><p><strong>标志着我们编译成功了！！！</strong></p><h2 id="4-进行测试（可能可以跳过）"><a href="#4-进行测试（可能可以跳过）" class="headerlink" title="4. 进行测试（可能可以跳过）"></a>4. 进行测试（可能可以跳过）</h2><p>根据官方文档进行操作</p><p><img src="/article_img/2022-05-31-15-59-31.png"></p><p>打开CMD，切换到 \S4D\Slicer-build 目录，运行<strong>Slicer.exe –VisualStudioProject</strong>命令，之后会启动VS 2022</p><p>文档中的Select build configuration指：<br><img src="/article_img/2022-05-31-16-12-50.png"></p><p>开始生成之后，会自动执行600多个测试，期间会不断跳出各种测试窗口，不用理会（这个过程也很长，不做好像也没什么。。）</p><p><img src="/article_img/2022-05-31-16-22-07.png"></p><p>可能会报错，先点击重试，会自动跳过（也不一定用到报错的这个功能）</p><p><img src="/article_img/2022-05-31-16-23-44.png"></p><p><strong>之后就可以正常使用了</strong></p>]]></content>
    
    
    <categories>
      
      <category>-[3DSlicer]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3DSlicer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown用法简介</title>
    <link href="/2022/04/06/Markdown%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/04/06/Markdown%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>本文章用来练习hexo写博客，顺便练习Markdown语法。</p><span id="more"></span><p>taskkill &#x2F;F &#x2F;IM node.exe<br>hexo创建新博客文章：hexo new “第一篇文章”</p><h1 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h1><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。旨在令人们可以专注于编辑内容，而不会因为编辑格式而分心。</p><h1 id="使用的编辑工具和插件"><a href="#使用的编辑工具和插件" class="headerlink" title="使用的编辑工具和插件"></a>使用的编辑工具和插件</h1><p>因为不想多下一个软件，所以用vscode来编辑Markdown。</p><p>使用的vscode扩展：</p><ol><li><strong>Markdown ALL in One</strong>（包含几乎所有Markdown相关功能）</li><li><strong>Markdown Preview Enhanced</strong>（提供Markdown渲染后的预览，以及可以方便的导出pdf）</li><li><strong>Paste Image</strong>（直接从剪切板粘贴图片）</li><li><strong>Code Spell Checker</strong>（检查拼写错误）</li></ol><h1 id="基本的语法练习"><a href="#基本的语法练习" class="headerlink" title="基本的语法练习"></a>基本的语法练习</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>正文</p><p>空一行换行表示另起一段，<br>打两个空格再换行表示换行但不另起一段</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>两个*加粗 <strong>加粗</strong></p><p>一个*斜体 <em>斜体</em></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>一</li><li>二<ol><li>二级列表</li></ol></li></ol><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="/img/bg/asoul.jpg"><br><em>图片的说明文字（caption）原作者：未确认_Sora</em></p><p>图片并排显示</p><table><thead><tr><th><img src="/article_img/2023-01-30-20-10-34.png"></th><th><img src="/article_img/2023-01-30-20-12-26.png"></th><th><img src="/article_img/2023-01-30-20-14-01.png"></th><th><img src="/article_img/2023-01-30-20-18-46.png"></th></tr></thead></table><h2 id="公式（支持latex公式书写）"><a href="#公式（支持latex公式书写）" class="headerlink" title="公式（支持latex公式书写）"></a>公式（支持latex公式书写）</h2><p>$$<br>\lim_{x\to\ 0} \frac{sin(x)}{x}&#x3D;1<br>$$</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th align="center">向晚</th><th align="center">贝拉</th><th align="center">乃琳</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr></tbody></table><p><strong>shift+alt+f</strong> 可以格式化,让markdown编辑页面的表格同样美观</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>这是一个<a href="https://www.bilibili.com/video/BV19Z4y1k7P7?spm_id_from=333.999.0.0">链接</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>()&#123;<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="vscode插件及设置"><a href="#vscode插件及设置" class="headerlink" title="vscode插件及设置"></a>vscode插件及设置</h1><h2 id="1-paste-image"><a href="#1-paste-image" class="headerlink" title="1. paste image"></a>1. paste image</h2><p>“pasteImage.BasePath”: “${projectRoot}”</p><p>“pasteImage.path”: “${projectRoot}&#x2F;article_img”</p><p>“prefix”: “&#x2F;“</p><p>截图快捷键（windows自带）：<strong>win+shift+s</strong></p><p>粘贴快捷键：<strong>alt+ctrl+v</strong></p><h2 id="2-Preview-Markdown"><a href="#2-Preview-Markdown" class="headerlink" title="2. Preview Markdown"></a>2. Preview Markdown</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hexo.fluid-dev.com/docs/start/">Fluid主题文档</a></p><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p><p>b站视频：</p><ol><li><a href="https://www.bilibili.com/video/BV1si4y1472o?spm_id_from=333.337.search-card.all.click">教你Markdown+VSCODE实现最完美流畅写作体验</a></li><li><a href="https://www.bilibili.com/video/BV1mU4y1j72n?spm_id_from=333.999.0.0">【2021最新版】保姆级Hexo+github搭建个人博客</a></li><li><a href="https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.999.0.0">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></li></ol><p>文章：</p><ol><li>Markdown: <a href="https://www.limfx.pro/ReadArticle/57/yi-zhong-xie-zuo-de-xin-fang-fa">https://www.limfx.pro/ReadArticle/57/yi-zhong-xie-zuo-de-xin-fang-fa</a></li><li>latex书写数学公式：<a href="https://blog.csdn.net/weixin_42373330/article/details/89785443">https://blog.csdn.net/weixin_42373330/article/details/89785443</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>-[练习]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
